./test/integration/shared/database.go:type TestDatabaseConfig struct {
./test/integration/shared/database.go-	Host     string
./test/integration/shared/database.go-	Port     string
./test/integration/shared/database.go-	User     string
./test/integration/shared/database.go-	Password string
./test/integration/shared/database.go-	Database string
./test/integration/shared/database.go-	SSLMode  string
./test/integration/shared/database.go-}
./test/integration/shared/database.go-
./test/integration/shared/database.go-// GetTestDatabaseConfig returns test database configuration
./test/integration/shared/database.go-func GetTestDatabaseConfig() TestDatabaseConfig {
./test/integration/shared/database.go-	return TestDatabaseConfig{
./test/integration/shared/database.go-		Host:     getEnv("TEST_DB_HOST", "localhost"),
./test/integration/shared/database.go-		Port:     getEnv("TEST_DB_PORT", "5432"),
./test/integration/shared/database.go-		User:     getEnv("TEST_DB_USER", "test"),
./test/integration/shared/database.go-		Password: getEnv("TEST_DB_PASSWORD", "test"),
./test/integration/shared/database.go-		Database: getEnv("TEST_DB_NAME", "mcp_test"),
./test/integration/shared/database.go-		SSLMode:  getEnv("TEST_DB_SSLMODE", "disable"),
./test/integration/shared/database.go-	}
./test/integration/shared/database.go-}
./test/integration/shared/database.go-
./test/integration/shared/database.go-// GetTestDatabase returns a test database connection
./test/integration/shared/database.go-func GetTestDatabase(ctx context.Context) (*sql.DB, error) {
./test/integration/shared/database.go-	config := GetTestDatabaseConfig()
./test/integration/shared/database.go-
./test/integration/shared/database.go-	dsn := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
./test/integration/shared/database.go-		config.Host, config.Port, config.User, config.Password, config.Database, config.SSLMode)
./test/integration/shared/database.go-
./test/integration/shared/database.go-	db, err := sql.Open("postgres", dsn)
./test/integration/shared/database.go-	if err != nil {
./test/integration/shared/database.go-		return nil, fmt.Errorf("failed to open database: %w", err)
./test/integration/shared/database.go-	}
./test/integration/shared/database.go-
./test/integration/shared/database.go-	// Configure connection pool for testing
./test/integration/shared/database.go-	db.SetMaxOpenConns(10)
./test/integration/shared/database.go-	db.SetMaxIdleConns(5)
./test/integration/shared/database.go-	db.SetConnMaxLifetime(5 * time.Minute)
./test/integration/shared/database.go-
./test/integration/shared/database.go-	// Verify connection
./test/integration/shared/database.go-	if err := db.PingContext(ctx); err != nil {
./test/integration/shared/database.go-		_ = db.Close()
./test/integration/shared/database.go-		return nil, fmt.Errorf("failed to ping database: %w", err)
./test/integration/shared/database.go-	}
./test/integration/shared/database.go-
./test/integration/shared/database.go-	return db, nil
./test/integration/shared/database.go-}
./test/integration/shared/database.go-
./test/integration/shared/database.go-// RunMigrations runs database migrations
./test/integration/shared/database.go-func RunMigrations(db *sql.DB) error {
./test/integration/shared/database.go-	driver, err := postgres.WithInstance(db, &postgres.Config{})
./test/integration/shared/database.go-	if err != nil {
--
./test/e2e/connection/connection.go:type ConnectionConfig struct {
./test/e2e/connection/connection.go-	BaseURL          string
./test/e2e/connection/connection.go-	APIKey           string
./test/e2e/connection/connection.go-	TenantID         string
./test/e2e/connection/connection.go-	MaxRetries       int
./test/e2e/connection/connection.go-	RetryDelay       time.Duration
./test/e2e/connection/connection.go-	Timeout          time.Duration
./test/e2e/connection/connection.go-	TLSConfig        *tls.Config
./test/e2e/connection/connection.go-	Headers          map[string]string
./test/e2e/connection/connection.go-	CompressionLevel int
./test/e2e/connection/connection.go-}
./test/e2e/connection/connection.go-
./test/e2e/connection/connection.go-// DefaultConfig returns default connection configuration
./test/e2e/connection/connection.go-func DefaultConfig() *ConnectionConfig {
./test/e2e/connection/connection.go-	return &ConnectionConfig{
./test/e2e/connection/connection.go-		MaxRetries:       3,
./test/e2e/connection/connection.go-		RetryDelay:       2 * time.Second,
./test/e2e/connection/connection.go-		Timeout:          30 * time.Second,
./test/e2e/connection/connection.go-		CompressionLevel: 6,
./test/e2e/connection/connection.go-	}
./test/e2e/connection/connection.go-}
./test/e2e/connection/connection.go-
./test/e2e/connection/connection.go-// ConnectionManager manages WebSocket connections
./test/e2e/connection/connection.go-type ConnectionManager struct {
./test/e2e/connection/connection.go-	config *ConnectionConfig
./test/e2e/connection/connection.go-}
./test/e2e/connection/connection.go-
./test/e2e/connection/connection.go-// NewConnectionManager creates a new connection manager
./test/e2e/connection/connection.go-func NewConnectionManager(config *ConnectionConfig) *ConnectionManager {
./test/e2e/connection/connection.go-	if config == nil {
./test/e2e/connection/connection.go-		config = DefaultConfig()
./test/e2e/connection/connection.go-	}
./test/e2e/connection/connection.go-	return &ConnectionManager{config: config}
./test/e2e/connection/connection.go-}
./test/e2e/connection/connection.go-
./test/e2e/connection/connection.go-// EstablishConnection creates a new WebSocket connection
./test/e2e/connection/connection.go-func (cm *ConnectionManager) EstablishConnection(ctx context.Context) (*websocket.Conn, error) {
./test/e2e/connection/connection.go-	wsURL, err := cm.buildWebSocketURL()
./test/e2e/connection/connection.go-	if err != nil {
./test/e2e/connection/connection.go-		return nil, err
./test/e2e/connection/connection.go-	}
./test/e2e/connection/connection.go-
./test/e2e/connection/connection.go-	opts := cm.buildDialOptions()
./test/e2e/connection/connection.go-
./test/e2e/connection/connection.go-	var conn *websocket.Conn
./test/e2e/connection/connection.go-	var lastErr error
./test/e2e/connection/connection.go-
./test/e2e/connection/connection.go-	for attempt := 0; attempt <= cm.config.MaxRetries; attempt++ {
./test/e2e/connection/connection.go-		if attempt > 0 {
./test/e2e/connection/connection.go-			time.Sleep(cm.config.RetryDelay)
./test/e2e/connection/connection.go-		}
--
./test/e2e/utils/helpers.go:type Config struct {
./test/e2e/utils/helpers.go-	MCPBaseURL    string
./test/e2e/utils/helpers.go-	APIBaseURL    string
./test/e2e/utils/helpers.go-	APIKey        string
./test/e2e/utils/helpers.go-	TenantID      string
./test/e2e/utils/helpers.go-	TestTimeout   time.Duration
./test/e2e/utils/helpers.go-	MaxRetries    int
./test/e2e/utils/helpers.go-	EnableDebug   bool
./test/e2e/utils/helpers.go-	ReportDir     string
./test/e2e/utils/helpers.go-	ParallelTests int
./test/e2e/utils/helpers.go-}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-// LoadConfig loads configuration from environment variables
./test/e2e/utils/helpers.go-func LoadConfig() *Config {
./test/e2e/utils/helpers.go-	config := &Config{
./test/e2e/utils/helpers.go-		MCPBaseURL:    getEnvOrDefault("MCP_BASE_URL", "https://mcp.dev-mesh.io"),
./test/e2e/utils/helpers.go-		APIBaseURL:    getEnvOrDefault("API_BASE_URL", "https://api.dev-mesh.io"),
./test/e2e/utils/helpers.go-		APIKey:        getEnvOrDefault("E2E_API_KEY", ""),
./test/e2e/utils/helpers.go-		TenantID:      getEnvOrDefault("E2E_TENANT_ID", "e2e-test-tenant"),
./test/e2e/utils/helpers.go-		TestTimeout:   parseDurationOrDefault(getEnvOrDefault("E2E_TEST_TIMEOUT", "5m"), 5*time.Minute),
./test/e2e/utils/helpers.go-		MaxRetries:    parseIntOrDefault(getEnvOrDefault("E2E_MAX_RETRIES", "3"), 3),
./test/e2e/utils/helpers.go-		EnableDebug:   getEnvOrDefault("E2E_DEBUG", "false") == "true",
./test/e2e/utils/helpers.go-		ReportDir:     getEnvOrDefault("E2E_REPORT_DIR", "test-results"),
./test/e2e/utils/helpers.go-		ParallelTests: parseIntOrDefault(getEnvOrDefault("E2E_PARALLEL_TESTS", "5"), 5),
./test/e2e/utils/helpers.go-	}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-	// Generate API key if not provided
./test/e2e/utils/helpers.go-	if config.APIKey == "" {
./test/e2e/utils/helpers.go-		config.APIKey = fmt.Sprintf("e2e-test-key-%s", uuid.New().String())
./test/e2e/utils/helpers.go-	}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-	return config
./test/e2e/utils/helpers.go-}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-// getEnvOrDefault gets environment variable or returns default
./test/e2e/utils/helpers.go-func getEnvOrDefault(key, defaultValue string) string {
./test/e2e/utils/helpers.go-	if value := os.Getenv(key); value != "" {
./test/e2e/utils/helpers.go-		return value
./test/e2e/utils/helpers.go-	}
./test/e2e/utils/helpers.go-	return defaultValue
./test/e2e/utils/helpers.go-}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-// parseDurationOrDefault parses duration or returns default
./test/e2e/utils/helpers.go-func parseDurationOrDefault(value string, defaultDuration time.Duration) time.Duration {
./test/e2e/utils/helpers.go-	if d, err := time.ParseDuration(value); err == nil {
./test/e2e/utils/helpers.go-		return d
./test/e2e/utils/helpers.go-	}
./test/e2e/utils/helpers.go-	return defaultDuration
./test/e2e/utils/helpers.go-}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-// parseIntOrDefault parses int or returns default
--
./test/e2e/utils/helpers.go:type RetryConfig struct {
./test/e2e/utils/helpers.go-	MaxAttempts  int
./test/e2e/utils/helpers.go-	InitialDelay time.Duration
./test/e2e/utils/helpers.go-	MaxDelay     time.Duration
./test/e2e/utils/helpers.go-	Multiplier   float64
./test/e2e/utils/helpers.go-}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-// DefaultRetryConfig returns default retry configuration
./test/e2e/utils/helpers.go-func DefaultRetryConfig() RetryConfig {
./test/e2e/utils/helpers.go-	return RetryConfig{
./test/e2e/utils/helpers.go-		MaxAttempts:  3,
./test/e2e/utils/helpers.go-		InitialDelay: 1 * time.Second,
./test/e2e/utils/helpers.go-		MaxDelay:     30 * time.Second,
./test/e2e/utils/helpers.go-		Multiplier:   2.0,
./test/e2e/utils/helpers.go-	}
./test/e2e/utils/helpers.go-}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-// Retry executes a function with retry logic
./test/e2e/utils/helpers.go-func Retry(ctx context.Context, config RetryConfig, fn func() error) error {
./test/e2e/utils/helpers.go-	var lastErr error
./test/e2e/utils/helpers.go-	delay := config.InitialDelay
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-	for attempt := 0; attempt < config.MaxAttempts; attempt++ {
./test/e2e/utils/helpers.go-		if attempt > 0 {
./test/e2e/utils/helpers.go-			select {
./test/e2e/utils/helpers.go-			case <-ctx.Done():
./test/e2e/utils/helpers.go-				return ctx.Err()
./test/e2e/utils/helpers.go-			case <-time.After(delay):
./test/e2e/utils/helpers.go-			}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-			// Exponential backoff
./test/e2e/utils/helpers.go-			delay = time.Duration(float64(delay) * config.Multiplier)
./test/e2e/utils/helpers.go-			if delay > config.MaxDelay {
./test/e2e/utils/helpers.go-				delay = config.MaxDelay
./test/e2e/utils/helpers.go-			}
./test/e2e/utils/helpers.go-		}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-		if err := fn(); err != nil {
./test/e2e/utils/helpers.go-			lastErr = err
./test/e2e/utils/helpers.go-			continue
./test/e2e/utils/helpers.go-		}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-		return nil
./test/e2e/utils/helpers.go-	}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-	return fmt.Errorf("failed after %d attempts: %w", config.MaxAttempts, lastErr)
./test/e2e/utils/helpers.go-}
./test/e2e/utils/helpers.go-
./test/e2e/utils/helpers.go-// WaitFor waits for a condition to be true
./test/e2e/utils/helpers.go-func WaitFor(ctx context.Context, interval time.Duration, condition func() (bool, error)) error {
./test/e2e/utils/helpers.go-	ticker := time.NewTicker(interval)
--
./test/e2e/setup_test.go:		type TenantConfig struct {
./test/e2e/setup_test.go-			RateLimitConfig json.RawMessage `db:"rate_limit_config"`
./test/e2e/setup_test.go-			AllowedOrigins  pq.StringArray  `db:"allowed_origins"`
./test/e2e/setup_test.go-			Features        json.RawMessage `db:"features"`
./test/e2e/setup_test.go-		}
./test/e2e/setup_test.go-
./test/e2e/setup_test.go-		var config TenantConfig
./test/e2e/setup_test.go-		getConfigQuery := `
./test/e2e/setup_test.go-			SELECT 
./test/e2e/setup_test.go-				tc.rate_limit_config,
./test/e2e/setup_test.go-				tc.allowed_origins,
./test/e2e/setup_test.go-				tc.features
./test/e2e/setup_test.go-			FROM mcp.tenant_config tc
./test/e2e/setup_test.go-			JOIN mcp.tenants t ON t.id = tc.tenant_id
./test/e2e/setup_test.go-			WHERE t.name = 'E2E Test Tenant'
./test/e2e/setup_test.go-		`
./test/e2e/setup_test.go-		err = db.Get(&config, getConfigQuery)
./test/e2e/setup_test.go-		require.NoError(t, err, "Failed to get tenant config")
./test/e2e/setup_test.go-
./test/e2e/setup_test.go-		t.Logf("E2E tenant configuration found with %d allowed origins", len(config.AllowedOrigins))
./test/e2e/setup_test.go-	} else {
./test/e2e/setup_test.go-		t.Log("No tenant configuration found (using defaults)")
./test/e2e/setup_test.go-	}
./test/e2e/setup_test.go-}
./test/e2e/setup_test.go-
./test/e2e/setup_test.go-// TestMultipleAPIKeyTypes verifies different API key types are supported
./test/e2e/setup_test.go-func TestMultipleAPIKeyTypes(t *testing.T) {
./test/e2e/setup_test.go-	// Skip in CI if no database URL is provided
./test/e2e/setup_test.go-	databaseURL := os.Getenv("DATABASE_URL")
./test/e2e/setup_test.go-	if databaseURL == "" {
./test/e2e/setup_test.go-		t.Skip("DATABASE_URL not set, skipping API key types test")
./test/e2e/setup_test.go-	}
./test/e2e/setup_test.go-
./test/e2e/setup_test.go-	// Connect to database
./test/e2e/setup_test.go-	db, err := sqlx.Connect("postgres", databaseURL)
./test/e2e/setup_test.go-	require.NoError(t, err, "Failed to connect to database")
./test/e2e/setup_test.go-	defer db.Close()
./test/e2e/setup_test.go-
./test/e2e/setup_test.go-	// Check what key types exist in the database
./test/e2e/setup_test.go-	type KeyTypeCount struct {
./test/e2e/setup_test.go-		KeyType string `db:"key_type"`
./test/e2e/setup_test.go-		Count   int    `db:"count"`
./test/e2e/setup_test.go-	}
./test/e2e/setup_test.go-
./test/e2e/setup_test.go-	var keyTypes []KeyTypeCount
./test/e2e/setup_test.go-	keyTypesQuery := `
./test/e2e/setup_test.go-		SELECT key_type, COUNT(*) as count
./test/e2e/setup_test.go-		FROM mcp.api_keys
./test/e2e/setup_test.go-		WHERE is_active = true
./test/e2e/setup_test.go-		GROUP BY key_type
./test/e2e/setup_test.go-		ORDER BY key_type
--
./test/functional/webhook/mock_webhook_test.go:type MockWebhookConfig struct {
./test/functional/webhook/mock_webhook_test.go-	EnabledFlag        bool
./test/functional/webhook/mock_webhook_test.go-	GitHubEndpointVal  string
./test/functional/webhook/mock_webhook_test.go-	GitHubSecretVal    string
./test/functional/webhook/mock_webhook_test.go-	AllowedEventsVal   []string
./test/functional/webhook/mock_webhook_test.go-	IPValidationVal    bool
./test/functional/webhook/mock_webhook_test.go-	ProcessedEvents    map[string]bool
./test/functional/webhook/mock_webhook_test.go-	ErrorEvents        map[string]bool // Tracks events that should be considered errors
./test/functional/webhook/mock_webhook_test.go-	ProcessedEventsMux sync.Mutex
./test/functional/webhook/mock_webhook_test.go-}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-func (m *MockWebhookConfig) Enabled() bool {
./test/functional/webhook/mock_webhook_test.go-	return m.EnabledFlag
./test/functional/webhook/mock_webhook_test.go-}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-func (m *MockWebhookConfig) GitHubEndpoint() string {
./test/functional/webhook/mock_webhook_test.go-	return m.GitHubEndpointVal
./test/functional/webhook/mock_webhook_test.go-}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-func (m *MockWebhookConfig) GitHubSecret() string {
./test/functional/webhook/mock_webhook_test.go-	return m.GitHubSecretVal
./test/functional/webhook/mock_webhook_test.go-}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-func (m *MockWebhookConfig) GitHubIPValidationEnabled() bool {
./test/functional/webhook/mock_webhook_test.go-	return m.IPValidationVal
./test/functional/webhook/mock_webhook_test.go-}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-func (m *MockWebhookConfig) GitHubAllowedEvents() []string {
./test/functional/webhook/mock_webhook_test.go-	return m.AllowedEventsVal
./test/functional/webhook/mock_webhook_test.go-}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-// MockWebhookHandler is a simplified version of the real webhook handler for testing
./test/functional/webhook/mock_webhook_test.go-func MockWebhookHandler(config *MockWebhookConfig) http.HandlerFunc {
./test/functional/webhook/mock_webhook_test.go-	logger := observability.NewLogger("mock-webhooks")
./test/functional/webhook/mock_webhook_test.go-	return func(w http.ResponseWriter, r *http.Request) {
./test/functional/webhook/mock_webhook_test.go-		// 1. Check method
./test/functional/webhook/mock_webhook_test.go-		if r.Method != http.MethodPost {
./test/functional/webhook/mock_webhook_test.go-			http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
./test/functional/webhook/mock_webhook_test.go-			logger.Warn("Mock webhook received non-POST request", nil)
./test/functional/webhook/mock_webhook_test.go-			return
./test/functional/webhook/mock_webhook_test.go-		}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-		// 2. Validate event type
./test/functional/webhook/mock_webhook_test.go-		eventType := r.Header.Get("X-GitHub-Event")
./test/functional/webhook/mock_webhook_test.go-		if eventType == "" {
./test/functional/webhook/mock_webhook_test.go-			http.Error(w, "Missing X-GitHub-Event header", http.StatusBadRequest)
./test/functional/webhook/mock_webhook_test.go-			logger.Warn("Mock webhook missing event header", nil)
./test/functional/webhook/mock_webhook_test.go-			return
./test/functional/webhook/mock_webhook_test.go-		}
./test/functional/webhook/mock_webhook_test.go-
./test/functional/webhook/mock_webhook_test.go-		// 3. Check if event is allowed
--
./test/functional/shared/config.go:type ServiceConfig struct {
./test/functional/shared/config.go-	WebSocketURL  string
./test/functional/shared/config.go-	RestAPIURL    string
./test/functional/shared/config.go-	MockServerURL string
./test/functional/shared/config.go-	logger        observability.Logger
./test/functional/shared/config.go-}
./test/functional/shared/config.go-
./test/functional/shared/config.go-// GetTestConfig returns test configuration following CLAUDE.md patterns
./test/functional/shared/config.go-func GetTestConfig() *ServiceConfig {
./test/functional/shared/config.go-	logger := observability.NewLogger("test-config")
./test/functional/shared/config.go-
./test/functional/shared/config.go-	config := &ServiceConfig{
./test/functional/shared/config.go-		WebSocketURL:  getEnvOrDefault("MCP_WEBSOCKET_URL", "ws://localhost:8080/ws"),
./test/functional/shared/config.go-		RestAPIURL:    getEnvOrDefault("REST_API_URL", "http://localhost:8081"),
./test/functional/shared/config.go-		MockServerURL: getEnvOrDefault("MOCKSERVER_URL", "http://localhost:8082"),
./test/functional/shared/config.go-		logger:        logger,
./test/functional/shared/config.go-	}
./test/functional/shared/config.go-
./test/functional/shared/config.go-	// Log configuration for debugging (following CLAUDE.md)
./test/functional/shared/config.go-	logger.Info("Test configuration loaded", map[string]interface{}{
./test/functional/shared/config.go-		"websocket_url": config.WebSocketURL,
./test/functional/shared/config.go-		"rest_api_url":  config.RestAPIURL,
./test/functional/shared/config.go-		"mock_server":   config.MockServerURL,
./test/functional/shared/config.go-	})
./test/functional/shared/config.go-
./test/functional/shared/config.go-	return config
./test/functional/shared/config.go-}
./test/functional/shared/config.go-
./test/functional/shared/config.go-func getEnvOrDefault(key, defaultValue string) string {
./test/functional/shared/config.go-	if value := os.Getenv(key); value != "" {
./test/functional/shared/config.go-		return value
./test/functional/shared/config.go-	}
./test/functional/shared/config.go-	return defaultValue
./test/functional/shared/config.go-}
./test/functional/shared/config.go-
./test/functional/shared/config.go-// GetAuthHeaders returns common auth headers for tests
./test/functional/shared/config.go-func GetAuthHeaders(apiKey string) map[string]string {
./test/functional/shared/config.go-	return map[string]string{
./test/functional/shared/config.go-		"Authorization": fmt.Sprintf("Bearer %s", apiKey),
./test/functional/shared/config.go-		"Content-Type":  "application/json",
./test/functional/shared/config.go-	}
./test/functional/shared/config.go-}
./test/functional/shared/config.go-
./test/functional/shared/config.go-// GetTestAPIKey returns the test API key for the given tenant
./test/functional/shared/config.go-func GetTestAPIKey(tenantID string) string {
./test/functional/shared/config.go-	// Map tenant IDs to their test API keys
./test/functional/shared/config.go-	keys := map[string]string{
./test/functional/shared/config.go-		"test-tenant-1": "test-key-tenant-1",
./test/functional/shared/config.go-		"test-tenant-2": "test-key-tenant-2",
./test/functional/shared/config.go-		"dev-tenant":    "dev-admin-key-1234567890",
./test/functional/shared/config.go-		"agent-1":       "test-key-agent-1", // Same tenant, different user
--
./apps/mcp-server/internal/core/tool/plugin.go:type ToolConfig struct {
./apps/mcp-server/internal/core/tool/plugin.go-	ID               string                 `json:"id"`
./apps/mcp-server/internal/core/tool/plugin.go-	TenantID         string                 `json:"tenant_id"`
./apps/mcp-server/internal/core/tool/plugin.go-	Type             string                 `json:"type"`
./apps/mcp-server/internal/core/tool/plugin.go-	Name             string                 `json:"name"`
./apps/mcp-server/internal/core/tool/plugin.go-	DisplayName      string                 `json:"display_name"`
./apps/mcp-server/internal/core/tool/plugin.go-	BaseURL          string                 `json:"base_url"`
./apps/mcp-server/internal/core/tool/plugin.go-	DocumentationURL string                 `json:"documentation_url,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	OpenAPIURL       string                 `json:"openapi_url,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	Config           map[string]interface{} `json:"config"`
./apps/mcp-server/internal/core/tool/plugin.go-	Credential       *TokenCredential       `json:"-"` // Never serialize
./apps/mcp-server/internal/core/tool/plugin.go-	RetryPolicy      *ToolRetryPolicy       `json:"retry_policy,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	Status           string                 `json:"status"`
./apps/mcp-server/internal/core/tool/plugin.go-	HealthStatus     string                 `json:"health_status"`
./apps/mcp-server/internal/core/tool/plugin.go-	LastHealthCheck  *time.Time             `json:"last_health_check,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// TokenCredential represents authentication credentials
./apps/mcp-server/internal/core/tool/plugin.go-type TokenCredential struct {
./apps/mcp-server/internal/core/tool/plugin.go-	Type         string `json:"type"` // bearer, api_key, basic, oauth2
./apps/mcp-server/internal/core/tool/plugin.go-	Token        string `json:"token,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	Username     string `json:"username,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	Password     string `json:"password,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	APIKey       string `json:"api_key,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	HeaderName   string `json:"header_name,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	HeaderPrefix string `json:"header_prefix,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// ToolRetryPolicy extends base retry policy with tool-specific settings
./apps/mcp-server/internal/core/tool/plugin.go-type ToolRetryPolicy struct {
./apps/mcp-server/internal/core/tool/plugin.go-	MaxAttempts      int           `json:"max_attempts"`
./apps/mcp-server/internal/core/tool/plugin.go-	InitialDelay     time.Duration `json:"initial_delay"`
./apps/mcp-server/internal/core/tool/plugin.go-	MaxDelay         time.Duration `json:"max_delay"`
./apps/mcp-server/internal/core/tool/plugin.go-	Multiplier       float64       `json:"multiplier"`
./apps/mcp-server/internal/core/tool/plugin.go-	Jitter           float64       `json:"jitter"`
./apps/mcp-server/internal/core/tool/plugin.go-	RetryableErrors  []string      `json:"retryable_errors,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	RetryOnTimeout   bool          `json:"retry_on_timeout"`
./apps/mcp-server/internal/core/tool/plugin.go-	RetryOnRateLimit bool          `json:"retry_on_rate_limit"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// HealthCheckConfig defines health check settings
./apps/mcp-server/internal/core/tool/plugin.go:type HealthCheckConfig struct {
./apps/mcp-server/internal/core/tool/plugin.go-	Mode           string        `json:"mode"` // "on-demand", "active", "hybrid"
./apps/mcp-server/internal/core/tool/plugin.go-	CacheDuration  time.Duration `json:"cache_duration"`
./apps/mcp-server/internal/core/tool/plugin.go-	StaleThreshold time.Duration `json:"stale_threshold"`
./apps/mcp-server/internal/core/tool/plugin.go-	CheckTimeout   time.Duration `json:"check_timeout"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// HealthStatus represents the health of a tool
./apps/mcp-server/internal/core/tool/plugin.go-type HealthStatus struct {
./apps/mcp-server/internal/core/tool/plugin.go-	IsHealthy    bool      `json:"is_healthy"`
./apps/mcp-server/internal/core/tool/plugin.go-	LastChecked  time.Time `json:"last_checked"`
./apps/mcp-server/internal/core/tool/plugin.go-	ResponseTime int       `json:"response_time_ms"`
./apps/mcp-server/internal/core/tool/plugin.go-	Error        string    `json:"error,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	Version      string    `json:"version,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	WasCached    bool      `json:"was_cached"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// DiscoveryResult contains the results of API discovery
./apps/mcp-server/internal/core/tool/plugin.go-type DiscoveryResult struct {
./apps/mcp-server/internal/core/tool/plugin.go-	Status           string       `json:"status"`
./apps/mcp-server/internal/core/tool/plugin.go-	OpenAPISpec      *openapi3.T  `json:"-"`
./apps/mcp-server/internal/core/tool/plugin.go-	DiscoveredURLs   []string     `json:"discovered_urls"`
./apps/mcp-server/internal/core/tool/plugin.go-	Capabilities     []Capability `json:"capabilities"`
./apps/mcp-server/internal/core/tool/plugin.go-	RequiresManual   bool         `json:"requires_manual"`
./apps/mcp-server/internal/core/tool/plugin.go-	SuggestedActions []string     `json:"suggested_actions"`
./apps/mcp-server/internal/core/tool/plugin.go-	Error            string       `json:"error,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// Capability represents a discovered tool capability
./apps/mcp-server/internal/core/tool/plugin.go-type Capability struct {
./apps/mcp-server/internal/core/tool/plugin.go-	Name        string   `json:"name"`
./apps/mcp-server/internal/core/tool/plugin.go-	Description string   `json:"description"`
./apps/mcp-server/internal/core/tool/plugin.go-	Category    string   `json:"category"`
./apps/mcp-server/internal/core/tool/plugin.go-	Actions     []string `json:"actions"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// SecurityScheme represents an authentication scheme from OpenAPI
./apps/mcp-server/internal/core/tool/plugin.go-type SecurityScheme struct {
./apps/mcp-server/internal/core/tool/plugin.go-	Type         string `json:"type"`
./apps/mcp-server/internal/core/tool/plugin.go-	Scheme       string `json:"scheme,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	Name         string `json:"name,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	In           string `json:"in,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	Description  string `json:"description,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-	BearerFormat string `json:"bearer_format,omitempty"`
./apps/mcp-server/internal/core/tool/plugin.go-}
./apps/mcp-server/internal/core/tool/plugin.go-
./apps/mcp-server/internal/core/tool/plugin.go-// CredentialTemplate provides dynamic credential configuration
./apps/mcp-server/internal/core/tool/plugin.go-type CredentialTemplate struct {
./apps/mcp-server/internal/core/tool/plugin.go-	SupportedTypes []string          `json:"supported_types"`
./apps/mcp-server/internal/core/tool/plugin.go-	RequiredFields []CredentialField `json:"required_fields"`
./apps/mcp-server/internal/core/tool/plugin.go-	AuthSchemes    []SecurityScheme  `json:"auth_schemes"`
--
./apps/mcp-server/internal/config/context_manager_config.go:type ContextManagerConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	// Database connection pooling settings
./apps/mcp-server/internal/config/context_manager_config.go-	Database DatabasePoolConfig `yaml:"database"`
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-	// Multi-level cache configuration
./apps/mcp-server/internal/config/context_manager_config.go-	Cache CacheConfig `yaml:"cache"`
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-	// Circuit breaker settings for resilience
./apps/mcp-server/internal/config/context_manager_config.go-	CircuitBreaker CircuitBreakerConfig `yaml:"circuit_breaker"`
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-	// Read replica configuration for scaling
./apps/mcp-server/internal/config/context_manager_config.go-	ReadReplicas []DatabasePoolConfig `yaml:"read_replicas"`
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-	// Performance monitoring settings
./apps/mcp-server/internal/config/context_manager_config.go-	Monitoring MonitoringConfig `yaml:"monitoring"`
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// DatabasePoolConfig optimizes database connections for high concurrency
./apps/mcp-server/internal/config/context_manager_config.go:type DatabasePoolConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	DSN                 string        `yaml:"dsn"`
./apps/mcp-server/internal/config/context_manager_config.go-	MaxOpenConns        int           `yaml:"max_open_conns" default:"50"`
./apps/mcp-server/internal/config/context_manager_config.go-	MaxIdleConns        int           `yaml:"max_idle_conns" default:"25"`
./apps/mcp-server/internal/config/context_manager_config.go-	ConnMaxLifetime     time.Duration `yaml:"conn_max_lifetime" default:"5m"`
./apps/mcp-server/internal/config/context_manager_config.go-	ConnMaxIdleTime     time.Duration `yaml:"conn_max_idle_time" default:"90s"`
./apps/mcp-server/internal/config/context_manager_config.go-	HealthCheckInterval time.Duration `yaml:"health_check_interval" default:"30s"`
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// CacheConfig configures multi-level caching strategy
./apps/mcp-server/internal/config/context_manager_config.go:type CacheConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	// In-memory LRU cache settings
./apps/mcp-server/internal/config/context_manager_config.go-	InMemory InMemoryCacheConfig `yaml:"in_memory"`
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-	// Redis distributed cache settings
./apps/mcp-server/internal/config/context_manager_config.go-	Redis RedisCacheConfig `yaml:"redis"`
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-	// Cache warming configuration
./apps/mcp-server/internal/config/context_manager_config.go-	Warming CacheWarmingConfig `yaml:"warming"`
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// InMemoryCacheConfig for local high-speed caching
./apps/mcp-server/internal/config/context_manager_config.go:type InMemoryCacheConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	Enabled     bool          `yaml:"enabled" default:"true"`
./apps/mcp-server/internal/config/context_manager_config.go-	MaxSize     int           `yaml:"max_size" default:"10000"` // Number of items
./apps/mcp-server/internal/config/context_manager_config.go-	TTL         time.Duration `yaml:"ttl" default:"5m"`
./apps/mcp-server/internal/config/context_manager_config.go-	MaxItemSize int           `yaml:"max_item_size" default:"1048576"` // 1MB
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// RedisCacheConfig for distributed caching
./apps/mcp-server/internal/config/context_manager_config.go:type RedisCacheConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	Enabled      bool          `yaml:"enabled" default:"true"`
./apps/mcp-server/internal/config/context_manager_config.go-	Endpoints    []string      `yaml:"endpoints"`
./apps/mcp-server/internal/config/context_manager_config.go-	Password     string        `yaml:"password"`
./apps/mcp-server/internal/config/context_manager_config.go-	DB           int           `yaml:"db" default:"0"`
./apps/mcp-server/internal/config/context_manager_config.go-	TTL          time.Duration `yaml:"ttl" default:"1h"`
./apps/mcp-server/internal/config/context_manager_config.go-	MaxRetries   int           `yaml:"max_retries" default:"3"`
./apps/mcp-server/internal/config/context_manager_config.go-	DialTimeout  time.Duration `yaml:"dial_timeout" default:"5s"`
./apps/mcp-server/internal/config/context_manager_config.go-	ReadTimeout  time.Duration `yaml:"read_timeout" default:"3s"`
./apps/mcp-server/internal/config/context_manager_config.go-	WriteTimeout time.Duration `yaml:"write_timeout" default:"3s"`
./apps/mcp-server/internal/config/context_manager_config.go-	PoolSize     int           `yaml:"pool_size" default:"100"`
./apps/mcp-server/internal/config/context_manager_config.go-	MinIdleConns int           `yaml:"min_idle_conns" default:"10"`
./apps/mcp-server/internal/config/context_manager_config.go-	MaxConnAge   time.Duration `yaml:"max_conn_age" default:"0"`
./apps/mcp-server/internal/config/context_manager_config.go-	PoolTimeout  time.Duration `yaml:"pool_timeout" default:"4s"`
./apps/mcp-server/internal/config/context_manager_config.go-	IdleTimeout  time.Duration `yaml:"idle_timeout" default:"5m"`
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// CacheWarmingConfig for proactive cache population
./apps/mcp-server/internal/config/context_manager_config.go:type CacheWarmingConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	Enabled              bool          `yaml:"enabled" default:"true"`
./apps/mcp-server/internal/config/context_manager_config.go-	RecentContextsCount  int           `yaml:"recent_contexts_count" default:"100"`
./apps/mcp-server/internal/config/context_manager_config.go-	PopularContextsCount int           `yaml:"popular_contexts_count" default:"50"`
./apps/mcp-server/internal/config/context_manager_config.go-	WarmupInterval       time.Duration `yaml:"warmup_interval" default:"5m"`
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// CircuitBreakerConfig for graceful degradation
./apps/mcp-server/internal/config/context_manager_config.go:type CircuitBreakerConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	Enabled               bool          `yaml:"enabled" default:"true"`
./apps/mcp-server/internal/config/context_manager_config.go-	FailureThreshold      int           `yaml:"failure_threshold" default:"5"`
./apps/mcp-server/internal/config/context_manager_config.go-	SuccessThreshold      int           `yaml:"success_threshold" default:"2"`
./apps/mcp-server/internal/config/context_manager_config.go-	Timeout               time.Duration `yaml:"timeout" default:"60s"`
./apps/mcp-server/internal/config/context_manager_config.go-	MaxConcurrentRequests int           `yaml:"max_concurrent_requests" default:"100"`
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// MonitoringConfig for performance tracking
./apps/mcp-server/internal/config/context_manager_config.go:type MonitoringConfig struct {
./apps/mcp-server/internal/config/context_manager_config.go-	MetricsEnabled     bool          `yaml:"metrics_enabled" default:"true"`
./apps/mcp-server/internal/config/context_manager_config.go-	TracingEnabled     bool          `yaml:"tracing_enabled" default:"true"`
./apps/mcp-server/internal/config/context_manager_config.go-	SlowQueryThreshold time.Duration `yaml:"slow_query_threshold" default:"100ms"`
./apps/mcp-server/internal/config/context_manager_config.go-	SamplingRate       float64       `yaml:"sampling_rate" default:"0.1"`
./apps/mcp-server/internal/config/context_manager_config.go-}
./apps/mcp-server/internal/config/context_manager_config.go-
./apps/mcp-server/internal/config/context_manager_config.go-// DefaultContextManagerConfig returns production-ready default configuration
./apps/mcp-server/internal/config/context_manager_config.go-func DefaultContextManagerConfig() *ContextManagerConfig {
./apps/mcp-server/internal/config/context_manager_config.go-	return &ContextManagerConfig{
./apps/mcp-server/internal/config/context_manager_config.go-		Database: DatabasePoolConfig{
./apps/mcp-server/internal/config/context_manager_config.go-			MaxOpenConns:        50,
./apps/mcp-server/internal/config/context_manager_config.go-			MaxIdleConns:        25,
./apps/mcp-server/internal/config/context_manager_config.go-			ConnMaxLifetime:     5 * time.Minute,
./apps/mcp-server/internal/config/context_manager_config.go-			ConnMaxIdleTime:     90 * time.Second,
./apps/mcp-server/internal/config/context_manager_config.go-			HealthCheckInterval: 30 * time.Second,
./apps/mcp-server/internal/config/context_manager_config.go-		},
./apps/mcp-server/internal/config/context_manager_config.go-		Cache: CacheConfig{
./apps/mcp-server/internal/config/context_manager_config.go-			InMemory: InMemoryCacheConfig{
./apps/mcp-server/internal/config/context_manager_config.go-				Enabled:     true,
./apps/mcp-server/internal/config/context_manager_config.go-				MaxSize:     10000,
./apps/mcp-server/internal/config/context_manager_config.go-				TTL:         5 * time.Minute,
./apps/mcp-server/internal/config/context_manager_config.go-				MaxItemSize: 1048576, // 1MB
./apps/mcp-server/internal/config/context_manager_config.go-			},
./apps/mcp-server/internal/config/context_manager_config.go-			Redis: RedisCacheConfig{
./apps/mcp-server/internal/config/context_manager_config.go-				Enabled:      true,
./apps/mcp-server/internal/config/context_manager_config.go-				TTL:          1 * time.Hour,
./apps/mcp-server/internal/config/context_manager_config.go-				MaxRetries:   3,
./apps/mcp-server/internal/config/context_manager_config.go-				DialTimeout:  5 * time.Second,
./apps/mcp-server/internal/config/context_manager_config.go-				ReadTimeout:  3 * time.Second,
./apps/mcp-server/internal/config/context_manager_config.go-				WriteTimeout: 3 * time.Second,
./apps/mcp-server/internal/config/context_manager_config.go-				PoolSize:     100,
./apps/mcp-server/internal/config/context_manager_config.go-				MinIdleConns: 10,
./apps/mcp-server/internal/config/context_manager_config.go-				PoolTimeout:  4 * time.Second,
./apps/mcp-server/internal/config/context_manager_config.go-				IdleTimeout:  5 * time.Minute,
./apps/mcp-server/internal/config/context_manager_config.go-			},
./apps/mcp-server/internal/config/context_manager_config.go-			Warming: CacheWarmingConfig{
./apps/mcp-server/internal/config/context_manager_config.go-				Enabled:              true,
./apps/mcp-server/internal/config/context_manager_config.go-				RecentContextsCount:  100,
./apps/mcp-server/internal/config/context_manager_config.go-				PopularContextsCount: 50,
./apps/mcp-server/internal/config/context_manager_config.go-				WarmupInterval:       5 * time.Minute,
./apps/mcp-server/internal/config/context_manager_config.go-			},
./apps/mcp-server/internal/config/context_manager_config.go-		},
./apps/mcp-server/internal/config/context_manager_config.go-		CircuitBreaker: CircuitBreakerConfig{
./apps/mcp-server/internal/config/context_manager_config.go-			Enabled:               true,
./apps/mcp-server/internal/config/context_manager_config.go-			FailureThreshold:      5,
./apps/mcp-server/internal/config/context_manager_config.go-			SuccessThreshold:      2,
./apps/mcp-server/internal/config/context_manager_config.go-			Timeout:               60 * time.Second,
./apps/mcp-server/internal/config/context_manager_config.go-			MaxConcurrentRequests: 100,
./apps/mcp-server/internal/config/context_manager_config.go-		},
./apps/mcp-server/internal/config/context_manager_config.go-		Monitoring: MonitoringConfig{
--
./apps/mcp-server/internal/api/config.go:type Config struct {
./apps/mcp-server/internal/api/config.go-	ListenAddress string            `mapstructure:"listen_address"`
./apps/mcp-server/internal/api/config.go-	ReadTimeout   time.Duration     `mapstructure:"read_timeout"`
./apps/mcp-server/internal/api/config.go-	WriteTimeout  time.Duration     `mapstructure:"write_timeout"`
./apps/mcp-server/internal/api/config.go-	IdleTimeout   time.Duration     `mapstructure:"idle_timeout"`
./apps/mcp-server/internal/api/config.go-	EnableCORS    bool              `mapstructure:"enable_cors"`
./apps/mcp-server/internal/api/config.go-	EnableSwagger bool              `mapstructure:"enable_swagger"`
./apps/mcp-server/internal/api/config.go-	TLSCertFile   string            `mapstructure:"tls_cert_file"`
./apps/mcp-server/internal/api/config.go-	TLSKeyFile    string            `mapstructure:"tls_key_file"`
./apps/mcp-server/internal/api/config.go-	Auth          AuthConfig        `mapstructure:"auth"`
./apps/mcp-server/internal/api/config.go-	RateLimit     RateLimitConfig   `mapstructure:"rate_limit"`
./apps/mcp-server/internal/api/config.go-	Versioning    VersioningConfig  `mapstructure:"versioning"`
./apps/mcp-server/internal/api/config.go-	Performance   PerformanceConfig `mapstructure:"performance"`
./apps/mcp-server/internal/api/config.go-	RestAPI       RestAPIConfig     `mapstructure:"rest_api"`
./apps/mcp-server/internal/api/config.go-	WebSocket     WebSocketConfig   `mapstructure:"websocket"`
./apps/mcp-server/internal/api/config.go-}
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-// VersioningConfig holds API versioning configuration
./apps/mcp-server/internal/api/config.go:type VersioningConfig struct {
./apps/mcp-server/internal/api/config.go-	Enabled           bool     `mapstructure:"enabled"`
./apps/mcp-server/internal/api/config.go-	DefaultVersion    string   `mapstructure:"default_version"`
./apps/mcp-server/internal/api/config.go-	SupportedVersions []string `mapstructure:"supported_versions"`
./apps/mcp-server/internal/api/config.go-}
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-// PerformanceConfig holds configuration for performance optimization
./apps/mcp-server/internal/api/config.go:type PerformanceConfig struct {
./apps/mcp-server/internal/api/config.go-	// Connection pooling for database
./apps/mcp-server/internal/api/config.go-	DBMaxIdleConns    int           `mapstructure:"db_max_idle_conns"`
./apps/mcp-server/internal/api/config.go-	DBMaxOpenConns    int           `mapstructure:"db_max_open_conns"`
./apps/mcp-server/internal/api/config.go-	DBConnMaxLifetime time.Duration `mapstructure:"db_conn_max_lifetime"`
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-	// HTTP client settings
./apps/mcp-server/internal/api/config.go-	HTTPMaxIdleConns    int           `mapstructure:"http_max_idle_conns"`
./apps/mcp-server/internal/api/config.go-	HTTPMaxConnsPerHost int           `mapstructure:"http_max_conns_per_host"`
./apps/mcp-server/internal/api/config.go-	HTTPIdleConnTimeout time.Duration `mapstructure:"http_idle_conn_timeout"`
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-	// Response optimization
./apps/mcp-server/internal/api/config.go-	EnableCompression bool `mapstructure:"enable_compression"`
./apps/mcp-server/internal/api/config.go-	EnableETagCaching bool `mapstructure:"enable_etag_caching"`
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-	// Cache control settings
./apps/mcp-server/internal/api/config.go-	StaticContentMaxAge  time.Duration `mapstructure:"static_content_max_age"`
./apps/mcp-server/internal/api/config.go-	DynamicContentMaxAge time.Duration `mapstructure:"dynamic_content_max_age"`
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-	// Circuit breaker settings for external services
./apps/mcp-server/internal/api/config.go-	CircuitBreakerEnabled bool          `mapstructure:"circuit_breaker_enabled"`
./apps/mcp-server/internal/api/config.go-	CircuitBreakerTimeout time.Duration `mapstructure:"circuit_breaker_timeout"`
./apps/mcp-server/internal/api/config.go-	MaxRetries            int           `mapstructure:"max_retries"`
./apps/mcp-server/internal/api/config.go-	RetryBackoff          time.Duration `mapstructure:"retry_backoff"`
./apps/mcp-server/internal/api/config.go-}
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-// AuthConfig holds authentication configuration
./apps/mcp-server/internal/api/config.go:type AuthConfig struct {
./apps/mcp-server/internal/api/config.go-	JWTSecret        string      `mapstructure:"jwt_secret"`
./apps/mcp-server/internal/api/config.go-	APIKeys          interface{} `mapstructure:"api_keys"`
./apps/mcp-server/internal/api/config.go-	ServiceSecret    string      `mapstructure:"service_secret"`
./apps/mcp-server/internal/api/config.go-	DefaultRateLimit int         `mapstructure:"default_rate_limit"`
./apps/mcp-server/internal/api/config.go-}
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-// RateLimitConfig holds rate limiting configuration
./apps/mcp-server/internal/api/config.go:type RateLimitConfig struct {
./apps/mcp-server/internal/api/config.go-	Enabled     bool          `mapstructure:"enabled"`
./apps/mcp-server/internal/api/config.go-	Limit       int           `mapstructure:"limit"`
./apps/mcp-server/internal/api/config.go-	Period      time.Duration `mapstructure:"period"`
./apps/mcp-server/internal/api/config.go-	BurstFactor int           `mapstructure:"burst_factor"`
./apps/mcp-server/internal/api/config.go-}
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-// RestAPIConfig holds configuration for the REST API client
./apps/mcp-server/internal/api/config.go:type RestAPIConfig struct {
./apps/mcp-server/internal/api/config.go-	Enabled    bool          `mapstructure:"enabled"`
./apps/mcp-server/internal/api/config.go-	BaseURL    string        `mapstructure:"base_url"`
./apps/mcp-server/internal/api/config.go-	APIKey     string        `mapstructure:"api_key"`
./apps/mcp-server/internal/api/config.go-	Timeout    time.Duration `mapstructure:"timeout"`
./apps/mcp-server/internal/api/config.go-	RetryCount int           `mapstructure:"retry_count"`
./apps/mcp-server/internal/api/config.go-}
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-// WebSocketConfig holds configuration for the WebSocket server
./apps/mcp-server/internal/api/config.go:type WebSocketConfig struct {
./apps/mcp-server/internal/api/config.go-	Enabled         bool                        `mapstructure:"enabled"`
./apps/mcp-server/internal/api/config.go-	MaxConnections  int                         `mapstructure:"max_connections"`
./apps/mcp-server/internal/api/config.go-	ReadBufferSize  int                         `mapstructure:"read_buffer_size"`
./apps/mcp-server/internal/api/config.go-	WriteBufferSize int                         `mapstructure:"write_buffer_size"`
./apps/mcp-server/internal/api/config.go-	PingInterval    time.Duration               `mapstructure:"ping_interval"`
./apps/mcp-server/internal/api/config.go-	PongTimeout     time.Duration               `mapstructure:"pong_timeout"`
./apps/mcp-server/internal/api/config.go-	MaxMessageSize  int64                       `mapstructure:"max_message_size"`
./apps/mcp-server/internal/api/config.go-	Security        websocket.SecurityConfig    `mapstructure:"security"`
./apps/mcp-server/internal/api/config.go-	RateLimit       websocket.RateLimiterConfig `mapstructure:"rate_limit"`
./apps/mcp-server/internal/api/config.go-}
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-// DefaultConfig returns a Config with sensible defaults
./apps/mcp-server/internal/api/config.go-func DefaultConfig() Config {
./apps/mcp-server/internal/api/config.go-	return Config{
./apps/mcp-server/internal/api/config.go-		ListenAddress: ":8080",
./apps/mcp-server/internal/api/config.go-		ReadTimeout:   30 * time.Second,
./apps/mcp-server/internal/api/config.go-		WriteTimeout:  60 * time.Second,
./apps/mcp-server/internal/api/config.go-		IdleTimeout:   120 * time.Second,
./apps/mcp-server/internal/api/config.go-		EnableCORS:    true,
./apps/mcp-server/internal/api/config.go-		EnableSwagger: true,
./apps/mcp-server/internal/api/config.go-		Auth: AuthConfig{
./apps/mcp-server/internal/api/config.go-			JWTSecret: "", // Must be provided by user
./apps/mcp-server/internal/api/config.go-			APIKeys:   make(map[string]string),
./apps/mcp-server/internal/api/config.go-		},
./apps/mcp-server/internal/api/config.go-		RateLimit: RateLimitConfig{
./apps/mcp-server/internal/api/config.go-			Enabled:     true,
./apps/mcp-server/internal/api/config.go-			Limit:       100,
./apps/mcp-server/internal/api/config.go-			Period:      time.Minute,
./apps/mcp-server/internal/api/config.go-			BurstFactor: 3,
./apps/mcp-server/internal/api/config.go-		},
./apps/mcp-server/internal/api/config.go-		Versioning: VersioningConfig{
./apps/mcp-server/internal/api/config.go-			Enabled:           true,
./apps/mcp-server/internal/api/config.go-			DefaultVersion:    "1.0",
./apps/mcp-server/internal/api/config.go-			SupportedVersions: []string{"1.0"},
./apps/mcp-server/internal/api/config.go-		},
./apps/mcp-server/internal/api/config.go-		Performance: PerformanceConfig{
./apps/mcp-server/internal/api/config.go-			// Database connection pooling defaults
./apps/mcp-server/internal/api/config.go-			DBMaxIdleConns:    10,
./apps/mcp-server/internal/api/config.go-			DBMaxOpenConns:    100,
./apps/mcp-server/internal/api/config.go-			DBConnMaxLifetime: 30 * time.Minute,
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-			// HTTP client settings
./apps/mcp-server/internal/api/config.go-			HTTPMaxIdleConns:    100,
./apps/mcp-server/internal/api/config.go-			HTTPMaxConnsPerHost: 10,
./apps/mcp-server/internal/api/config.go-			HTTPIdleConnTimeout: 90 * time.Second,
./apps/mcp-server/internal/api/config.go-
./apps/mcp-server/internal/api/config.go-			// Response optimization
./apps/mcp-server/internal/api/config.go-			EnableCompression: true,
./apps/mcp-server/internal/api/config.go-			EnableETagCaching: true,
./apps/mcp-server/internal/api/config.go-
--
./apps/mcp-server/internal/api/websocket/server.go:type Config struct {
./apps/mcp-server/internal/api/websocket/server.go-	MaxConnections  int           `mapstructure:"max_connections"`
./apps/mcp-server/internal/api/websocket/server.go-	ReadBufferSize  int           `mapstructure:"read_buffer_size"`
./apps/mcp-server/internal/api/websocket/server.go-	WriteBufferSize int           `mapstructure:"write_buffer_size"`
./apps/mcp-server/internal/api/websocket/server.go-	PingInterval    time.Duration `mapstructure:"ping_interval"`
./apps/mcp-server/internal/api/websocket/server.go-	PongTimeout     time.Duration `mapstructure:"pong_timeout"`
./apps/mcp-server/internal/api/websocket/server.go-	MaxMessageSize  int64         `mapstructure:"max_message_size"`
./apps/mcp-server/internal/api/websocket/server.go-
./apps/mcp-server/internal/api/websocket/server.go-	// Security settings
./apps/mcp-server/internal/api/websocket/server.go-	Security  SecurityConfig    `mapstructure:"security"`
./apps/mcp-server/internal/api/websocket/server.go-	RateLimit RateLimiterConfig `mapstructure:"rate_limit"`
./apps/mcp-server/internal/api/websocket/server.go-
./apps/mcp-server/internal/api/websocket/server.go-	// Version information
./apps/mcp-server/internal/api/websocket/server.go-	Version   string `mapstructure:"-"`
./apps/mcp-server/internal/api/websocket/server.go-	BuildTime string `mapstructure:"-"`
./apps/mcp-server/internal/api/websocket/server.go-	GitCommit string `mapstructure:"-"`
./apps/mcp-server/internal/api/websocket/server.go-}
./apps/mcp-server/internal/api/websocket/server.go-
./apps/mcp-server/internal/api/websocket/server.go-// Connection wraps the WebSocket connection and adds our metadata
./apps/mcp-server/internal/api/websocket/server.go-type Connection struct {
./apps/mcp-server/internal/api/websocket/server.go-	*ws.Connection
./apps/mcp-server/internal/api/websocket/server.go-	conn      *websocket.Conn
./apps/mcp-server/internal/api/websocket/server.go-	send      chan []byte
./apps/mcp-server/internal/api/websocket/server.go-	afterSend chan *PostActionConfig // Channel for post-response actions
./apps/mcp-server/internal/api/websocket/server.go-	hub       *Server
./apps/mcp-server/internal/api/websocket/server.go-	mu        sync.RWMutex
./apps/mcp-server/internal/api/websocket/server.go-	state     *ConnectionState
./apps/mcp-server/internal/api/websocket/server.go-
./apps/mcp-server/internal/api/websocket/server.go-	// Connection lifecycle management
./apps/mcp-server/internal/api/websocket/server.go-	closeOnce sync.Once
./apps/mcp-server/internal/api/websocket/server.go-	closed    chan struct{}
./apps/mcp-server/internal/api/websocket/server.go-	wg        sync.WaitGroup
./apps/mcp-server/internal/api/websocket/server.go-}
./apps/mcp-server/internal/api/websocket/server.go-
./apps/mcp-server/internal/api/websocket/server.go-func NewServer(auth *auth.Service, metrics observability.MetricsClient, logger observability.Logger, config Config) *Server {
./apps/mcp-server/internal/api/websocket/server.go-	// Create tracer function for tracing handler
./apps/mcp-server/internal/api/websocket/server.go-	var tracerFunc observability.StartSpanFunc = func(ctx context.Context, name string, attrs ...attribute.KeyValue) (context.Context, observability.Span) {
./apps/mcp-server/internal/api/websocket/server.go-		// This would use the global tracer or one passed in config
./apps/mcp-server/internal/api/websocket/server.go-		// For now, using a no-op implementation
./apps/mcp-server/internal/api/websocket/server.go-		return ctx, &NoOpSpan{}
./apps/mcp-server/internal/api/websocket/server.go-	}
./apps/mcp-server/internal/api/websocket/server.go-
./apps/mcp-server/internal/api/websocket/server.go-	// Set default MaxMessageSize if not configured
./apps/mcp-server/internal/api/websocket/server.go-	if config.MaxMessageSize <= 0 {
./apps/mcp-server/internal/api/websocket/server.go-		config.MaxMessageSize = 1048576 // 1MB default
./apps/mcp-server/internal/api/websocket/server.go-		if logger != nil {
./apps/mcp-server/internal/api/websocket/server.go-			logger.Warn("MaxMessageSize not configured, using default", map[string]interface{}{
./apps/mcp-server/internal/api/websocket/server.go-				"default_size": config.MaxMessageSize,
./apps/mcp-server/internal/api/websocket/server.go-				"size_kb":      config.MaxMessageSize / 1024,
./apps/mcp-server/internal/api/websocket/server.go-			})
./apps/mcp-server/internal/api/websocket/server.go-		}
--
./apps/mcp-server/internal/api/websocket/auth.go:type RateLimiterConfig struct {
./apps/mcp-server/internal/api/websocket/auth.go-	Rate    float64 // Requests per second
./apps/mcp-server/internal/api/websocket/auth.go-	Burst   float64 // Burst capacity
./apps/mcp-server/internal/api/websocket/auth.go-	PerIP   bool    // Enable per-IP rate limiting
./apps/mcp-server/internal/api/websocket/auth.go-	PerUser bool    // Enable per-user rate limiting
./apps/mcp-server/internal/api/websocket/auth.go-}
./apps/mcp-server/internal/api/websocket/auth.go-
./apps/mcp-server/internal/api/websocket/auth.go-// DefaultRateLimiterConfig returns default rate limiter configuration
./apps/mcp-server/internal/api/websocket/auth.go-func DefaultRateLimiterConfig() *RateLimiterConfig {
./apps/mcp-server/internal/api/websocket/auth.go-	return &RateLimiterConfig{
./apps/mcp-server/internal/api/websocket/auth.go-		Rate:    1000.0 / 60.0, // 1000 per minute
./apps/mcp-server/internal/api/websocket/auth.go-		Burst:   100,
./apps/mcp-server/internal/api/websocket/auth.go-		PerIP:   true,
./apps/mcp-server/internal/api/websocket/auth.go-		PerUser: true,
./apps/mcp-server/internal/api/websocket/auth.go-	}
./apps/mcp-server/internal/api/websocket/auth.go-}
./apps/mcp-server/internal/api/websocket/auth.go-
./apps/mcp-server/internal/api/websocket/auth.go-// IPRateLimiter manages rate limiting per IP address
./apps/mcp-server/internal/api/websocket/auth.go-type IPRateLimiter struct {
./apps/mcp-server/internal/api/websocket/auth.go-	limiters map[string]*RateLimiter
./apps/mcp-server/internal/api/websocket/auth.go-	mu       sync.RWMutex
./apps/mcp-server/internal/api/websocket/auth.go-	config   *RateLimiterConfig
./apps/mcp-server/internal/api/websocket/auth.go-}
./apps/mcp-server/internal/api/websocket/auth.go-
./apps/mcp-server/internal/api/websocket/auth.go-// NewIPRateLimiter creates a new IP-based rate limiter
./apps/mcp-server/internal/api/websocket/auth.go-func NewIPRateLimiter(config *RateLimiterConfig) *IPRateLimiter {
./apps/mcp-server/internal/api/websocket/auth.go-	return &IPRateLimiter{
./apps/mcp-server/internal/api/websocket/auth.go-		limiters: make(map[string]*RateLimiter),
./apps/mcp-server/internal/api/websocket/auth.go-		config:   config,
./apps/mcp-server/internal/api/websocket/auth.go-	}
./apps/mcp-server/internal/api/websocket/auth.go-}
./apps/mcp-server/internal/api/websocket/auth.go-
./apps/mcp-server/internal/api/websocket/auth.go-// Allow checks if a request from an IP is allowed
./apps/mcp-server/internal/api/websocket/auth.go-func (r *IPRateLimiter) Allow(ip string) bool {
./apps/mcp-server/internal/api/websocket/auth.go-	r.mu.Lock()
./apps/mcp-server/internal/api/websocket/auth.go-	limiter, ok := r.limiters[ip]
./apps/mcp-server/internal/api/websocket/auth.go-	if !ok {
./apps/mcp-server/internal/api/websocket/auth.go-		limiter = NewRateLimiter(r.config.Rate, r.config.Burst)
./apps/mcp-server/internal/api/websocket/auth.go-		r.limiters[ip] = limiter
./apps/mcp-server/internal/api/websocket/auth.go-	}
./apps/mcp-server/internal/api/websocket/auth.go-	r.mu.Unlock()
./apps/mcp-server/internal/api/websocket/auth.go-
./apps/mcp-server/internal/api/websocket/auth.go-	return limiter.Allow()
./apps/mcp-server/internal/api/websocket/auth.go-}
./apps/mcp-server/internal/api/websocket/auth.go-
./apps/mcp-server/internal/api/websocket/auth.go-// Cleanup removes old rate limiters
./apps/mcp-server/internal/api/websocket/auth.go-func (r *IPRateLimiter) Cleanup() {
./apps/mcp-server/internal/api/websocket/auth.go-	r.mu.Lock()
./apps/mcp-server/internal/api/websocket/auth.go-	defer r.mu.Unlock()
./apps/mcp-server/internal/api/websocket/auth.go-
./apps/mcp-server/internal/api/websocket/auth.go-	// In production, implement cleanup of inactive IPs
--
./apps/mcp-server/internal/api/websocket/auth.go:type SecurityConfig struct {
./apps/mcp-server/internal/api/websocket/auth.go-	RequireAuth    bool     // Require authentication
./apps/mcp-server/internal/api/websocket/auth.go-	HMACSignatures bool     // Enable HMAC signatures
./apps/mcp-server/internal/api/websocket/auth.go-	AllowedOrigins []string // CORS allowed origins
./apps/mcp-server/internal/api/websocket/auth.go-	MaxFrameSize   int64    // Maximum WebSocket frame size
./apps/mcp-server/internal/api/websocket/auth.go-	EnableTLS      bool     // Require TLS
./apps/mcp-server/internal/api/websocket/auth.go-	MinTLSVersion  string   // Minimum TLS version
./apps/mcp-server/internal/api/websocket/auth.go-	JWTSecret      string   // JWT signing secret
./apps/mcp-server/internal/api/websocket/auth.go-	APIKeys        []string // Valid API keys
./apps/mcp-server/internal/api/websocket/auth.go-	IPWhitelist    []string // Allowed IP addresses (empty = allow all)
./apps/mcp-server/internal/api/websocket/auth.go-}
--
./apps/mcp-server/internal/api/websocket/session_manager.go:type SessionConfig struct {
./apps/mcp-server/internal/api/websocket/session_manager.go-	ID             string
./apps/mcp-server/internal/api/websocket/session_manager.go-	Name           string
./apps/mcp-server/internal/api/websocket/session_manager.go-	AgentID        string
./apps/mcp-server/internal/api/websocket/session_manager.go-	TenantID       string
./apps/mcp-server/internal/api/websocket/session_manager.go-	AgentProfile   map[string]interface{}
./apps/mcp-server/internal/api/websocket/session_manager.go-	InitialContext map[string]interface{}
./apps/mcp-server/internal/api/websocket/session_manager.go-	State          map[string]interface{}
./apps/mcp-server/internal/api/websocket/session_manager.go-	Persistent     bool
./apps/mcp-server/internal/api/websocket/session_manager.go-	TTL            time.Duration
./apps/mcp-server/internal/api/websocket/session_manager.go-	TrackMetrics   bool
./apps/mcp-server/internal/api/websocket/session_manager.go-	Tags           []string
./apps/mcp-server/internal/api/websocket/session_manager.go-}
./apps/mcp-server/internal/api/websocket/session_manager.go-
./apps/mcp-server/internal/api/websocket/session_manager.go-// SessionMetrics tracks session usage metrics
./apps/mcp-server/internal/api/websocket/session_manager.go-type SessionMetrics struct {
./apps/mcp-server/internal/api/websocket/session_manager.go-	Duration       time.Duration  `json:"duration"`
./apps/mcp-server/internal/api/websocket/session_manager.go-	OperationCount int            `json:"operation_count"`
./apps/mcp-server/internal/api/websocket/session_manager.go-	TokenUsage     int            `json:"token_usage"`
./apps/mcp-server/internal/api/websocket/session_manager.go-	ToolUsage      map[string]int `json:"tool_usage"`
./apps/mcp-server/internal/api/websocket/session_manager.go-	ErrorCount     int            `json:"error_count"`
./apps/mcp-server/internal/api/websocket/session_manager.go-	CreatedAt      time.Time      `json:"created_at"`
./apps/mcp-server/internal/api/websocket/session_manager.go-	LastActivity   time.Time      `json:"last_activity"`
./apps/mcp-server/internal/api/websocket/session_manager.go-}
./apps/mcp-server/internal/api/websocket/session_manager.go-
./apps/mcp-server/internal/api/websocket/session_manager.go-// CreateSession creates a new session
./apps/mcp-server/internal/api/websocket/session_manager.go-func (sm *ConversationSessionManager) CreateSession(ctx context.Context, config *SessionConfig) (*Session, error) {
./apps/mcp-server/internal/api/websocket/session_manager.go-	session := &Session{
./apps/mcp-server/internal/api/websocket/session_manager.go-		ID:           config.ID,
./apps/mcp-server/internal/api/websocket/session_manager.go-		Name:         config.Name,
./apps/mcp-server/internal/api/websocket/session_manager.go-		AgentID:      config.AgentID,
./apps/mcp-server/internal/api/websocket/session_manager.go-		TenantID:     config.TenantID,
./apps/mcp-server/internal/api/websocket/session_manager.go-		AgentProfile: config.AgentProfile,
./apps/mcp-server/internal/api/websocket/session_manager.go-		State:        config.State,
./apps/mcp-server/internal/api/websocket/session_manager.go-		Messages:     []SessionMessage{},
./apps/mcp-server/internal/api/websocket/session_manager.go-		TokenCount:   0,
./apps/mcp-server/internal/api/websocket/session_manager.go-		Persistent:   config.Persistent,
./apps/mcp-server/internal/api/websocket/session_manager.go-		CreatedAt:    time.Now(),
./apps/mcp-server/internal/api/websocket/session_manager.go-		UpdatedAt:    time.Now(),
./apps/mcp-server/internal/api/websocket/session_manager.go-		Tags:         config.Tags,
./apps/mcp-server/internal/api/websocket/session_manager.go-	}
./apps/mcp-server/internal/api/websocket/session_manager.go-
./apps/mcp-server/internal/api/websocket/session_manager.go-	if config.TTL > 0 {
./apps/mcp-server/internal/api/websocket/session_manager.go-		session.ExpiresAt = time.Now().Add(config.TTL)
./apps/mcp-server/internal/api/websocket/session_manager.go-	}
./apps/mcp-server/internal/api/websocket/session_manager.go-
./apps/mcp-server/internal/api/websocket/session_manager.go-	if config.TrackMetrics {
./apps/mcp-server/internal/api/websocket/session_manager.go-		session.Metrics = &SessionMetrics{
./apps/mcp-server/internal/api/websocket/session_manager.go-			CreatedAt:    time.Now(),
./apps/mcp-server/internal/api/websocket/session_manager.go-			LastActivity: time.Now(),
./apps/mcp-server/internal/api/websocket/session_manager.go-			ToolUsage:    make(map[string]int),
--
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go:type AgentRateLimiterConfig struct {
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	*auth.RateLimiterConfig // Embed base config
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	// Agent-specific settings
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	DefaultAgentRPS      int
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	DefaultTenantRPS     int
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	DefaultCapabilityRPS int
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	BurstMultiplier      float64
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-}
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-// DefaultAgentRateLimiterConfig returns sensible defaults
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-func DefaultAgentRateLimiterConfig() *AgentRateLimiterConfig {
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	return &AgentRateLimiterConfig{
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		RateLimiterConfig:    auth.DefaultRateLimiterConfig(),
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		DefaultAgentRPS:      10,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		DefaultTenantRPS:     100,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		DefaultCapabilityRPS: 50,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		BurstMultiplier:      2.0,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	}
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-}
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-// NewAgentRateLimiter creates a rate limiter for agents
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-func NewAgentRateLimiter(
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	cache cache.Cache,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	logger observability.Logger,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	metrics observability.MetricsClient,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	tenantRepo repository.TenantConfigRepository,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	orgRepo repository.OrganizationRepository,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	config *AgentRateLimiterConfig,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-) *AgentRateLimiter {
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	if config == nil {
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		config = DefaultAgentRateLimiterConfig()
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	}
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	// Create base rate limiter
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	baseRateLimiter := auth.NewRateLimiter(cache, logger, config.RateLimiterConfig)
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	return &AgentRateLimiter{
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		RateLimiter:          baseRateLimiter,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		tenantRepo:           tenantRepo,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		orgRepo:              orgRepo,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		logger:               logger,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		metrics:              metrics,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		defaultAgentRPS:      config.DefaultAgentRPS,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		defaultTenantRPS:     config.DefaultTenantRPS,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		defaultCapabilityRPS: config.DefaultCapabilityRPS,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-		burstMultiplier:      config.BurstMultiplier,
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-	}
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-}
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-
./apps/mcp-server/internal/api/websocket/agent_rate_limiter.go-// CheckAgentLimit checks rate limits for a specific agent
--
./apps/mcp-server/internal/api/websocket/handlers.go:type PostActionConfig struct {
./apps/mcp-server/internal/api/websocket/handlers.go-	Action      func()
./apps/mcp-server/internal/api/websocket/handlers.go-	Synchronous bool // If true, execute synchronously; if false, execute in goroutine
./apps/mcp-server/internal/api/websocket/handlers.go-}
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-// MessageHandler processes a specific message type
./apps/mcp-server/internal/api/websocket/handlers.go-type MessageHandler func(ctx context.Context, conn *Connection, params json.RawMessage) (interface{}, error)
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-// MessageHandlerWithPostAction is an enhanced handler that can return a post-response action
./apps/mcp-server/internal/api/websocket/handlers.go-type MessageHandlerWithPostAction func(ctx context.Context, conn *Connection, params json.RawMessage) (interface{}, *PostActionConfig, error)
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-// RegisterHandlers sets up all message handlers
./apps/mcp-server/internal/api/websocket/handlers.go-func (s *Server) RegisterHandlers() {
./apps/mcp-server/internal/api/websocket/handlers.go-	// Initialize handlers as MessageHandler type
./apps/mcp-server/internal/api/websocket/handlers.go-	handlers := map[string]MessageHandler{
./apps/mcp-server/internal/api/websocket/handlers.go-		// Core protocol
./apps/mcp-server/internal/api/websocket/handlers.go-		"initialize":          s.handleInitialize,
./apps/mcp-server/internal/api/websocket/handlers.go-		"protocol.set_binary": s.handleSetBinaryProtocol,
./apps/mcp-server/internal/api/websocket/handlers.go-		"protocol.get_info":   s.handleProtocolGetInfo,
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-		// Testing and diagnostics
./apps/mcp-server/internal/api/websocket/handlers.go-		"echo":      s.handleEcho,
./apps/mcp-server/internal/api/websocket/handlers.go-		"ping":      s.handlePing,
./apps/mcp-server/internal/api/websocket/handlers.go-		"benchmark": s.handleBenchmark,
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-		// Tool operations
./apps/mcp-server/internal/api/websocket/handlers.go-		"tool.list":    s.handleToolList,
./apps/mcp-server/internal/api/websocket/handlers.go-		"tool.execute": s.handleToolExecute,
./apps/mcp-server/internal/api/websocket/handlers.go-		"tool.cancel":  s.handleToolCancel,
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-		// Embedding operations
./apps/mcp-server/internal/api/websocket/handlers.go-		"embedding.generate": s.handleEmbeddingGenerate,
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-		// Context management
./apps/mcp-server/internal/api/websocket/handlers.go-		"context.create":     s.handleContextCreate,
./apps/mcp-server/internal/api/websocket/handlers.go-		"context.get":        s.handleContextGet,
./apps/mcp-server/internal/api/websocket/handlers.go-		"context.update":     s.handleContextUpdate,
./apps/mcp-server/internal/api/websocket/handlers.go-		"context.append":     s.handleContextAppend,
./apps/mcp-server/internal/api/websocket/handlers.go-		"context.get_limits": s.handleContextGetLimits,
./apps/mcp-server/internal/api/websocket/handlers.go-		"context.get_stats":  s.handleContextGetStats,
./apps/mcp-server/internal/api/websocket/handlers.go-		"context.truncate":   s.handleContextTruncate,
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-		// Context window management
./apps/mcp-server/internal/api/websocket/handlers.go-		"window.setTokens":     s.handleWindowSetTokens,
./apps/mcp-server/internal/api/websocket/handlers.go-		"window.getTokenUsage": s.handleWindowGetTokenUsage,
./apps/mcp-server/internal/api/websocket/handlers.go-
./apps/mcp-server/internal/api/websocket/handlers.go-		// Session management
./apps/mcp-server/internal/api/websocket/handlers.go-		"session.create":       s.handleSessionCreate,
./apps/mcp-server/internal/api/websocket/handlers.go-		"session.get":          s.handleSessionGet,
./apps/mcp-server/internal/api/websocket/handlers.go-		"session.update_state": s.handleSessionUpdateState,
./apps/mcp-server/internal/api/websocket/handlers.go-		"session.add_message":  s.handleSessionAddMessage,
--
./apps/mcp-server/internal/api/websocket/handlers.go:type AgentConfig struct {
./apps/mcp-server/internal/api/websocket/handlers.go-	MaxContextTokens int
./apps/mcp-server/internal/api/websocket/handlers.go-	Model            string
./apps/mcp-server/internal/api/websocket/handlers.go-}
--
./apps/mcp-server/internal/api/websocket/batch.go:type BatchConfig struct {
./apps/mcp-server/internal/api/websocket/batch.go-	BatchSize     int           // Target batch size
./apps/mcp-server/internal/api/websocket/batch.go-	MaxBatchSize  int           // Maximum batch size
./apps/mcp-server/internal/api/websocket/batch.go-	FlushInterval time.Duration // Max time to wait before flushing
./apps/mcp-server/internal/api/websocket/batch.go-	BinaryMode    bool          // Use binary protocol for batching
./apps/mcp-server/internal/api/websocket/batch.go-}
./apps/mcp-server/internal/api/websocket/batch.go-
./apps/mcp-server/internal/api/websocket/batch.go-// DefaultBatchConfig returns default batch configuration
./apps/mcp-server/internal/api/websocket/batch.go-func DefaultBatchConfig() *BatchConfig {
./apps/mcp-server/internal/api/websocket/batch.go-	return &BatchConfig{
./apps/mcp-server/internal/api/websocket/batch.go-		BatchSize:     10,
./apps/mcp-server/internal/api/websocket/batch.go-		MaxBatchSize:  100,
./apps/mcp-server/internal/api/websocket/batch.go-		FlushInterval: 10 * time.Millisecond,
./apps/mcp-server/internal/api/websocket/batch.go-		BinaryMode:    true,
./apps/mcp-server/internal/api/websocket/batch.go-	}
./apps/mcp-server/internal/api/websocket/batch.go-}
./apps/mcp-server/internal/api/websocket/batch.go-
./apps/mcp-server/internal/api/websocket/batch.go-// NewBatchProcessor creates a new batch processor
./apps/mcp-server/internal/api/websocket/batch.go-func NewBatchProcessor(
./apps/mcp-server/internal/api/websocket/batch.go-	config *BatchConfig,
./apps/mcp-server/internal/api/websocket/batch.go-	sendFunc func([]byte) error,
./apps/mcp-server/internal/api/websocket/batch.go-	logger observability.Logger,
./apps/mcp-server/internal/api/websocket/batch.go-	metrics observability.MetricsClient,
./apps/mcp-server/internal/api/websocket/batch.go-) *BatchProcessor {
./apps/mcp-server/internal/api/websocket/batch.go-	bp := &BatchProcessor{
./apps/mcp-server/internal/api/websocket/batch.go-		pendingMessages: make([]*BatchMessage, 0, config.MaxBatchSize),
./apps/mcp-server/internal/api/websocket/batch.go-		batchSize:       config.BatchSize,
./apps/mcp-server/internal/api/websocket/batch.go-		maxBatchSize:    config.MaxBatchSize,
./apps/mcp-server/internal/api/websocket/batch.go-		flushInterval:   config.FlushInterval,
./apps/mcp-server/internal/api/websocket/batch.go-		sendFunc:        sendFunc,
./apps/mcp-server/internal/api/websocket/batch.go-		logger:          logger,
./apps/mcp-server/internal/api/websocket/batch.go-		metrics:         metrics,
./apps/mcp-server/internal/api/websocket/batch.go-		binaryMode:      config.BinaryMode,
./apps/mcp-server/internal/api/websocket/batch.go-		batchSizes:      make([]int, 0, 1000),
./apps/mcp-server/internal/api/websocket/batch.go-	}
./apps/mcp-server/internal/api/websocket/batch.go-
./apps/mcp-server/internal/api/websocket/batch.go-	// Start flush timer
./apps/mcp-server/internal/api/websocket/batch.go-	bp.resetTimer()
./apps/mcp-server/internal/api/websocket/batch.go-
./apps/mcp-server/internal/api/websocket/batch.go-	return bp
./apps/mcp-server/internal/api/websocket/batch.go-}
./apps/mcp-server/internal/api/websocket/batch.go-
./apps/mcp-server/internal/api/websocket/batch.go-// Add adds a message to the batch
./apps/mcp-server/internal/api/websocket/batch.go-func (bp *BatchProcessor) Add(connectionID string, message []byte) error {
./apps/mcp-server/internal/api/websocket/batch.go-	bp.mu.Lock()
./apps/mcp-server/internal/api/websocket/batch.go-	defer bp.mu.Unlock()
./apps/mcp-server/internal/api/websocket/batch.go-
./apps/mcp-server/internal/api/websocket/batch.go-	// Create batch message
./apps/mcp-server/internal/api/websocket/batch.go-	batchMsg := &BatchMessage{
./apps/mcp-server/internal/api/websocket/batch.go-		ConnectionID: connectionID,
./apps/mcp-server/internal/api/websocket/batch.go-		Message:      message,
--
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go:type ChannelConfig struct {
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Type     string
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Config   models.JSONMap
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Priority int
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-}
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-// ChannelInfo contains channel information
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-type ChannelInfo struct {
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	ID       uuid.UUID
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Type     string
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Priority int
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Active   bool
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-}
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-// AgentHealthUpdate contains health update information
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-type AgentHealthUpdate struct {
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Status  string
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Message string
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-	Metrics map[string]interface{}
./apps/mcp-server/internal/api/websocket/agent_registry_enhanced.go-}
--
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go:type AgentCircuitBreakerConfig struct {
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	// Default configuration for all breakers
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	DefaultConfig resilience.CircuitBreakerConfig
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	// Specific configurations
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	AgentConfig      resilience.CircuitBreakerConfig
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	CapabilityConfig resilience.CircuitBreakerConfig
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	TenantConfig     resilience.CircuitBreakerConfig
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	ChannelConfig    resilience.CircuitBreakerConfig
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-}
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-// DefaultAgentCircuitBreakerConfig returns sensible defaults
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-func DefaultAgentCircuitBreakerConfig() *AgentCircuitBreakerConfig {
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-	return &AgentCircuitBreakerConfig{
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		DefaultConfig: resilience.CircuitBreakerConfig{
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureThreshold:    5,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureRatio:        0.6,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			ResetTimeout:        30 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			SuccessThreshold:    2,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			TimeoutThreshold:    5 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MaxRequestsHalfOpen: 5,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MinimumRequestCount: 10,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		},
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		AgentConfig: resilience.CircuitBreakerConfig{
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureThreshold:    3,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureRatio:        0.5,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			ResetTimeout:        20 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			SuccessThreshold:    2,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			TimeoutThreshold:    10 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MaxRequestsHalfOpen: 3,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MinimumRequestCount: 5,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		},
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		CapabilityConfig: resilience.CircuitBreakerConfig{
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureThreshold:    10,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureRatio:        0.7,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			ResetTimeout:        60 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			SuccessThreshold:    3,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			TimeoutThreshold:    15 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MaxRequestsHalfOpen: 10,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MinimumRequestCount: 20,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		},
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		TenantConfig: resilience.CircuitBreakerConfig{
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureThreshold:    20,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			FailureRatio:        0.8,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			ResetTimeout:        120 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			SuccessThreshold:    5,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			TimeoutThreshold:    30 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MaxRequestsHalfOpen: 15,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-			MinimumRequestCount: 30,
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		},
./apps/mcp-server/internal/api/websocket/agent_circuit_breaker.go-		ChannelConfig: resilience.CircuitBreakerConfig{
--
./apps/mcp-server/internal/api/websocket/workspace_manager.go:type WorkspaceConfig struct {
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Name        string   `json:"name"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Description string   `json:"description"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Type        string   `json:"type"` // private, team, public
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	OwnerID     string   `json:"owner_id"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	TenantID    string   `json:"tenant_id"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Members     []string `json:"members"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-}
./apps/mcp-server/internal/api/websocket/workspace_manager.go-
./apps/mcp-server/internal/api/websocket/workspace_manager.go-// Workspace represents a collaborative workspace
./apps/mcp-server/internal/api/websocket/workspace_manager.go-type Workspace struct {
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	ID             string                      `json:"id"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Name           string                      `json:"name"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Description    string                      `json:"description"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Type           string                      `json:"type"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	OwnerID        string                      `json:"owner_id"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	TenantID       string                      `json:"tenant_id"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Members        map[string]*WorkspaceMember `json:"members"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	State          map[string]interface{}      `json:"state"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	StateVersion   int                         `json:"state_version"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	StateUpdatedAt time.Time                   `json:"state_updated_at"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	StateUpdatedBy string                      `json:"state_updated_by"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	CreatedAt      time.Time                   `json:"created_at"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	UpdatedAt      time.Time                   `json:"updated_at"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-}
./apps/mcp-server/internal/api/websocket/workspace_manager.go-
./apps/mcp-server/internal/api/websocket/workspace_manager.go-// WorkspaceMember represents a workspace member
./apps/mcp-server/internal/api/websocket/workspace_manager.go-type WorkspaceMember struct {
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	ID       string    `json:"id"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	AgentID  string    `json:"agent_id"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	Role     string    `json:"role"` // member, moderator, admin
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	JoinedAt time.Time `json:"joined_at"`
./apps/mcp-server/internal/api/websocket/workspace_manager.go-}
./apps/mcp-server/internal/api/websocket/workspace_manager.go-
./apps/mcp-server/internal/api/websocket/workspace_manager.go-// CreateWorkspace creates a new workspace
./apps/mcp-server/internal/api/websocket/workspace_manager.go-func (wm *WorkspaceManager) CreateWorkspace(ctx context.Context, config *WorkspaceConfig) (*Workspace, error) {
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	workspace := &Workspace{
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		ID:          uuid.New().String(),
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		Name:        config.Name,
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		Description: config.Description,
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		Type:        config.Type,
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		OwnerID:     config.OwnerID,
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		TenantID:    config.TenantID,
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		Members:     make(map[string]*WorkspaceMember),
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		CreatedAt:   time.Now(),
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		UpdatedAt:   time.Now(),
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	}
./apps/mcp-server/internal/api/websocket/workspace_manager.go-
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	// Add owner as admin
./apps/mcp-server/internal/api/websocket/workspace_manager.go-	ownerMember := &WorkspaceMember{
./apps/mcp-server/internal/api/websocket/workspace_manager.go-		ID:       uuid.New().String(),
--
./apps/mcp-server/internal/api/websocket/agent_message_broker.go:type BrokerConfig struct {
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	// Stream configuration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	BaseStreamKey    string
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	ConsumerGroup    string
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	DeadLetterStream string
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	// Processing configuration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	BatchSize        int64
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	BlockTimeout     time.Duration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	ProcessTimeout   time.Duration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	MaxRetries       int
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	ClaimMinIdleTime time.Duration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	// Worker configuration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	NumWorkers        int
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	RoutingWorkers    int
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	CapabilityWorkers int
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	// Stream management
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	StreamTTL       time.Duration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	MaxStreamLength int64
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	TrimApproximate bool
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-}
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-// DefaultBrokerConfig returns default configuration
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-func DefaultBrokerConfig() *BrokerConfig {
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	return &BrokerConfig{
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		BaseStreamKey:     "agent:messages",
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		ConsumerGroup:     "agent-message-brokers",
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		DeadLetterStream:  "agent:messages:dlq",
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		BatchSize:         10,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		BlockTimeout:      5 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		ProcessTimeout:    30 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		MaxRetries:        3,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		ClaimMinIdleTime:  30 * time.Second,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		NumWorkers:        5,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		RoutingWorkers:    3,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		CapabilityWorkers: 2,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		StreamTTL:         24 * time.Hour,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		MaxStreamLength:   100000,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-		TrimApproximate:   true,
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	}
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-}
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-// AgentMessage represents a message between agents
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-type AgentMessage struct {
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	ID               string                 `json:"id"`
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	SourceAgentID    string                 `json:"source_agent_id"`
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	SourceAgentType  string                 `json:"source_agent_type"`
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	TargetAgentID    string                 `json:"target_agent_id,omitempty"`
./apps/mcp-server/internal/api/websocket/agent_message_broker.go-	TargetAgentType  string                 `json:"target_agent_type,omitempty"`
--
./apps/mcp-server/internal/api/tools/mcp_tools_server.go:type Config struct {
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	// EnableGitHubTools controls whether GitHub tools are enabled
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	EnableGitHubTools bool
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-}
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-// NewMCPToolsServer creates a new MCP tools server
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-func NewMCPToolsServer(
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	logger observability.Logger,
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	githubAdapter *github.GitHubAdapter,
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	config *Config,
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-) *MCPToolsServer {
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	// Create router
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	router := gin.New()
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	// Use recovery middleware
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	router.Use(gin.Recovery())
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	// Create server
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	server := &MCPToolsServer{
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-		router:        router,
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-		logger:        logger,
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-		githubAdapter: githubAdapter,
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	}
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	// Register tools
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	server.registerTools(config)
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	return server
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-}
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-// registerTools registers all enabled tools with the server
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-func (s *MCPToolsServer) registerTools(config *Config) {
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	// Register GitHub tools if enabled
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	if config.EnableGitHubTools && s.githubAdapter != nil {
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-		s.logger.Info("Registering GitHub tools", nil)
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-		githubtools.RegisterGitHubTools(s.router, s.githubAdapter, s.logger)
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	}
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-}
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-// GetRouter returns the underlying Gin router
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-func (s *MCPToolsServer) GetRouter() *gin.Engine {
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-	return s.router
./apps/mcp-server/internal/api/tools/mcp_tools_server.go-}
--
./apps/mcp-server/internal/api/dynamic_tools_models.go:type PassthroughConfig struct {
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Mode              string `json:"mode"`                // optional, required, disabled
./apps/mcp-server/internal/api/dynamic_tools_models.go-	FallbackToService bool   `json:"fallback_to_service"` // Allow fallback to service account
./apps/mcp-server/internal/api/dynamic_tools_models.go-}
./apps/mcp-server/internal/api/dynamic_tools_models.go-
./apps/mcp-server/internal/api/dynamic_tools_models.go-// Tool represents a configured tool with its current state
./apps/mcp-server/internal/api/dynamic_tools_models.go-type Tool struct {
./apps/mcp-server/internal/api/dynamic_tools_models.go-	ID                string                   `json:"id"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	TenantID          string                   `json:"tenant_id"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Name              string                   `json:"name"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	DisplayName       string                   `json:"display_name"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	BaseURL           string                   `json:"base_url"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	DocumentationURL  string                   `json:"documentation_url,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	OpenAPIURL        string                   `json:"openapi_url,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	AuthType          string                   `json:"auth_type"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Config            map[string]interface{}   `json:"config"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	RetryPolicy       *tools.ToolRetryPolicy   `json:"retry_policy,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	HealthConfig      *tools.HealthCheckConfig `json:"health_config,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Status            string                   `json:"status"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	HealthStatus      *tools.HealthStatus      `json:"health_status,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Provider          string                   `json:"provider,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	PassthroughConfig *PassthroughConfig       `json:"passthrough_config,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	CreatedAt         string                   `json:"created_at"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	UpdatedAt         string                   `json:"updated_at"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-
./apps/mcp-server/internal/api/dynamic_tools_models.go-	// Internal fields not exposed in JSON
./apps/mcp-server/internal/api/dynamic_tools_models.go-	InternalConfig tools.ToolConfig `json:"-"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-}
./apps/mcp-server/internal/api/dynamic_tools_models.go-
./apps/mcp-server/internal/api/dynamic_tools_models.go-// DiscoverySession represents an active discovery session
./apps/mcp-server/internal/api/dynamic_tools_models.go-type DiscoverySession struct {
./apps/mcp-server/internal/api/dynamic_tools_models.go-	ID             string                 `json:"id"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	TenantID       string                 `json:"tenant_id"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	SessionID      string                 `json:"session_id"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	BaseURL        string                 `json:"base_url"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Status         tools.DiscoveryStatus  `json:"status"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	DiscoveredURLs []string               `json:"discovered_urls,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	SelectedURL    string                 `json:"selected_url,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Metadata       map[string]interface{} `json:"metadata,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	ErrorMessage   string                 `json:"error_message,omitempty"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	CreatedAt      string                 `json:"created_at"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	ExpiresAt      string                 `json:"expires_at"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-}
./apps/mcp-server/internal/api/dynamic_tools_models.go-
./apps/mcp-server/internal/api/dynamic_tools_models.go-// ActionDefinition represents a tool action
./apps/mcp-server/internal/api/dynamic_tools_models.go-type ActionDefinition struct {
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Name        string                 `json:"name"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Description string                 `json:"description"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Method      string                 `json:"method"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Path        string                 `json:"path"`
./apps/mcp-server/internal/api/dynamic_tools_models.go-	Parameters  map[string]interface{} `json:"parameters"`
--
./apps/mcp-server/internal/api/middleware.go:type RateLimiterConfig struct {
./apps/mcp-server/internal/api/middleware.go-	Limit      float64       // Number of requests allowed per second
./apps/mcp-server/internal/api/middleware.go-	Burst      int           // Number of requests that can be made in a burst
./apps/mcp-server/internal/api/middleware.go-	Expiration time.Duration // How long to keep track of rate limits for a user
./apps/mcp-server/internal/api/middleware.go-}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-// NewRateLimiterConfigFromConfig creates a middleware rate limiter config from the API config
./apps/mcp-server/internal/api/middleware.go-func NewRateLimiterConfigFromConfig(cfg RateLimitConfig) RateLimiterConfig {
./apps/mcp-server/internal/api/middleware.go-	return RateLimiterConfig{
./apps/mcp-server/internal/api/middleware.go-		Limit:      float64(cfg.Limit),
./apps/mcp-server/internal/api/middleware.go-		Burst:      cfg.Limit * cfg.BurstFactor,
./apps/mcp-server/internal/api/middleware.go-		Expiration: 1 * time.Hour, // Default expiration
./apps/mcp-server/internal/api/middleware.go-	}
./apps/mcp-server/internal/api/middleware.go-}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-// RateLimiterStorage provides storage for rate limiting
./apps/mcp-server/internal/api/middleware.go-type RateLimiterStorage struct {
./apps/mcp-server/internal/api/middleware.go-	limiters map[string]*rate.Limiter
./apps/mcp-server/internal/api/middleware.go-	expiry   map[string]time.Time
./apps/mcp-server/internal/api/middleware.go-	config   RateLimiterConfig
./apps/mcp-server/internal/api/middleware.go-	mu       sync.RWMutex // Protect map access with mutex
./apps/mcp-server/internal/api/middleware.go-	done     chan struct{}
./apps/mcp-server/internal/api/middleware.go-}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-// NewRateLimiterStorage creates a new rate limiter storage
./apps/mcp-server/internal/api/middleware.go-func NewRateLimiterStorage(config RateLimiterConfig) *RateLimiterStorage {
./apps/mcp-server/internal/api/middleware.go-	storage := &RateLimiterStorage{
./apps/mcp-server/internal/api/middleware.go-		limiters: make(map[string]*rate.Limiter),
./apps/mcp-server/internal/api/middleware.go-		expiry:   make(map[string]time.Time),
./apps/mcp-server/internal/api/middleware.go-		config:   config,
./apps/mcp-server/internal/api/middleware.go-		done:     make(chan struct{}),
./apps/mcp-server/internal/api/middleware.go-	}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-	// Start a background cleanup job
./apps/mcp-server/internal/api/middleware.go-	go storage.cleanupTask()
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-	return storage
./apps/mcp-server/internal/api/middleware.go-}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-// GetLimiter returns a rate limiter for a given key
./apps/mcp-server/internal/api/middleware.go-func (s *RateLimiterStorage) GetLimiter(key string) *rate.Limiter {
./apps/mcp-server/internal/api/middleware.go-	s.mu.RLock()
./apps/mcp-server/internal/api/middleware.go-	// Check if limiter exists and is not expired
./apps/mcp-server/internal/api/middleware.go-	if limiter, exists := s.limiters[key]; exists {
./apps/mcp-server/internal/api/middleware.go-		if time.Now().Before(s.expiry[key]) {
./apps/mcp-server/internal/api/middleware.go-			s.mu.RUnlock()
./apps/mcp-server/internal/api/middleware.go-			return limiter
./apps/mcp-server/internal/api/middleware.go-		}
./apps/mcp-server/internal/api/middleware.go-	}
./apps/mcp-server/internal/api/middleware.go-	s.mu.RUnlock()
./apps/mcp-server/internal/api/middleware.go-
--
./apps/mcp-server/internal/api/middleware.go:type CORSConfig struct {
./apps/mcp-server/internal/api/middleware.go-	AllowedOrigins []string `mapstructure:"allowed_origins"`
./apps/mcp-server/internal/api/middleware.go-}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-// CachingMiddleware adds HTTP caching headers
./apps/mcp-server/internal/api/middleware.go-func CachingMiddleware() gin.HandlerFunc {
./apps/mcp-server/internal/api/middleware.go-	return func(c *gin.Context) {
./apps/mcp-server/internal/api/middleware.go-		// Skip non-GET requests
./apps/mcp-server/internal/api/middleware.go-		if c.Request.Method != "GET" {
./apps/mcp-server/internal/api/middleware.go-			c.Next()
./apps/mcp-server/internal/api/middleware.go-			return
./apps/mcp-server/internal/api/middleware.go-		}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-		// Process the request
./apps/mcp-server/internal/api/middleware.go-		c.Next()
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-		// After the request is processed, add caching headers if status is successful
./apps/mcp-server/internal/api/middleware.go-		if c.Writer.Status() >= 200 && c.Writer.Status() < 300 {
./apps/mcp-server/internal/api/middleware.go-			// Check if Cache-Control is already set
./apps/mcp-server/internal/api/middleware.go-			if c.Writer.Header().Get("Cache-Control") == "" {
./apps/mcp-server/internal/api/middleware.go-				// Default cache policy for GET requests
./apps/mcp-server/internal/api/middleware.go-				// Define different cache policies based on path
./apps/mcp-server/internal/api/middleware.go-				path := c.Request.URL.Path
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-				// Schema and documentation can be cached longer
./apps/mcp-server/internal/api/middleware.go-				if strings.Contains(path, "/swagger") {
./apps/mcp-server/internal/api/middleware.go-					c.Header("Cache-Control", "public, max-age=86400") // 1 day
./apps/mcp-server/internal/api/middleware.go-				} else if strings.HasPrefix(path, "/api/v1/tools") && !strings.Contains(path, "/actions/") {
./apps/mcp-server/internal/api/middleware.go-					// Tool metadata can be cached but not tool actions
./apps/mcp-server/internal/api/middleware.go-					c.Header("Cache-Control", "public, max-age=3600") // 1 hour
./apps/mcp-server/internal/api/middleware.go-				} else {
./apps/mcp-server/internal/api/middleware.go-					// Default for other GET requests - short cache with revalidation
./apps/mcp-server/internal/api/middleware.go-					c.Header("Cache-Control", "private, max-age=60, must-revalidate") // 1 minute
./apps/mcp-server/internal/api/middleware.go-				}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-				// Add ETag based on response size and last modified time
./apps/mcp-server/internal/api/middleware.go-				// In a real implementation, this would be a hash of the response content
./apps/mcp-server/internal/api/middleware.go-				etag := fmt.Sprintf("W/\"%d-%s\"", c.Writer.Size(), time.Now().UTC().Format(http.TimeFormat))
./apps/mcp-server/internal/api/middleware.go-				c.Header("ETag", etag)
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-				// Add Last-Modified header - in a real implementation this would come from the resource
./apps/mcp-server/internal/api/middleware.go-				c.Header("Last-Modified", time.Now().UTC().Format(http.TimeFormat))
./apps/mcp-server/internal/api/middleware.go-			}
./apps/mcp-server/internal/api/middleware.go-		}
./apps/mcp-server/internal/api/middleware.go-	}
./apps/mcp-server/internal/api/middleware.go-}
./apps/mcp-server/internal/api/middleware.go-
./apps/mcp-server/internal/api/middleware.go-// CORSMiddleware enables Cross-Origin Resource Sharing
./apps/mcp-server/internal/api/middleware.go-func CORSMiddleware(corsConfig CORSConfig) gin.HandlerFunc {
./apps/mcp-server/internal/api/middleware.go-	return func(c *gin.Context) {
./apps/mcp-server/internal/api/middleware.go-		// Get origin from request
--
./apps/worker/internal/worker/retry_handler.go:type RetryConfig struct {
./apps/worker/internal/worker/retry_handler.go-	MaxRetries      int
./apps/worker/internal/worker/retry_handler.go-	InitialInterval time.Duration
./apps/worker/internal/worker/retry_handler.go-	MaxInterval     time.Duration
./apps/worker/internal/worker/retry_handler.go-	Multiplier      float64
./apps/worker/internal/worker/retry_handler.go-	MaxElapsedTime  time.Duration
./apps/worker/internal/worker/retry_handler.go-}
./apps/worker/internal/worker/retry_handler.go-
./apps/worker/internal/worker/retry_handler.go-// DefaultRetryConfig returns default retry configuration
./apps/worker/internal/worker/retry_handler.go-func DefaultRetryConfig() *RetryConfig {
./apps/worker/internal/worker/retry_handler.go-	return &RetryConfig{
./apps/worker/internal/worker/retry_handler.go-		MaxRetries:      5,
./apps/worker/internal/worker/retry_handler.go-		InitialInterval: 1 * time.Second,
./apps/worker/internal/worker/retry_handler.go-		MaxInterval:     5 * time.Minute,
./apps/worker/internal/worker/retry_handler.go-		Multiplier:      2.0,
./apps/worker/internal/worker/retry_handler.go-		MaxElapsedTime:  30 * time.Minute,
./apps/worker/internal/worker/retry_handler.go-	}
./apps/worker/internal/worker/retry_handler.go-}
./apps/worker/internal/worker/retry_handler.go-
./apps/worker/internal/worker/retry_handler.go-// RetryHandler handles retries with exponential backoff
./apps/worker/internal/worker/retry_handler.go-type RetryHandler struct {
./apps/worker/internal/worker/retry_handler.go-	config  *RetryConfig
./apps/worker/internal/worker/retry_handler.go-	logger  observability.Logger
./apps/worker/internal/worker/retry_handler.go-	dlq     DLQHandler
./apps/worker/internal/worker/retry_handler.go-	metrics *MetricsCollector
./apps/worker/internal/worker/retry_handler.go-}
./apps/worker/internal/worker/retry_handler.go-
./apps/worker/internal/worker/retry_handler.go-// NewRetryHandler creates a new retry handler
./apps/worker/internal/worker/retry_handler.go-func NewRetryHandler(config *RetryConfig, logger observability.Logger, dlq DLQHandler, metrics *MetricsCollector) *RetryHandler {
./apps/worker/internal/worker/retry_handler.go-	if config == nil {
./apps/worker/internal/worker/retry_handler.go-		config = DefaultRetryConfig()
./apps/worker/internal/worker/retry_handler.go-	}
./apps/worker/internal/worker/retry_handler.go-	return &RetryHandler{
./apps/worker/internal/worker/retry_handler.go-		config:  config,
./apps/worker/internal/worker/retry_handler.go-		logger:  logger,
./apps/worker/internal/worker/retry_handler.go-		dlq:     dlq,
./apps/worker/internal/worker/retry_handler.go-		metrics: metrics,
./apps/worker/internal/worker/retry_handler.go-	}
./apps/worker/internal/worker/retry_handler.go-}
./apps/worker/internal/worker/retry_handler.go-
./apps/worker/internal/worker/retry_handler.go-// ExecuteWithRetry executes a function with exponential backoff retry
./apps/worker/internal/worker/retry_handler.go-func (r *RetryHandler) ExecuteWithRetry(ctx context.Context, event queue.Event, fn func() error) error {
./apps/worker/internal/worker/retry_handler.go-	// Create exponential backoff configuration
./apps/worker/internal/worker/retry_handler.go-	b := backoff.NewExponentialBackOff()
./apps/worker/internal/worker/retry_handler.go-	b.InitialInterval = r.config.InitialInterval
./apps/worker/internal/worker/retry_handler.go-	b.MaxInterval = r.config.MaxInterval
./apps/worker/internal/worker/retry_handler.go-	b.Multiplier = r.config.Multiplier
./apps/worker/internal/worker/retry_handler.go-	b.MaxElapsedTime = r.config.MaxElapsedTime
./apps/worker/internal/worker/retry_handler.go-
./apps/worker/internal/worker/retry_handler.go-	// Wrap with max retries
./apps/worker/internal/worker/retry_handler.go-	backoffWithRetries := backoff.WithMaxRetries(b, uint64(r.config.MaxRetries))
--
./apps/rest-api/internal/api/config.go:type Config struct {
./apps/rest-api/internal/api/config.go-	ListenAddress string                   `mapstructure:"listen_address"`
./apps/rest-api/internal/api/config.go-	ReadTimeout   time.Duration            `mapstructure:"read_timeout"`
./apps/rest-api/internal/api/config.go-	WriteTimeout  time.Duration            `mapstructure:"write_timeout"`
./apps/rest-api/internal/api/config.go-	IdleTimeout   time.Duration            `mapstructure:"idle_timeout"`
./apps/rest-api/internal/api/config.go-	EnableCORS    bool                     `mapstructure:"enable_cors"`
./apps/rest-api/internal/api/config.go-	EnableSwagger bool                     `mapstructure:"enable_swagger"`
./apps/rest-api/internal/api/config.go-	TLSCertFile   string                   `mapstructure:"tls_cert_file"`
./apps/rest-api/internal/api/config.go-	TLSKeyFile    string                   `mapstructure:"tls_key_file"`
./apps/rest-api/internal/api/config.go-	Auth          AuthConfig               `mapstructure:"auth"`
./apps/rest-api/internal/api/config.go-	RateLimit     RateLimitConfig          `mapstructure:"rate_limit"`
./apps/rest-api/internal/api/config.go-	Versioning    VersioningConfig         `mapstructure:"versioning"`
./apps/rest-api/internal/api/config.go-	Performance   PerformanceConfig        `mapstructure:"performance"`
./apps/rest-api/internal/api/config.go-	Webhook       interfaces.WebhookConfig `mapstructure:"webhook"`
./apps/rest-api/internal/api/config.go-}
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-// VersioningConfig holds API versioning configuration
./apps/rest-api/internal/api/config.go:type VersioningConfig struct {
./apps/rest-api/internal/api/config.go-	Enabled           bool     `mapstructure:"enabled"`
./apps/rest-api/internal/api/config.go-	DefaultVersion    string   `mapstructure:"default_version"`
./apps/rest-api/internal/api/config.go-	SupportedVersions []string `mapstructure:"supported_versions"`
./apps/rest-api/internal/api/config.go-}
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-// PerformanceConfig holds configuration for performance optimization
./apps/rest-api/internal/api/config.go:type PerformanceConfig struct {
./apps/rest-api/internal/api/config.go-	// Connection pooling for database
./apps/rest-api/internal/api/config.go-	DBMaxIdleConns    int           `mapstructure:"db_max_idle_conns"`
./apps/rest-api/internal/api/config.go-	DBMaxOpenConns    int           `mapstructure:"db_max_open_conns"`
./apps/rest-api/internal/api/config.go-	DBConnMaxLifetime time.Duration `mapstructure:"db_conn_max_lifetime"`
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-	// HTTP client settings
./apps/rest-api/internal/api/config.go-	HTTPMaxIdleConns    int           `mapstructure:"http_max_idle_conns"`
./apps/rest-api/internal/api/config.go-	HTTPMaxConnsPerHost int           `mapstructure:"http_max_conns_per_host"`
./apps/rest-api/internal/api/config.go-	HTTPIdleConnTimeout time.Duration `mapstructure:"http_idle_conn_timeout"`
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-	// Response optimization
./apps/rest-api/internal/api/config.go-	EnableCompression bool `mapstructure:"enable_compression"`
./apps/rest-api/internal/api/config.go-	EnableETagCaching bool `mapstructure:"enable_etag_caching"`
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-	// Cache control settings
./apps/rest-api/internal/api/config.go-	StaticContentMaxAge  time.Duration `mapstructure:"static_content_max_age"`
./apps/rest-api/internal/api/config.go-	DynamicContentMaxAge time.Duration `mapstructure:"dynamic_content_max_age"`
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-	// Circuit breaker settings for external services
./apps/rest-api/internal/api/config.go-	CircuitBreakerEnabled bool          `mapstructure:"circuit_breaker_enabled"`
./apps/rest-api/internal/api/config.go-	CircuitBreakerTimeout time.Duration `mapstructure:"circuit_breaker_timeout"`
./apps/rest-api/internal/api/config.go-	MaxRetries            int           `mapstructure:"max_retries"`
./apps/rest-api/internal/api/config.go-	RetryBackoff          time.Duration `mapstructure:"retry_backoff"`
./apps/rest-api/internal/api/config.go-}
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-// AuthConfig holds authentication configuration
./apps/rest-api/internal/api/config.go:type AuthConfig struct {
./apps/rest-api/internal/api/config.go-	JWTSecret string `mapstructure:"jwt_secret"`
./apps/rest-api/internal/api/config.go-	APIKeys   any    `mapstructure:"api_keys"`
./apps/rest-api/internal/api/config.go-}
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-// RateLimitConfig holds rate limiting configuration
./apps/rest-api/internal/api/config.go:type RateLimitConfig struct {
./apps/rest-api/internal/api/config.go-	Enabled     bool          `mapstructure:"enabled"`
./apps/rest-api/internal/api/config.go-	Limit       int           `mapstructure:"limit"`
./apps/rest-api/internal/api/config.go-	Period      time.Duration `mapstructure:"period"`
./apps/rest-api/internal/api/config.go-	BurstFactor int           `mapstructure:"burst_factor"`
./apps/rest-api/internal/api/config.go-}
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-// DefaultConfig returns a Config with sensible defaults
./apps/rest-api/internal/api/config.go-func DefaultConfig() Config {
./apps/rest-api/internal/api/config.go-	return Config{
./apps/rest-api/internal/api/config.go-		ListenAddress: ":8080",
./apps/rest-api/internal/api/config.go-		ReadTimeout:   30 * time.Second,
./apps/rest-api/internal/api/config.go-		WriteTimeout:  60 * time.Second,
./apps/rest-api/internal/api/config.go-		IdleTimeout:   120 * time.Second,
./apps/rest-api/internal/api/config.go-		EnableCORS:    true,
./apps/rest-api/internal/api/config.go-		EnableSwagger: true,
./apps/rest-api/internal/api/config.go-		Auth: AuthConfig{
./apps/rest-api/internal/api/config.go-			JWTSecret: "", // Must be provided by user
./apps/rest-api/internal/api/config.go-			APIKeys:   make(map[string]string),
./apps/rest-api/internal/api/config.go-		},
./apps/rest-api/internal/api/config.go-		RateLimit: RateLimitConfig{
./apps/rest-api/internal/api/config.go-			Enabled:     true,
./apps/rest-api/internal/api/config.go-			Limit:       100,
./apps/rest-api/internal/api/config.go-			Period:      time.Minute,
./apps/rest-api/internal/api/config.go-			BurstFactor: 3,
./apps/rest-api/internal/api/config.go-		},
./apps/rest-api/internal/api/config.go-		Versioning: VersioningConfig{
./apps/rest-api/internal/api/config.go-			Enabled:           true,
./apps/rest-api/internal/api/config.go-			DefaultVersion:    "1.0",
./apps/rest-api/internal/api/config.go-			SupportedVersions: []string{"1.0"},
./apps/rest-api/internal/api/config.go-		},
./apps/rest-api/internal/api/config.go-		Performance: PerformanceConfig{
./apps/rest-api/internal/api/config.go-			// Database connection pooling defaults
./apps/rest-api/internal/api/config.go-			DBMaxIdleConns:    10,
./apps/rest-api/internal/api/config.go-			DBMaxOpenConns:    100,
./apps/rest-api/internal/api/config.go-			DBConnMaxLifetime: 30 * time.Minute,
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-			// HTTP client settings
./apps/rest-api/internal/api/config.go-			HTTPMaxIdleConns:    100,
./apps/rest-api/internal/api/config.go-			HTTPMaxConnsPerHost: 10,
./apps/rest-api/internal/api/config.go-			HTTPIdleConnTimeout: 90 * time.Second,
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-			// Response optimization
./apps/rest-api/internal/api/config.go-			EnableCompression: true,
./apps/rest-api/internal/api/config.go-			EnableETagCaching: true,
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-			// Cache control settings
./apps/rest-api/internal/api/config.go-			StaticContentMaxAge:  24 * time.Hour,
./apps/rest-api/internal/api/config.go-			DynamicContentMaxAge: 5 * time.Minute,
./apps/rest-api/internal/api/config.go-
./apps/rest-api/internal/api/config.go-			// Circuit breaker settings
--
./apps/rest-api/internal/api/security_headers.go:type SecurityHeadersConfig struct {
./apps/rest-api/internal/api/security_headers.go-	Enabled              bool
./apps/rest-api/internal/api/security_headers.go-	EnableHSTS           bool
./apps/rest-api/internal/api/security_headers.go-	HSTSMaxAge           int
./apps/rest-api/internal/api/security_headers.go-	EnableXFrameOptions  bool
./apps/rest-api/internal/api/security_headers.go-	XFrameOptions        string
./apps/rest-api/internal/api/security_headers.go-	EnableXContentType   bool
./apps/rest-api/internal/api/security_headers.go-	EnableXSSProtection  bool
./apps/rest-api/internal/api/security_headers.go-	EnableReferrerPolicy bool
./apps/rest-api/internal/api/security_headers.go-	ReferrerPolicy       string
./apps/rest-api/internal/api/security_headers.go-}
./apps/rest-api/internal/api/security_headers.go-
./apps/rest-api/internal/api/security_headers.go-// DefaultSecurityHeadersConfig returns default security headers configuration
./apps/rest-api/internal/api/security_headers.go-func DefaultSecurityHeadersConfig() SecurityHeadersConfig {
./apps/rest-api/internal/api/security_headers.go-	return SecurityHeadersConfig{
./apps/rest-api/internal/api/security_headers.go-		Enabled:              true,
./apps/rest-api/internal/api/security_headers.go-		EnableHSTS:           true,
./apps/rest-api/internal/api/security_headers.go-		HSTSMaxAge:           31536000, // 1 year
./apps/rest-api/internal/api/security_headers.go-		EnableXFrameOptions:  true,
./apps/rest-api/internal/api/security_headers.go-		XFrameOptions:        "DENY",
./apps/rest-api/internal/api/security_headers.go-		EnableXContentType:   true,
./apps/rest-api/internal/api/security_headers.go-		EnableXSSProtection:  true,
./apps/rest-api/internal/api/security_headers.go-		EnableReferrerPolicy: true,
./apps/rest-api/internal/api/security_headers.go-		ReferrerPolicy:       "strict-origin-when-cross-origin",
./apps/rest-api/internal/api/security_headers.go-	}
./apps/rest-api/internal/api/security_headers.go-}
./apps/rest-api/internal/api/security_headers.go-
./apps/rest-api/internal/api/security_headers.go-// SecurityHeaders adds security headers to responses
./apps/rest-api/internal/api/security_headers.go-// Note: In production, these headers are typically set by the reverse proxy (nginx, etc.)
./apps/rest-api/internal/api/security_headers.go-// This middleware is useful for development or when not behind a reverse proxy
./apps/rest-api/internal/api/security_headers.go-func SecurityHeaders(config SecurityHeadersConfig) gin.HandlerFunc {
./apps/rest-api/internal/api/security_headers.go-	return func(c *gin.Context) {
./apps/rest-api/internal/api/security_headers.go-		if !config.Enabled {
./apps/rest-api/internal/api/security_headers.go-			c.Next()
./apps/rest-api/internal/api/security_headers.go-			return
./apps/rest-api/internal/api/security_headers.go-		}
./apps/rest-api/internal/api/security_headers.go-
./apps/rest-api/internal/api/security_headers.go-		// HSTS - only on HTTPS
./apps/rest-api/internal/api/security_headers.go-		if config.EnableHSTS && c.Request.TLS != nil {
./apps/rest-api/internal/api/security_headers.go-			c.Header("Strict-Transport-Security",
./apps/rest-api/internal/api/security_headers.go-				"max-age="+string(rune(config.HSTSMaxAge))+"; includeSubDomains")
./apps/rest-api/internal/api/security_headers.go-		}
./apps/rest-api/internal/api/security_headers.go-
./apps/rest-api/internal/api/security_headers.go-		// X-Frame-Options
./apps/rest-api/internal/api/security_headers.go-		if config.EnableXFrameOptions {
./apps/rest-api/internal/api/security_headers.go-			c.Header("X-Frame-Options", config.XFrameOptions)
./apps/rest-api/internal/api/security_headers.go-		}
./apps/rest-api/internal/api/security_headers.go-
./apps/rest-api/internal/api/security_headers.go-		// X-Content-Type-Options
./apps/rest-api/internal/api/security_headers.go-		if config.EnableXContentType {
./apps/rest-api/internal/api/security_headers.go-			c.Header("X-Content-Type-Options", "nosniff")
--
./apps/rest-api/internal/api/middleware.go:type RateLimiterConfig struct {
./apps/rest-api/internal/api/middleware.go-	Limit      float64       // Number of requests allowed per second
./apps/rest-api/internal/api/middleware.go-	Burst      int           // Number of requests that can be made in a burst
./apps/rest-api/internal/api/middleware.go-	Expiration time.Duration // How long to keep track of rate limits for a user
./apps/rest-api/internal/api/middleware.go-}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-// NewRateLimiterConfigFromConfig creates a middleware rate limiter config from the API config
./apps/rest-api/internal/api/middleware.go-func NewRateLimiterConfigFromConfig(cfg RateLimitConfig) RateLimiterConfig {
./apps/rest-api/internal/api/middleware.go-	return RateLimiterConfig{
./apps/rest-api/internal/api/middleware.go-		Limit:      float64(cfg.Limit),
./apps/rest-api/internal/api/middleware.go-		Burst:      cfg.Limit * cfg.BurstFactor,
./apps/rest-api/internal/api/middleware.go-		Expiration: 1 * time.Hour, // Default expiration
./apps/rest-api/internal/api/middleware.go-	}
./apps/rest-api/internal/api/middleware.go-}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-// RateLimiterStorage provides storage for rate limiting
./apps/rest-api/internal/api/middleware.go-type RateLimiterStorage struct {
./apps/rest-api/internal/api/middleware.go-	limiters map[string]*rate.Limiter
./apps/rest-api/internal/api/middleware.go-	expiry   map[string]time.Time
./apps/rest-api/internal/api/middleware.go-	config   RateLimiterConfig
./apps/rest-api/internal/api/middleware.go-	mu       sync.RWMutex // Protect map access with mutex
./apps/rest-api/internal/api/middleware.go-	done     chan struct{}
./apps/rest-api/internal/api/middleware.go-}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-// NewRateLimiterStorage creates a new rate limiter storage
./apps/rest-api/internal/api/middleware.go-func NewRateLimiterStorage(config RateLimiterConfig) *RateLimiterStorage {
./apps/rest-api/internal/api/middleware.go-	storage := &RateLimiterStorage{
./apps/rest-api/internal/api/middleware.go-		limiters: make(map[string]*rate.Limiter),
./apps/rest-api/internal/api/middleware.go-		expiry:   make(map[string]time.Time),
./apps/rest-api/internal/api/middleware.go-		config:   config,
./apps/rest-api/internal/api/middleware.go-		done:     make(chan struct{}),
./apps/rest-api/internal/api/middleware.go-	}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-	// Start a background cleanup job
./apps/rest-api/internal/api/middleware.go-	go storage.cleanupTask()
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-	return storage
./apps/rest-api/internal/api/middleware.go-}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-// GetLimiter returns a rate limiter for a given key
./apps/rest-api/internal/api/middleware.go-func (s *RateLimiterStorage) GetLimiter(key string) *rate.Limiter {
./apps/rest-api/internal/api/middleware.go-	s.mu.RLock()
./apps/rest-api/internal/api/middleware.go-	// Check if limiter exists and is not expired
./apps/rest-api/internal/api/middleware.go-	if limiter, exists := s.limiters[key]; exists {
./apps/rest-api/internal/api/middleware.go-		if time.Now().Before(s.expiry[key]) {
./apps/rest-api/internal/api/middleware.go-			s.mu.RUnlock()
./apps/rest-api/internal/api/middleware.go-			return limiter
./apps/rest-api/internal/api/middleware.go-		}
./apps/rest-api/internal/api/middleware.go-	}
./apps/rest-api/internal/api/middleware.go-	s.mu.RUnlock()
./apps/rest-api/internal/api/middleware.go-
--
./apps/rest-api/internal/api/middleware.go:type CORSConfig struct {
./apps/rest-api/internal/api/middleware.go-	AllowedOrigins []string `mapstructure:"allowed_origins"`
./apps/rest-api/internal/api/middleware.go-}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-// CachingMiddleware adds HTTP caching headers
./apps/rest-api/internal/api/middleware.go-func CachingMiddleware() gin.HandlerFunc {
./apps/rest-api/internal/api/middleware.go-	return func(c *gin.Context) {
./apps/rest-api/internal/api/middleware.go-		// Skip non-GET requests
./apps/rest-api/internal/api/middleware.go-		if c.Request.Method != "GET" {
./apps/rest-api/internal/api/middleware.go-			c.Next()
./apps/rest-api/internal/api/middleware.go-			return
./apps/rest-api/internal/api/middleware.go-		}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-		// Process the request
./apps/rest-api/internal/api/middleware.go-		c.Next()
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-		// After the request is processed, add caching headers if status is successful
./apps/rest-api/internal/api/middleware.go-		if c.Writer.Status() >= 200 && c.Writer.Status() < 300 {
./apps/rest-api/internal/api/middleware.go-			// Check if Cache-Control is already set
./apps/rest-api/internal/api/middleware.go-			if c.Writer.Header().Get("Cache-Control") == "" {
./apps/rest-api/internal/api/middleware.go-				// Default cache policy for GET requests
./apps/rest-api/internal/api/middleware.go-				// Define different cache policies based on path
./apps/rest-api/internal/api/middleware.go-				path := c.Request.URL.Path
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-				// Schema and documentation can be cached longer
./apps/rest-api/internal/api/middleware.go-				if strings.Contains(path, "/swagger") {
./apps/rest-api/internal/api/middleware.go-					c.Header("Cache-Control", "public, max-age=86400") // 1 day
./apps/rest-api/internal/api/middleware.go-				} else if strings.HasPrefix(path, "/api/v1/tools") && !strings.Contains(path, "/actions/") {
./apps/rest-api/internal/api/middleware.go-					// Tool metadata can be cached but not tool actions
./apps/rest-api/internal/api/middleware.go-					c.Header("Cache-Control", "public, max-age=3600") // 1 hour
./apps/rest-api/internal/api/middleware.go-				} else {
./apps/rest-api/internal/api/middleware.go-					// Default for other GET requests - short cache with revalidation
./apps/rest-api/internal/api/middleware.go-					c.Header("Cache-Control", "private, max-age=60, must-revalidate") // 1 minute
./apps/rest-api/internal/api/middleware.go-				}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-				// Add ETag based on response size and last modified time
./apps/rest-api/internal/api/middleware.go-				// In a real implementation, this would be a hash of the response content
./apps/rest-api/internal/api/middleware.go-				etag := fmt.Sprintf("W/\"%d-%s\"", c.Writer.Size(), time.Now().UTC().Format(http.TimeFormat))
./apps/rest-api/internal/api/middleware.go-				c.Header("ETag", etag)
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-				// Add Last-Modified header - in a real implementation this would come from the resource
./apps/rest-api/internal/api/middleware.go-				c.Header("Last-Modified", time.Now().UTC().Format(http.TimeFormat))
./apps/rest-api/internal/api/middleware.go-			}
./apps/rest-api/internal/api/middleware.go-		}
./apps/rest-api/internal/api/middleware.go-	}
./apps/rest-api/internal/api/middleware.go-}
./apps/rest-api/internal/api/middleware.go-
./apps/rest-api/internal/api/middleware.go-// CORSMiddleware enables Cross-Origin Resource Sharing
./apps/rest-api/internal/api/middleware.go-func CORSMiddleware(corsConfig CORSConfig) gin.HandlerFunc {
./apps/rest-api/internal/api/middleware.go-	return func(c *gin.Context) {
./apps/rest-api/internal/api/middleware.go-		// Get origin from request
--
./pkg/webhook/embedding.go:type EmbeddingConfig struct {
./pkg/webhook/embedding.go-	Provider       string                 // "openai", "sentence-transformers", "custom"
./pkg/webhook/embedding.go-	Model          string                 // Model name
./pkg/webhook/embedding.go-	Dimensions     int                    // Embedding dimensions
./pkg/webhook/embedding.go-	MaxTextLength  int                    // Maximum text length
./pkg/webhook/embedding.go-	BatchSize      int                    // Batch processing size
./pkg/webhook/embedding.go-	CacheDuration  time.Duration          // Cache duration for embeddings
./pkg/webhook/embedding.go-	ProviderConfig map[string]interface{} // Provider-specific config
./pkg/webhook/embedding.go-}
./pkg/webhook/embedding.go-
./pkg/webhook/embedding.go-// DefaultEmbeddingConfig returns default embedding configuration
./pkg/webhook/embedding.go-func DefaultEmbeddingConfig() *EmbeddingConfig {
./pkg/webhook/embedding.go-	return &EmbeddingConfig{
./pkg/webhook/embedding.go-		Provider:      "sentence-transformers",
./pkg/webhook/embedding.go-		Model:         "all-MiniLM-L6-v2",
./pkg/webhook/embedding.go-		Dimensions:    384,
./pkg/webhook/embedding.go-		MaxTextLength: 512,
./pkg/webhook/embedding.go-		BatchSize:     32,
./pkg/webhook/embedding.go-		CacheDuration: 24 * time.Hour,
./pkg/webhook/embedding.go-		ProviderConfig: map[string]interface{}{
./pkg/webhook/embedding.go-			"endpoint": "http://localhost:8001/embed", // Local embedding service
./pkg/webhook/embedding.go-		},
./pkg/webhook/embedding.go-	}
./pkg/webhook/embedding.go-}
./pkg/webhook/embedding.go-
./pkg/webhook/embedding.go-// EmbeddingService manages embeddings for webhook contexts
./pkg/webhook/embedding.go-type EmbeddingService struct {
./pkg/webhook/embedding.go-	config   *EmbeddingConfig
./pkg/webhook/embedding.go-	provider EmbeddingProvider
./pkg/webhook/embedding.go-	cache    EmbeddingCache
./pkg/webhook/embedding.go-	logger   observability.Logger
./pkg/webhook/embedding.go-
./pkg/webhook/embedding.go-	// Metrics
./pkg/webhook/embedding.go-	metrics EmbeddingMetrics
./pkg/webhook/embedding.go-}
./pkg/webhook/embedding.go-
./pkg/webhook/embedding.go-// EmbeddingMetrics tracks embedding generation statistics
./pkg/webhook/embedding.go-type EmbeddingMetrics struct {
./pkg/webhook/embedding.go-	mu                    sync.RWMutex
./pkg/webhook/embedding.go-	TotalGenerated        int64
./pkg/webhook/embedding.go-	TotalCacheHits        int64
./pkg/webhook/embedding.go-	TotalCacheMisses      int64
./pkg/webhook/embedding.go-	AverageGenerationTime time.Duration
./pkg/webhook/embedding.go-	TotalErrors           int64
./pkg/webhook/embedding.go-}
./pkg/webhook/embedding.go-
./pkg/webhook/embedding.go-// EmbeddingCache defines the interface for embedding cache
./pkg/webhook/embedding.go-type EmbeddingCache interface {
./pkg/webhook/embedding.go-	Get(ctx context.Context, key string) ([]float32, error)
./pkg/webhook/embedding.go-	Set(ctx context.Context, key string, embedding []float32, ttl time.Duration) error
./pkg/webhook/embedding.go-	GetBatch(ctx context.Context, keys []string) (map[string][]float32, error)
--
./pkg/webhook/deduplication.go:type DeduplicationConfig struct {
./pkg/webhook/deduplication.go-	// Window configurations per tool type
./pkg/webhook/deduplication.go-	WindowConfigs map[string]WindowConfig
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-	// Default window configuration
./pkg/webhook/deduplication.go-	DefaultWindow WindowConfig
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-	// Bloom filter settings
./pkg/webhook/deduplication.go-	BloomFilterSize      uint
./pkg/webhook/deduplication.go-	BloomFilterHashFuncs uint
./pkg/webhook/deduplication.go-	BloomRotationPeriod  time.Duration
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-	// Redis key prefix
./pkg/webhook/deduplication.go-	RedisKeyPrefix string
./pkg/webhook/deduplication.go-}
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-// WindowConfig defines deduplication window settings
./pkg/webhook/deduplication.go:type WindowConfig struct {
./pkg/webhook/deduplication.go-	Duration time.Duration
./pkg/webhook/deduplication.go-	MaxSize  int64 // Maximum number of entries to track
./pkg/webhook/deduplication.go-}
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-// DefaultDeduplicationConfig returns default configuration
./pkg/webhook/deduplication.go-func DefaultDeduplicationConfig() *DeduplicationConfig {
./pkg/webhook/deduplication.go-	return &DeduplicationConfig{
./pkg/webhook/deduplication.go-		WindowConfigs: map[string]WindowConfig{
./pkg/webhook/deduplication.go-			"github": {
./pkg/webhook/deduplication.go-				Duration: 5 * time.Minute,
./pkg/webhook/deduplication.go-				MaxSize:  10000,
./pkg/webhook/deduplication.go-			},
./pkg/webhook/deduplication.go-			"gitlab": {
./pkg/webhook/deduplication.go-				Duration: 5 * time.Minute,
./pkg/webhook/deduplication.go-				MaxSize:  10000,
./pkg/webhook/deduplication.go-			},
./pkg/webhook/deduplication.go-			"jira": {
./pkg/webhook/deduplication.go-				Duration: 10 * time.Minute,
./pkg/webhook/deduplication.go-				MaxSize:  5000,
./pkg/webhook/deduplication.go-			},
./pkg/webhook/deduplication.go-		},
./pkg/webhook/deduplication.go-		DefaultWindow: WindowConfig{
./pkg/webhook/deduplication.go-			Duration: 5 * time.Minute,
./pkg/webhook/deduplication.go-			MaxSize:  10000,
./pkg/webhook/deduplication.go-		},
./pkg/webhook/deduplication.go-		BloomFilterSize:      1000000, // 1M entries
./pkg/webhook/deduplication.go-		BloomFilterHashFuncs: 7,
./pkg/webhook/deduplication.go-		BloomRotationPeriod:  24 * time.Hour,
./pkg/webhook/deduplication.go-		RedisKeyPrefix:       "webhook:dedup:",
./pkg/webhook/deduplication.go-	}
./pkg/webhook/deduplication.go-}
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-// Deduplicator handles webhook event deduplication
./pkg/webhook/deduplication.go-type Deduplicator struct {
./pkg/webhook/deduplication.go-	config      *DeduplicationConfig
./pkg/webhook/deduplication.go-	redisClient *redis.StreamsClient
./pkg/webhook/deduplication.go-	logger      observability.Logger
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-	// Current and previous bloom filters for rotation
./pkg/webhook/deduplication.go-	currentBloom  *bloom.BloomFilter
./pkg/webhook/deduplication.go-	previousBloom *bloom.BloomFilter
./pkg/webhook/deduplication.go-	bloomMu       sync.RWMutex
./pkg/webhook/deduplication.go-	lastRotation  time.Time
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-	// Metrics
./pkg/webhook/deduplication.go-	metrics DeduplicationMetrics
./pkg/webhook/deduplication.go-}
./pkg/webhook/deduplication.go-
./pkg/webhook/deduplication.go-// DeduplicationMetrics tracks deduplication statistics
./pkg/webhook/deduplication.go-type DeduplicationMetrics struct {
--
./pkg/webhook/coordinator.go:type CoordinatorConfig struct {
./pkg/webhook/coordinator.go-	// Coordination settings
./pkg/webhook/coordinator.go-	HeartbeatInterval time.Duration
./pkg/webhook/coordinator.go-	ConsumerTimeout   time.Duration
./pkg/webhook/coordinator.go-	RebalanceInterval time.Duration
./pkg/webhook/coordinator.go-
./pkg/webhook/coordinator.go-	// Leader election
./pkg/webhook/coordinator.go-	LeaderKey string
./pkg/webhook/coordinator.go-	LeaderTTL time.Duration
./pkg/webhook/coordinator.go-
./pkg/webhook/coordinator.go-	// Stream distribution
./pkg/webhook/coordinator.go-	MinConsumersPerStream int
./pkg/webhook/coordinator.go-	MaxConsumersPerStream int
./pkg/webhook/coordinator.go-
./pkg/webhook/coordinator.go-	// Health check settings
./pkg/webhook/coordinator.go-	HealthCheckInterval time.Duration
./pkg/webhook/coordinator.go-	UnhealthyThreshold  int
./pkg/webhook/coordinator.go-}
./pkg/webhook/coordinator.go-
./pkg/webhook/coordinator.go-// DefaultCoordinatorConfig returns default coordinator configuration
./pkg/webhook/coordinator.go-func DefaultCoordinatorConfig() *CoordinatorConfig {
./pkg/webhook/coordinator.go-	return &CoordinatorConfig{
./pkg/webhook/coordinator.go-		HeartbeatInterval:     10 * time.Second,
./pkg/webhook/coordinator.go-		ConsumerTimeout:       30 * time.Second,
./pkg/webhook/coordinator.go-		RebalanceInterval:     60 * time.Second,
./pkg/webhook/coordinator.go-		LeaderKey:             "webhook:coordinator:leader",
./pkg/webhook/coordinator.go-		LeaderTTL:             15 * time.Second,
./pkg/webhook/coordinator.go-		MinConsumersPerStream: 2,
./pkg/webhook/coordinator.go-		MaxConsumersPerStream: 10,
./pkg/webhook/coordinator.go-		HealthCheckInterval:   30 * time.Second,
./pkg/webhook/coordinator.go-		UnhealthyThreshold:    3,
./pkg/webhook/coordinator.go-	}
./pkg/webhook/coordinator.go-}
./pkg/webhook/coordinator.go-
./pkg/webhook/coordinator.go-// ConsumerInfo represents information about a consumer
./pkg/webhook/coordinator.go-type ConsumerInfo struct {
./pkg/webhook/coordinator.go-	ID              string          `json:"id"`
./pkg/webhook/coordinator.go-	GroupID         string          `json:"group_id"`
./pkg/webhook/coordinator.go-	Hostname        string          `json:"hostname"`
./pkg/webhook/coordinator.go-	StartTime       time.Time       `json:"start_time"`
./pkg/webhook/coordinator.go-	LastHeartbeat   time.Time       `json:"last_heartbeat"`
./pkg/webhook/coordinator.go-	State           ConsumerState   `json:"state"`
./pkg/webhook/coordinator.go-	AssignedStreams []string        `json:"assigned_streams"`
./pkg/webhook/coordinator.go-	ProcessingStats ProcessingStats `json:"processing_stats"`
./pkg/webhook/coordinator.go-	HealthStatus    HealthStatus    `json:"health_status"`
./pkg/webhook/coordinator.go-}
./pkg/webhook/coordinator.go-
./pkg/webhook/coordinator.go-// ConsumerState represents the state of a consumer
./pkg/webhook/coordinator.go-type ConsumerState string
./pkg/webhook/coordinator.go-
./pkg/webhook/coordinator.go-const (
--
./pkg/webhook/security.go:type SecurityConfig struct {
./pkg/webhook/security.go-	// Webhook signature verification
./pkg/webhook/security.go-	EnableSignatureVerification bool              `yaml:"enable_signature_verification" json:"enable_signature_verification"`
./pkg/webhook/security.go-	SignatureSecrets            map[string]string `yaml:"signature_secrets" json:"-"` // toolID -> secret
./pkg/webhook/security.go-	SignatureHeader             string            `yaml:"signature_header" json:"signature_header"`
./pkg/webhook/security.go-	TimestampTolerance          time.Duration     `yaml:"timestamp_tolerance" json:"timestamp_tolerance"`
./pkg/webhook/security.go-
./pkg/webhook/security.go-	// Rate limiting
./pkg/webhook/security.go-	EnableRateLimiting bool                     `yaml:"enable_rate_limiting" json:"enable_rate_limiting"`
./pkg/webhook/security.go-	GlobalRateLimit    int                      `yaml:"global_rate_limit" json:"global_rate_limit"`       // requests per second
./pkg/webhook/security.go-	PerToolRateLimits  map[string]int           `yaml:"per_tool_rate_limits" json:"per_tool_rate_limits"` // toolID -> RPS
./pkg/webhook/security.go-	BurstSize          int                      `yaml:"burst_size" json:"burst_size"`
./pkg/webhook/security.go-	RateLimiters       map[string]*rate.Limiter `yaml:"-" json:"-"`
./pkg/webhook/security.go-
./pkg/webhook/security.go-	// DDoS protection
./pkg/webhook/security.go-	MaxPayloadSize int64         `yaml:"max_payload_size" json:"max_payload_size"`
./pkg/webhook/security.go-	MaxHeaderSize  int           `yaml:"max_header_size" json:"max_header_size"`
./pkg/webhook/security.go-	IPWhitelist    []string      `yaml:"ip_whitelist" json:"ip_whitelist"`
./pkg/webhook/security.go-	IPBlacklist    []string      `yaml:"ip_blacklist" json:"ip_blacklist"`
./pkg/webhook/security.go-	BlockDuration  time.Duration `yaml:"block_duration" json:"block_duration"`
./pkg/webhook/security.go-
./pkg/webhook/security.go-	// Audit logging
./pkg/webhook/security.go-	EnableAuditLogging bool     `yaml:"enable_audit_logging" json:"enable_audit_logging"`
./pkg/webhook/security.go-	AuditLogFields     []string `yaml:"audit_log_fields" json:"audit_log_fields"`
./pkg/webhook/security.go-	SensitiveFields    []string `yaml:"sensitive_fields" json:"sensitive_fields"` // Fields to redact
./pkg/webhook/security.go-
./pkg/webhook/security.go-	// Encryption
./pkg/webhook/security.go-	EnableEncryption bool   `yaml:"enable_encryption" json:"enable_encryption"`
./pkg/webhook/security.go-	EncryptionKey    []byte `yaml:"-" json:"-"` // 32 bytes for AES-256
./pkg/webhook/security.go-}
./pkg/webhook/security.go-
./pkg/webhook/security.go-// DefaultSecurityConfig returns default security configuration
./pkg/webhook/security.go-func DefaultSecurityConfig() *SecurityConfig {
./pkg/webhook/security.go-	return &SecurityConfig{
./pkg/webhook/security.go-		EnableSignatureVerification: true,
./pkg/webhook/security.go-		SignatureHeader:             "X-Webhook-Signature",
./pkg/webhook/security.go-		TimestampTolerance:          5 * time.Minute,
./pkg/webhook/security.go-		EnableRateLimiting:          true,
./pkg/webhook/security.go-		GlobalRateLimit:             1000, // 1000 RPS globally
./pkg/webhook/security.go-		BurstSize:                   100,
./pkg/webhook/security.go-		MaxPayloadSize:              10 * 1024 * 1024, // 10MB
./pkg/webhook/security.go-		MaxHeaderSize:               8192,
./pkg/webhook/security.go-		BlockDuration:               1 * time.Hour,
./pkg/webhook/security.go-		EnableAuditLogging:          true,
./pkg/webhook/security.go-		AuditLogFields: []string{
./pkg/webhook/security.go-			"event_id", "tenant_id", "tool_id", "event_type", "timestamp",
./pkg/webhook/security.go-		},
./pkg/webhook/security.go-		SensitiveFields: []string{
./pkg/webhook/security.go-			"password", "token", "secret", "key", "authorization",
./pkg/webhook/security.go-		},
./pkg/webhook/security.go-		EnableEncryption: false, // Requires explicit key configuration
--
./pkg/webhook/summarization.go:type SummarizationConfig struct {
./pkg/webhook/summarization.go-	Provider       string                 // "openai", "anthropic", "local"
./pkg/webhook/summarization.go-	Model          string                 // Model name
./pkg/webhook/summarization.go-	MaxInputLength int                    // Maximum input length
./pkg/webhook/summarization.go-	DefaultOptions SummarizationOptions   // Default options
./pkg/webhook/summarization.go-	ProviderConfig map[string]interface{} // Provider-specific config
./pkg/webhook/summarization.go-	CacheDuration  time.Duration          // Cache duration for summaries
./pkg/webhook/summarization.go-}
./pkg/webhook/summarization.go-
./pkg/webhook/summarization.go-// DefaultSummarizationConfig returns default configuration
./pkg/webhook/summarization.go-func DefaultSummarizationConfig() *SummarizationConfig {
./pkg/webhook/summarization.go-	return &SummarizationConfig{
./pkg/webhook/summarization.go-		Provider:       "local",
./pkg/webhook/summarization.go-		Model:          "extractive",
./pkg/webhook/summarization.go-		MaxInputLength: 4096,
./pkg/webhook/summarization.go-		DefaultOptions: SummarizationOptions{
./pkg/webhook/summarization.go-			MaxLength:        150,
./pkg/webhook/summarization.go-			MinLength:        50,
./pkg/webhook/summarization.go-			Style:            "paragraph",
./pkg/webhook/summarization.go-			PreserveEntities: true,
./pkg/webhook/summarization.go-			Language:         "en",
./pkg/webhook/summarization.go-		},
./pkg/webhook/summarization.go-		CacheDuration: 24 * time.Hour,
./pkg/webhook/summarization.go-	}
./pkg/webhook/summarization.go-}
./pkg/webhook/summarization.go-
./pkg/webhook/summarization.go-// SummarizationService provides AI-powered summarization
./pkg/webhook/summarization.go-type SummarizationService struct {
./pkg/webhook/summarization.go-	config   *SummarizationConfig
./pkg/webhook/summarization.go-	provider SummarizationProvider
./pkg/webhook/summarization.go-	cache    SummarizationCache
./pkg/webhook/summarization.go-	logger   observability.Logger
./pkg/webhook/summarization.go-
./pkg/webhook/summarization.go-	// Metrics
./pkg/webhook/summarization.go-	metrics SummarizationMetrics
./pkg/webhook/summarization.go-}
./pkg/webhook/summarization.go-
./pkg/webhook/summarization.go-// SummarizationMetrics tracks summarization statistics
./pkg/webhook/summarization.go-type SummarizationMetrics struct {
./pkg/webhook/summarization.go-	mu                   sync.RWMutex
./pkg/webhook/summarization.go-	TotalSummarized      int64
./pkg/webhook/summarization.go-	TotalTokensProcessed int64
./pkg/webhook/summarization.go-	TotalCacheHits       int64
./pkg/webhook/summarization.go-	TotalCacheMisses     int64
./pkg/webhook/summarization.go-	AverageSummaryTime   time.Duration
./pkg/webhook/summarization.go-	TotalErrors          int64
./pkg/webhook/summarization.go-}
./pkg/webhook/summarization.go-
./pkg/webhook/summarization.go-// SummarizationCache defines the interface for summary cache
./pkg/webhook/summarization.go-type SummarizationCache interface {
./pkg/webhook/summarization.go-	Get(ctx context.Context, key string) (string, error)
--
./pkg/webhook/prewarming.go:type PrewarmingConfig struct {
./pkg/webhook/prewarming.go-	// Prediction settings
./pkg/webhook/prewarming.go-	MaxPredictions      int           // Maximum contexts to pre-warm
./pkg/webhook/prewarming.go-	ConfidenceThreshold float64       // Minimum confidence for pre-warming
./pkg/webhook/prewarming.go-	LookbackWindow      time.Duration // Time window for pattern analysis
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-	// Resource limits
./pkg/webhook/prewarming.go-	MaxMemoryUsage     int64         // Maximum memory for pre-warmed contexts
./pkg/webhook/prewarming.go-	MaxConcurrentWarms int           // Maximum concurrent pre-warming operations
./pkg/webhook/prewarming.go-	WarmingTimeout     time.Duration // Timeout for warming operations
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-	// Model settings
./pkg/webhook/prewarming.go-	ModelUpdateInterval time.Duration // How often to update prediction models
./pkg/webhook/prewarming.go-	MinDataPoints       int           // Minimum data points for predictions
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-	// Strategies
./pkg/webhook/prewarming.go-	EnabledStrategies []string // "sequential", "similarity", "temporal", "collaborative"
./pkg/webhook/prewarming.go-}
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-// DefaultPrewarmingConfig returns default configuration
./pkg/webhook/prewarming.go-func DefaultPrewarmingConfig() *PrewarmingConfig {
./pkg/webhook/prewarming.go-	return &PrewarmingConfig{
./pkg/webhook/prewarming.go-		MaxPredictions:      10,
./pkg/webhook/prewarming.go-		ConfidenceThreshold: 0.7,
./pkg/webhook/prewarming.go-		LookbackWindow:      24 * time.Hour,
./pkg/webhook/prewarming.go-		MaxMemoryUsage:      100 * 1024 * 1024, // 100MB
./pkg/webhook/prewarming.go-		MaxConcurrentWarms:  5,
./pkg/webhook/prewarming.go-		WarmingTimeout:      5 * time.Second,
./pkg/webhook/prewarming.go-		ModelUpdateInterval: 1 * time.Hour,
./pkg/webhook/prewarming.go-		MinDataPoints:       10,
./pkg/webhook/prewarming.go-		EnabledStrategies:   []string{"sequential", "similarity", "temporal"},
./pkg/webhook/prewarming.go-	}
./pkg/webhook/prewarming.go-}
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-// PrewarmingEngine predicts and pre-warms contexts
./pkg/webhook/prewarming.go-type PrewarmingEngine struct {
./pkg/webhook/prewarming.go-	config      *PrewarmingConfig
./pkg/webhook/prewarming.go-	lifecycle   *ContextLifecycleManager
./pkg/webhook/prewarming.go-	relevance   *RelevanceService
./pkg/webhook/prewarming.go-	redisClient *redis.StreamsClient
./pkg/webhook/prewarming.go-	logger      observability.Logger
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-	// Strategies
./pkg/webhook/prewarming.go-	strategies map[string]PrewarmingStrategy
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-	// Access pattern tracking
./pkg/webhook/prewarming.go-	accessLog *AccessLog
./pkg/webhook/prewarming.go-
./pkg/webhook/prewarming.go-	// Resource tracking
./pkg/webhook/prewarming.go-	memoryUsage  int64
./pkg/webhook/prewarming.go-	warmingQueue chan *WarmingTask
--
./pkg/webhook/consumer.go:type ConsumerConfig struct {
./pkg/webhook/consumer.go-	// Consumer group settings
./pkg/webhook/consumer.go-	ConsumerGroup string
./pkg/webhook/consumer.go-	ConsumerID    string
./pkg/webhook/consumer.go-	StreamKey     string
./pkg/webhook/consumer.go-
./pkg/webhook/consumer.go-	// Processing settings
./pkg/webhook/consumer.go-	BatchSize        int64
./pkg/webhook/consumer.go-	ClaimMinIdleTime time.Duration
./pkg/webhook/consumer.go-	MaxRetries       int
./pkg/webhook/consumer.go-	BlockTimeout     time.Duration
./pkg/webhook/consumer.go-
./pkg/webhook/consumer.go-	// Worker settings
./pkg/webhook/consumer.go-	NumWorkers     int
./pkg/webhook/consumer.go-	ProcessTimeout time.Duration
./pkg/webhook/consumer.go-
./pkg/webhook/consumer.go-	// Dead letter settings
./pkg/webhook/consumer.go-	DeadLetterStream string
./pkg/webhook/consumer.go-	MaxDeadLetterAge time.Duration
./pkg/webhook/consumer.go-}
./pkg/webhook/consumer.go-
./pkg/webhook/consumer.go-// DefaultConsumerConfig returns default consumer configuration
./pkg/webhook/consumer.go-func DefaultConsumerConfig() *ConsumerConfig {
./pkg/webhook/consumer.go-	return &ConsumerConfig{
./pkg/webhook/consumer.go-		ConsumerGroup:    "webhook-consumers",
./pkg/webhook/consumer.go-		StreamKey:        "webhook:events",
./pkg/webhook/consumer.go-		BatchSize:        10,
./pkg/webhook/consumer.go-		ClaimMinIdleTime: 30 * time.Second,
./pkg/webhook/consumer.go-		MaxRetries:       3,
./pkg/webhook/consumer.go-		BlockTimeout:     5 * time.Second,
./pkg/webhook/consumer.go-		NumWorkers:       5,
./pkg/webhook/consumer.go-		ProcessTimeout:   30 * time.Second,
./pkg/webhook/consumer.go-		DeadLetterStream: "webhook:events:dlq",
./pkg/webhook/consumer.go-		MaxDeadLetterAge: 7 * 24 * time.Hour,
./pkg/webhook/consumer.go-	}
./pkg/webhook/consumer.go-}
./pkg/webhook/consumer.go-
./pkg/webhook/consumer.go-// WebhookConsumer consumes webhook events from Redis Streams
./pkg/webhook/consumer.go-type WebhookConsumer struct {
./pkg/webhook/consumer.go-	config         *ConsumerConfig
./pkg/webhook/consumer.go-	redisClient    *redis.StreamsClient
./pkg/webhook/consumer.go-	deduplicator   *Deduplicator
./pkg/webhook/consumer.go-	schemaRegistry *SchemaRegistry
./pkg/webhook/consumer.go-	lifecycle      *ContextLifecycleManager
./pkg/webhook/consumer.go-	logger         observability.Logger
./pkg/webhook/consumer.go-
./pkg/webhook/consumer.go-	// Event processor
./pkg/webhook/consumer.go-	processor EventProcessor
./pkg/webhook/consumer.go-
./pkg/webhook/consumer.go-	// Worker management
./pkg/webhook/consumer.go-	workers  sync.WaitGroup
--
./pkg/webhook/context_lifecycle.go:type LifecycleConfig struct {
./pkg/webhook/context_lifecycle.go-	HotDuration  time.Duration // Time in hot storage (default: 2 hours)
./pkg/webhook/context_lifecycle.go-	WarmDuration time.Duration // Time in warm storage (default: 22 hours)
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-	// Importance thresholds for lifecycle transitions
./pkg/webhook/context_lifecycle.go-	HotImportanceThreshold  float64 // Keep in hot if importance > threshold
./pkg/webhook/context_lifecycle.go-	WarmImportanceThreshold float64 // Keep in warm if importance > threshold
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-	// Access count thresholds
./pkg/webhook/context_lifecycle.go-	HotAccessThreshold  int // Keep in hot if accessed more than N times
./pkg/webhook/context_lifecycle.go-	WarmAccessThreshold int // Keep in warm if accessed more than N times
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-	// Storage settings
./pkg/webhook/context_lifecycle.go-	EnableCompression bool
./pkg/webhook/context_lifecycle.go-	CompressionLevel  int // 1-9, higher = better compression
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-	// Transition settings
./pkg/webhook/context_lifecycle.go-	TransitionBatchSize int
./pkg/webhook/context_lifecycle.go-	TransitionInterval  time.Duration
./pkg/webhook/context_lifecycle.go-}
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-// DefaultLifecycleConfig returns default lifecycle configuration
./pkg/webhook/context_lifecycle.go-func DefaultLifecycleConfig() *LifecycleConfig {
./pkg/webhook/context_lifecycle.go-	return &LifecycleConfig{
./pkg/webhook/context_lifecycle.go-		HotDuration:             2 * time.Hour,
./pkg/webhook/context_lifecycle.go-		WarmDuration:            22 * time.Hour,
./pkg/webhook/context_lifecycle.go-		HotImportanceThreshold:  0.8,
./pkg/webhook/context_lifecycle.go-		WarmImportanceThreshold: 0.5,
./pkg/webhook/context_lifecycle.go-		HotAccessThreshold:      5,
./pkg/webhook/context_lifecycle.go-		WarmAccessThreshold:     2,
./pkg/webhook/context_lifecycle.go-		EnableCompression:       true,
./pkg/webhook/context_lifecycle.go-		CompressionLevel:        6,
./pkg/webhook/context_lifecycle.go-		TransitionBatchSize:     100,
./pkg/webhook/context_lifecycle.go-		TransitionInterval:      5 * time.Minute,
./pkg/webhook/context_lifecycle.go-	}
./pkg/webhook/context_lifecycle.go-}
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-// ContextLifecycleManager manages the lifecycle of contexts
./pkg/webhook/context_lifecycle.go-type ContextLifecycleManager struct {
./pkg/webhook/context_lifecycle.go-	config         *LifecycleConfig
./pkg/webhook/context_lifecycle.go-	redisClient    *redis.StreamsClient
./pkg/webhook/context_lifecycle.go-	storageBackend StorageBackend
./pkg/webhook/context_lifecycle.go-	compression    CompressionService
./pkg/webhook/context_lifecycle.go-	logger         observability.Logger
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-	// Lifecycle workers
./pkg/webhook/context_lifecycle.go-	transitionStop chan struct{}
./pkg/webhook/context_lifecycle.go-	wg             sync.WaitGroup
./pkg/webhook/context_lifecycle.go-
./pkg/webhook/context_lifecycle.go-	// Circuit breaker for cold storage
./pkg/webhook/context_lifecycle.go-	coldStorageBreaker *redis.CircuitBreaker
--
./pkg/webhook/relevance.go:type RelevanceConfig struct {
./pkg/webhook/relevance.go-	// Scoring weights
./pkg/webhook/relevance.go-	TextSimilarityWeight  float64
./pkg/webhook/relevance.go-	RecencyWeight         float64
./pkg/webhook/relevance.go-	AccessFrequencyWeight float64
./pkg/webhook/relevance.go-	ImportanceWeight      float64
./pkg/webhook/relevance.go-	SemanticWeight        float64
./pkg/webhook/relevance.go-
./pkg/webhook/relevance.go-	// Decay parameters
./pkg/webhook/relevance.go-	RecencyDecayHalfLife   time.Duration
./pkg/webhook/relevance.go-	FrequencyDecayHalfLife time.Duration
./pkg/webhook/relevance.go-
./pkg/webhook/relevance.go-	// Semantic scoring
./pkg/webhook/relevance.go-	UseEmbeddings      bool
./pkg/webhook/relevance.go-	EmbeddingThreshold float64
./pkg/webhook/relevance.go-
./pkg/webhook/relevance.go-	// Feature extraction
./pkg/webhook/relevance.go-	MaxKeywords      int
./pkg/webhook/relevance.go-	MinKeywordLength int
./pkg/webhook/relevance.go-}
./pkg/webhook/relevance.go-
./pkg/webhook/relevance.go-// DefaultRelevanceConfig returns default configuration
./pkg/webhook/relevance.go-func DefaultRelevanceConfig() *RelevanceConfig {
./pkg/webhook/relevance.go-	return &RelevanceConfig{
./pkg/webhook/relevance.go-		TextSimilarityWeight:   0.3,
./pkg/webhook/relevance.go-		RecencyWeight:          0.2,
./pkg/webhook/relevance.go-		AccessFrequencyWeight:  0.2,
./pkg/webhook/relevance.go-		ImportanceWeight:       0.2,
./pkg/webhook/relevance.go-		SemanticWeight:         0.1,
./pkg/webhook/relevance.go-		RecencyDecayHalfLife:   24 * time.Hour,
./pkg/webhook/relevance.go-		FrequencyDecayHalfLife: 7 * 24 * time.Hour,
./pkg/webhook/relevance.go-		UseEmbeddings:          true,
./pkg/webhook/relevance.go-		EmbeddingThreshold:     0.7,
./pkg/webhook/relevance.go-		MaxKeywords:            20,
./pkg/webhook/relevance.go-		MinKeywordLength:       3,
./pkg/webhook/relevance.go-	}
./pkg/webhook/relevance.go-}
./pkg/webhook/relevance.go-
./pkg/webhook/relevance.go-// RelevanceService provides context relevance scoring
./pkg/webhook/relevance.go-type RelevanceService struct {
./pkg/webhook/relevance.go-	config     *RelevanceConfig
./pkg/webhook/relevance.go-	embedding  *EmbeddingService
./pkg/webhook/relevance.go-	summarizer *SummarizationService
./pkg/webhook/relevance.go-	logger     observability.Logger
./pkg/webhook/relevance.go-
./pkg/webhook/relevance.go-	// Feature cache
./pkg/webhook/relevance.go-	featureCache sync.Map // map[contextID]*ContextFeatures
./pkg/webhook/relevance.go-
./pkg/webhook/relevance.go-	// Metrics
./pkg/webhook/relevance.go-	metrics RelevanceMetrics
./pkg/webhook/relevance.go-}
--
./pkg/webhook/storage_backend.go:type S3Config struct {
./pkg/webhook/storage_backend.go-	Bucket       string
./pkg/webhook/storage_backend.go-	Region       string
./pkg/webhook/storage_backend.go-	Endpoint     string // For S3-compatible services
./pkg/webhook/storage_backend.go-	UsePathStyle bool   // For MinIO and other S3-compatible services
./pkg/webhook/storage_backend.go-}
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-// S3StorageBackend implements cold storage using S3
./pkg/webhook/storage_backend.go-type S3StorageBackend struct {
./pkg/webhook/storage_backend.go-	config *S3Config
./pkg/webhook/storage_backend.go-	client *s3.S3
./pkg/webhook/storage_backend.go-	logger observability.Logger
./pkg/webhook/storage_backend.go-}
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-// NewS3StorageBackend creates a new S3 storage backend
./pkg/webhook/storage_backend.go-func NewS3StorageBackend(config *S3Config, logger observability.Logger) (*S3StorageBackend, error) {
./pkg/webhook/storage_backend.go-	awsConfig := &aws.Config{
./pkg/webhook/storage_backend.go-		Region: aws.String(config.Region),
./pkg/webhook/storage_backend.go-	}
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-	if config.Endpoint != "" {
./pkg/webhook/storage_backend.go-		awsConfig.Endpoint = aws.String(config.Endpoint)
./pkg/webhook/storage_backend.go-		awsConfig.S3ForcePathStyle = aws.Bool(config.UsePathStyle)
./pkg/webhook/storage_backend.go-	}
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-	sess, err := session.NewSession(awsConfig)
./pkg/webhook/storage_backend.go-	if err != nil {
./pkg/webhook/storage_backend.go-		return nil, fmt.Errorf("failed to create AWS session: %w", err)
./pkg/webhook/storage_backend.go-	}
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-	return &S3StorageBackend{
./pkg/webhook/storage_backend.go-		config: config,
./pkg/webhook/storage_backend.go-		client: s3.New(sess),
./pkg/webhook/storage_backend.go-		logger: logger,
./pkg/webhook/storage_backend.go-	}, nil
./pkg/webhook/storage_backend.go-}
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-// Store stores data in S3
./pkg/webhook/storage_backend.go-func (s *S3StorageBackend) Store(ctx context.Context, key string, data []byte) error {
./pkg/webhook/storage_backend.go-	input := &s3.PutObjectInput{
./pkg/webhook/storage_backend.go-		Bucket: aws.String(s.config.Bucket),
./pkg/webhook/storage_backend.go-		Key:    aws.String(key),
./pkg/webhook/storage_backend.go-		Body:   bytes.NewReader(data),
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-		// Add metadata
./pkg/webhook/storage_backend.go-		Metadata: map[string]*string{
./pkg/webhook/storage_backend.go-			"stored-by": aws.String("webhook-pipeline"),
./pkg/webhook/storage_backend.go-			"timestamp": aws.String(fmt.Sprintf("%d", time.Now().Unix())),
./pkg/webhook/storage_backend.go-		},
./pkg/webhook/storage_backend.go-
./pkg/webhook/storage_backend.go-		// Use intelligent tiering for cost optimization
--
./pkg/metrics/client.go:type Config struct {
./pkg/metrics/client.go-	Enabled      bool          `mapstructure:"enabled"`
./pkg/metrics/client.go-	Type         string        `mapstructure:"type"`
./pkg/metrics/client.go-	Endpoint     string        `mapstructure:"endpoint"`
./pkg/metrics/client.go-	PushGateway  string        `mapstructure:"push_gateway"`
./pkg/metrics/client.go-	PushInterval time.Duration `mapstructure:"push_interval"`
./pkg/metrics/client.go-}
./pkg/metrics/client.go-
./pkg/metrics/client.go-// Client is the interface for metrics collection
./pkg/metrics/client.go-type Client interface {
./pkg/metrics/client.go-	// RecordEvent records an event metric
./pkg/metrics/client.go-	RecordEvent(source, eventType string)
./pkg/metrics/client.go-
./pkg/metrics/client.go-	// RecordLatency records a latency metric
./pkg/metrics/client.go-	RecordLatency(operation string, duration time.Duration)
./pkg/metrics/client.go-
./pkg/metrics/client.go-	// RecordCounter increments a counter metric
./pkg/metrics/client.go-	RecordCounter(name string, value float64, labels map[string]string)
./pkg/metrics/client.go-
./pkg/metrics/client.go-	// RecordGauge sets a gauge metric
./pkg/metrics/client.go-	RecordGauge(name string, value float64, labels map[string]string)
./pkg/metrics/client.go-
./pkg/metrics/client.go-	// Close closes the metrics client
./pkg/metrics/client.go-	Close() error
./pkg/metrics/client.go-}
./pkg/metrics/client.go-
./pkg/metrics/client.go-// PrometheusClient implements the metrics client using Prometheus
./pkg/metrics/client.go-type PrometheusClient struct {
./pkg/metrics/client.go-	config  Config
./pkg/metrics/client.go-	metrics map[string]any
./pkg/metrics/client.go-	mu      sync.RWMutex
./pkg/metrics/client.go-}
./pkg/metrics/client.go-
./pkg/metrics/client.go-// NewClient creates a new metrics client
./pkg/metrics/client.go-func NewClient(cfg Config) Client {
./pkg/metrics/client.go-	if !cfg.Enabled {
./pkg/metrics/client.go-		return &NoopClient{}
./pkg/metrics/client.go-	}
./pkg/metrics/client.go-
./pkg/metrics/client.go-	switch cfg.Type {
./pkg/metrics/client.go-	case "prometheus":
./pkg/metrics/client.go-		return NewPrometheusClient(cfg)
./pkg/metrics/client.go-	default:
./pkg/metrics/client.go-		// Default to noop client
./pkg/metrics/client.go-		return &NoopClient{}
./pkg/metrics/client.go-	}
./pkg/metrics/client.go-}
./pkg/metrics/client.go-
./pkg/metrics/client.go-// NewPrometheusClient creates a new Prometheus metrics client
./pkg/metrics/client.go-func NewPrometheusClient(cfg Config) *PrometheusClient {
./pkg/metrics/client.go-	client := &PrometheusClient{
--
./pkg/clients/cache_manager.go:type CacheConfig struct {
./pkg/clients/cache_manager.go-	// L1 Cache (in-memory)
./pkg/clients/cache_manager.go-	L1MaxSize int           `json:"l1_max_size"`
./pkg/clients/cache_manager.go-	L1TTL     time.Duration `json:"l1_ttl"`
./pkg/clients/cache_manager.go-
./pkg/clients/cache_manager.go-	// L2 Cache (Redis)
./pkg/clients/cache_manager.go-	L2Enabled bool          `json:"l2_enabled"`
./pkg/clients/cache_manager.go-	L2TTL     time.Duration `json:"l2_ttl"`
./pkg/clients/cache_manager.go-
./pkg/clients/cache_manager.go-	// Cache warming
./pkg/clients/cache_manager.go-	WarmupEnabled  bool          `json:"warmup_enabled"`
./pkg/clients/cache_manager.go-	WarmupInterval time.Duration `json:"warmup_interval"`
./pkg/clients/cache_manager.go-	WarmupWorkers  int           `json:"warmup_workers"`
./pkg/clients/cache_manager.go-
./pkg/clients/cache_manager.go-	// Request coalescing
./pkg/clients/cache_manager.go-	CoalescingEnabled bool `json:"coalescing_enabled"`
./pkg/clients/cache_manager.go-
./pkg/clients/cache_manager.go-	// Compression
./pkg/clients/cache_manager.go-	CompressionEnabled bool `json:"compression_enabled"`
./pkg/clients/cache_manager.go-	CompressionLevel   int  `json:"compression_level"`
./pkg/clients/cache_manager.go-	CompressionMinSize int  `json:"compression_min_size"`
./pkg/clients/cache_manager.go-}
./pkg/clients/cache_manager.go-
./pkg/clients/cache_manager.go-// cacheEntry represents a cached item
./pkg/clients/cache_manager.go-type cacheEntry struct {
./pkg/clients/cache_manager.go-	Data         []byte
./pkg/clients/cache_manager.go-	Compressed   bool
./pkg/clients/cache_manager.go-	CachedAt     time.Time
./pkg/clients/cache_manager.go-	TTL          time.Duration
./pkg/clients/cache_manager.go-	AccessCount  int64
./pkg/clients/cache_manager.go-	LastAccessed time.Time
./pkg/clients/cache_manager.go-	Dependencies []string // Keys this entry depends on
./pkg/clients/cache_manager.go-}
./pkg/clients/cache_manager.go-
./pkg/clients/cache_manager.go-// warmupRequest represents a cache warmup request
./pkg/clients/cache_manager.go-type warmupRequest struct {
./pkg/clients/cache_manager.go-	Key      string
./pkg/clients/cache_manager.go-	TenantID string
./pkg/clients/cache_manager.go-	Priority int
./pkg/clients/cache_manager.go-	Callback func() (interface{}, error)
./pkg/clients/cache_manager.go-}
./pkg/clients/cache_manager.go-
./pkg/clients/cache_manager.go-// coalescedRequest represents a coalesced request
./pkg/clients/cache_manager.go-type coalescedRequest struct {
./pkg/clients/cache_manager.go-	key     string
./pkg/clients/cache_manager.go-	result  interface{}
./pkg/clients/cache_manager.go-	err     error
./pkg/clients/cache_manager.go-	done    chan struct{}
./pkg/clients/cache_manager.go-	waiters int
./pkg/clients/cache_manager.go-}
./pkg/clients/cache_manager.go-
--
./pkg/clients/observability_manager.go:type ObservabilityConfig struct {
./pkg/clients/observability_manager.go-	// Tracing configuration
./pkg/clients/observability_manager.go-	TracingEnabled      bool          `json:"tracing_enabled"`
./pkg/clients/observability_manager.go-	TracingEndpoint     string        `json:"tracing_endpoint"`
./pkg/clients/observability_manager.go-	TracingSampleRate   float64       `json:"tracing_sample_rate"`
./pkg/clients/observability_manager.go-	TracingBatchTimeout time.Duration `json:"tracing_batch_timeout"`
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Metrics configuration
./pkg/clients/observability_manager.go-	MetricsEnabled       bool          `json:"metrics_enabled"`
./pkg/clients/observability_manager.go-	MetricsEndpoint      string        `json:"metrics_endpoint"`
./pkg/clients/observability_manager.go-	MetricsInterval      time.Duration `json:"metrics_interval"`
./pkg/clients/observability_manager.go-	CustomMetricsEnabled bool          `json:"custom_metrics_enabled"`
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Logging configuration
./pkg/clients/observability_manager.go-	StructuredLogging bool   `json:"structured_logging"`
./pkg/clients/observability_manager.go-	LogLevel          string `json:"log_level"`
./pkg/clients/observability_manager.go-	LogBufferSize     int    `json:"log_buffer_size"`
./pkg/clients/observability_manager.go-	LogSampling       bool   `json:"log_sampling"`
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Health monitoring
./pkg/clients/observability_manager.go-	HealthCheckInterval time.Duration `json:"health_check_interval"`
./pkg/clients/observability_manager.go-	HealthCheckTimeout  time.Duration `json:"health_check_timeout"`
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// SLA configuration
./pkg/clients/observability_manager.go-	SLAEnabled        bool          `json:"sla_enabled"`
./pkg/clients/observability_manager.go-	SLAReportInterval time.Duration `json:"sla_report_interval"`
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Profiling configuration
./pkg/clients/observability_manager.go-	ProfilingEnabled  bool          `json:"profiling_enabled"`
./pkg/clients/observability_manager.go-	ProfilingInterval time.Duration `json:"profiling_interval"`
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Dashboard configuration
./pkg/clients/observability_manager.go-	DashboardEnabled bool `json:"dashboard_enabled"`
./pkg/clients/observability_manager.go-	DashboardPort    int  `json:"dashboard_port"`
./pkg/clients/observability_manager.go-}
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-// EnhancedMetricsCollector provides advanced metrics collection
./pkg/clients/observability_manager.go-type EnhancedMetricsCollector struct {
./pkg/clients/observability_manager.go-	mu sync.RWMutex
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Counters
./pkg/clients/observability_manager.go-	counters map[string]*atomic.Int64
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Gauges
./pkg/clients/observability_manager.go-	gauges map[string]*atomic.Value
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Histograms
./pkg/clients/observability_manager.go-	histograms map[string]*Histogram
./pkg/clients/observability_manager.go-
./pkg/clients/observability_manager.go-	// Summaries
./pkg/clients/observability_manager.go-	summaries map[string]*Summary
--
./pkg/clients/batch_processor.go:type BatchConfig struct {
./pkg/clients/batch_processor.go-	MaxBatchSize    int           `json:"max_batch_size"`
./pkg/clients/batch_processor.go-	MaxBatchWait    time.Duration `json:"max_batch_wait"`
./pkg/clients/batch_processor.go-	Workers         int           `json:"workers"`
./pkg/clients/batch_processor.go-	QueueSize       int           `json:"queue_size"`
./pkg/clients/batch_processor.go-	EnableAutoFlush bool          `json:"enable_auto_flush"`
./pkg/clients/batch_processor.go-	FlushInterval   time.Duration `json:"flush_interval"`
./pkg/clients/batch_processor.go-}
./pkg/clients/batch_processor.go-
./pkg/clients/batch_processor.go-// BatchRequest represents a single request in a batch
./pkg/clients/batch_processor.go-type BatchRequest struct {
./pkg/clients/batch_processor.go-	ID        string
./pkg/clients/batch_processor.go-	Operation string
./pkg/clients/batch_processor.go-	TenantID  string
./pkg/clients/batch_processor.go-	Data      interface{}
./pkg/clients/batch_processor.go-	Context   context.Context
./pkg/clients/batch_processor.go-	Result    chan BatchResult
./pkg/clients/batch_processor.go-}
./pkg/clients/batch_processor.go-
./pkg/clients/batch_processor.go-// BatchResult represents the result of a batch request
./pkg/clients/batch_processor.go-type BatchResult struct {
./pkg/clients/batch_processor.go-	ID    string
./pkg/clients/batch_processor.go-	Data  interface{}
./pkg/clients/batch_processor.go-	Error error
./pkg/clients/batch_processor.go-}
./pkg/clients/batch_processor.go-
./pkg/clients/batch_processor.go-// Batch represents a collection of requests to be processed together
./pkg/clients/batch_processor.go-type Batch struct {
./pkg/clients/batch_processor.go-	ID         string
./pkg/clients/batch_processor.go-	Requests   []*BatchRequest
./pkg/clients/batch_processor.go-	CreatedAt  time.Time
./pkg/clients/batch_processor.go-	Processing bool
./pkg/clients/batch_processor.go-}
./pkg/clients/batch_processor.go-
./pkg/clients/batch_processor.go-// BatchMetrics tracks batch processing metrics
./pkg/clients/batch_processor.go-type BatchMetrics struct {
./pkg/clients/batch_processor.go-	mu sync.RWMutex
./pkg/clients/batch_processor.go-
./pkg/clients/batch_processor.go-	TotalBatches      int64
./pkg/clients/batch_processor.go-	TotalRequests     int64
./pkg/clients/batch_processor.go-	SuccessfulBatches int64
./pkg/clients/batch_processor.go-	FailedBatches     int64
./pkg/clients/batch_processor.go-
./pkg/clients/batch_processor.go-	AvgBatchSize      float64
./pkg/clients/batch_processor.go-	AvgProcessingTime time.Duration
./pkg/clients/batch_processor.go-	MaxBatchSize      int
./pkg/clients/batch_processor.go-
./pkg/clients/batch_processor.go-	CurrentQueueSize int
./pkg/clients/batch_processor.go-	DroppedRequests  int64
./pkg/clients/batch_processor.go-}
./pkg/clients/batch_processor.go-
--
./pkg/clients/security_manager.go:type SecurityConfig struct {
./pkg/clients/security_manager.go-	// Token management
./pkg/clients/security_manager.go-	TokenRotationInterval time.Duration `json:"token_rotation_interval"`
./pkg/clients/security_manager.go-	TokenTTL              time.Duration `json:"token_ttl"`
./pkg/clients/security_manager.go-	MaxTokensPerUser      int           `json:"max_tokens_per_user"`
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Encryption
./pkg/clients/security_manager.go-	EncryptionEnabled   bool          `json:"encryption_enabled"`
./pkg/clients/security_manager.go-	EncryptionAlgorithm string        `json:"encryption_algorithm"`
./pkg/clients/security_manager.go-	KeyRotationInterval time.Duration `json:"key_rotation_interval"`
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Rate limiting
./pkg/clients/security_manager.go-	RateLimitEnabled  bool `json:"rate_limit_enabled"`
./pkg/clients/security_manager.go-	RequestsPerMinute int  `json:"requests_per_minute"`
./pkg/clients/security_manager.go-	BurstSize         int  `json:"burst_size"`
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Security headers
./pkg/clients/security_manager.go-	EnableSecurityHeaders bool   `json:"enable_security_headers"`
./pkg/clients/security_manager.go-	CSPPolicy             string `json:"csp_policy"`
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Audit logging
./pkg/clients/security_manager.go-	AuditEnabled   bool          `json:"audit_enabled"`
./pkg/clients/security_manager.go-	AuditRetention time.Duration `json:"audit_retention"`
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Threat detection
./pkg/clients/security_manager.go-	ThreatDetectionEnabled bool    `json:"threat_detection_enabled"`
./pkg/clients/security_manager.go-	AnomalyThreshold       float64 `json:"anomaly_threshold"`
./pkg/clients/security_manager.go-}
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-// TokenManager handles token lifecycle management
./pkg/clients/security_manager.go-type TokenManager struct {
./pkg/clients/security_manager.go-	mu sync.RWMutex
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Token storage
./pkg/clients/security_manager.go-	tokens     map[string]*Token
./pkg/clients/security_manager.go-	userTokens map[string][]string // user ID -> token IDs
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Configuration
./pkg/clients/security_manager.go-	rotationInterval time.Duration
./pkg/clients/security_manager.go-	tokenTTL         time.Duration
./pkg/clients/security_manager.go-	maxTokensPerUser int
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-	// Rotation tracking
./pkg/clients/security_manager.go-	lastRotation    time.Time
./pkg/clients/security_manager.go-	rotationHistory []TokenRotation
./pkg/clients/security_manager.go-}
./pkg/clients/security_manager.go-
./pkg/clients/security_manager.go-// Token represents an API token
./pkg/clients/security_manager.go-type Token struct {
./pkg/clients/security_manager.go-	ID          string
./pkg/clients/security_manager.go-	UserID      string
--
./pkg/clients/performance_monitor.go:type MonitorConfig struct {
./pkg/clients/performance_monitor.go-	CollectionInterval    time.Duration `json:"collection_interval"`
./pkg/clients/performance_monitor.go-	HistoryRetention      time.Duration `json:"history_retention"`
./pkg/clients/performance_monitor.go-	EnableAlerting        bool          `json:"enable_alerting"`
./pkg/clients/performance_monitor.go-	EnableAutoTuning      bool          `json:"enable_auto_tuning"`
./pkg/clients/performance_monitor.go-	MetricsBufferSize     int           `json:"metrics_buffer_size"`
./pkg/clients/performance_monitor.go-	PercentileCalculation bool          `json:"percentile_calculation"`
./pkg/clients/performance_monitor.go-}
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-// MetricsCollector collects performance metrics
./pkg/clients/performance_monitor.go-type MetricsCollector struct {
./pkg/clients/performance_monitor.go-	mu sync.RWMutex
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// Request metrics
./pkg/clients/performance_monitor.go-	requestMetrics *RequestMetrics
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// Cache metrics
./pkg/clients/performance_monitor.go-	cacheMetrics *CachePerformanceMetrics
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// System metrics
./pkg/clients/performance_monitor.go-	systemMetrics *SystemMetrics
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// Custom metrics
./pkg/clients/performance_monitor.go-	customMetrics map[string]*CustomMetric
./pkg/clients/performance_monitor.go-}
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-// RequestMetrics tracks request performance
./pkg/clients/performance_monitor.go-type RequestMetrics struct {
./pkg/clients/performance_monitor.go-	mu sync.RWMutex
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// Timing metrics
./pkg/clients/performance_monitor.go-	responseTimes []time.Duration
./pkg/clients/performance_monitor.go-	maxBufferSize int
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// Throughput metrics
./pkg/clients/performance_monitor.go-	requestCount     int64
./pkg/clients/performance_monitor.go-	bytesTransferred int64
./pkg/clients/performance_monitor.go-	startTime        time.Time
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// Error metrics
./pkg/clients/performance_monitor.go-	errorCount   int64
./pkg/clients/performance_monitor.go-	errorsByType map[string]int64
./pkg/clients/performance_monitor.go-
./pkg/clients/performance_monitor.go-	// Latency breakdown
./pkg/clients/performance_monitor.go-	dnsLatency      []time.Duration
./pkg/clients/performance_monitor.go-	connectLatency  []time.Duration
./pkg/clients/performance_monitor.go-	tlsLatency      []time.Duration
./pkg/clients/performance_monitor.go-	serverLatency   []time.Duration
./pkg/clients/performance_monitor.go-	transferLatency []time.Duration
./pkg/clients/performance_monitor.go-}
./pkg/clients/performance_monitor.go-
--
./pkg/clients/context_utils.go:type TimeoutConfig struct {
./pkg/clients/context_utils.go-	// Default timeout for general operations
./pkg/clients/context_utils.go-	Default time.Duration
./pkg/clients/context_utils.go-	// HealthCheck timeout for health check operations
./pkg/clients/context_utils.go-	HealthCheck time.Duration
./pkg/clients/context_utils.go-	// ListTools timeout for listing tools
./pkg/clients/context_utils.go-	ListTools time.Duration
./pkg/clients/context_utils.go-	// ExecuteTool timeout for tool execution
./pkg/clients/context_utils.go-	ExecuteTool time.Duration
./pkg/clients/context_utils.go-	// LongRunning timeout for long-running operations
./pkg/clients/context_utils.go-	LongRunning time.Duration
./pkg/clients/context_utils.go-}
./pkg/clients/context_utils.go-
./pkg/clients/context_utils.go-// DefaultTimeoutConfig returns default timeout configuration
./pkg/clients/context_utils.go-func DefaultTimeoutConfig() TimeoutConfig {
./pkg/clients/context_utils.go-	return TimeoutConfig{
./pkg/clients/context_utils.go-		Default:     30 * time.Second,
./pkg/clients/context_utils.go-		HealthCheck: 5 * time.Second,
./pkg/clients/context_utils.go-		ListTools:   10 * time.Second,
./pkg/clients/context_utils.go-		ExecuteTool: 60 * time.Second,
./pkg/clients/context_utils.go-		LongRunning: 5 * time.Minute,
./pkg/clients/context_utils.go-	}
./pkg/clients/context_utils.go-}
./pkg/clients/context_utils.go-
./pkg/clients/context_utils.go-// WithCorrelationID adds a correlation ID to the context
./pkg/clients/context_utils.go-func WithCorrelationID(ctx context.Context, correlationID string) context.Context {
./pkg/clients/context_utils.go-	if correlationID == "" {
./pkg/clients/context_utils.go-		correlationID = uuid.New().String()
./pkg/clients/context_utils.go-	}
./pkg/clients/context_utils.go-	return context.WithValue(ctx, ContextKeyCorrelationID, correlationID)
./pkg/clients/context_utils.go-}
./pkg/clients/context_utils.go-
./pkg/clients/context_utils.go-// GetCorrelationID retrieves the correlation ID from context
./pkg/clients/context_utils.go-func GetCorrelationID(ctx context.Context) string {
./pkg/clients/context_utils.go-	if val := ctx.Value(ContextKeyCorrelationID); val != nil {
./pkg/clients/context_utils.go-		if id, ok := val.(string); ok {
./pkg/clients/context_utils.go-			return id
./pkg/clients/context_utils.go-		}
./pkg/clients/context_utils.go-	}
./pkg/clients/context_utils.go-	return uuid.New().String()
./pkg/clients/context_utils.go-}
./pkg/clients/context_utils.go-
./pkg/clients/context_utils.go-// WithOperation adds an operation name to the context
./pkg/clients/context_utils.go-func WithOperation(ctx context.Context, operation string) context.Context {
./pkg/clients/context_utils.go-	return context.WithValue(ctx, ContextKeyOperation, operation)
./pkg/clients/context_utils.go-}
./pkg/clients/context_utils.go-
./pkg/clients/context_utils.go-// GetOperation retrieves the operation name from context
./pkg/clients/context_utils.go-func GetOperation(ctx context.Context) string {
./pkg/clients/context_utils.go-	if val := ctx.Value(ContextKeyOperation); val != nil {
./pkg/clients/context_utils.go-		if op, ok := val.(string); ok {
--
./pkg/clients/rest_api_client.go:type RESTClientConfig struct {
./pkg/clients/rest_api_client.go-	BaseURL         string
./pkg/clients/rest_api_client.go-	APIKey          string
./pkg/clients/rest_api_client.go-	Timeout         time.Duration
./pkg/clients/rest_api_client.go-	MaxIdleConns    int
./pkg/clients/rest_api_client.go-	MaxConnsPerHost int
./pkg/clients/rest_api_client.go-	CacheTTL        time.Duration
./pkg/clients/rest_api_client.go-	Logger          observability.Logger
./pkg/clients/rest_api_client.go-	MetricsClient   observability.MetricsClient
./pkg/clients/rest_api_client.go-
./pkg/clients/rest_api_client.go-	// Circuit breaker configuration
./pkg/clients/rest_api_client.go-	CircuitBreakerMaxFailures  int
./pkg/clients/rest_api_client.go-	CircuitBreakerTimeout      time.Duration
./pkg/clients/rest_api_client.go-	CircuitBreakerRetryTimeout time.Duration
./pkg/clients/rest_api_client.go-
./pkg/clients/rest_api_client.go-	// Health check configuration
./pkg/clients/rest_api_client.go-	HealthCheckInterval time.Duration
./pkg/clients/rest_api_client.go-	HealthCheckTimeout  time.Duration
./pkg/clients/rest_api_client.go-
./pkg/clients/rest_api_client.go-	// Observability configuration
./pkg/clients/rest_api_client.go-	ObservabilityConfig ObservabilityConfig
./pkg/clients/rest_api_client.go-}
./pkg/clients/rest_api_client.go-
./pkg/clients/rest_api_client.go-// NewRESTAPIClient creates a new REST API client with configuration
./pkg/clients/rest_api_client.go-func NewRESTAPIClient(config RESTClientConfig) RESTAPIClient {
./pkg/clients/rest_api_client.go-	// Set defaults
./pkg/clients/rest_api_client.go-	if config.Timeout == 0 {
./pkg/clients/rest_api_client.go-		config.Timeout = 30 * time.Second
./pkg/clients/rest_api_client.go-	}
./pkg/clients/rest_api_client.go-	if config.MaxIdleConns == 0 {
./pkg/clients/rest_api_client.go-		config.MaxIdleConns = 100
./pkg/clients/rest_api_client.go-	}
./pkg/clients/rest_api_client.go-	if config.MaxConnsPerHost == 0 {
./pkg/clients/rest_api_client.go-		config.MaxConnsPerHost = 10
./pkg/clients/rest_api_client.go-	}
./pkg/clients/rest_api_client.go-	if config.CacheTTL == 0 {
./pkg/clients/rest_api_client.go-		config.CacheTTL = 30 * time.Second
./pkg/clients/rest_api_client.go-	}
./pkg/clients/rest_api_client.go-
./pkg/clients/rest_api_client.go-	// Create HTTP client with connection pooling
./pkg/clients/rest_api_client.go-	transport := &http.Transport{
./pkg/clients/rest_api_client.go-		MaxIdleConns:        config.MaxIdleConns,
./pkg/clients/rest_api_client.go-		MaxIdleConnsPerHost: config.MaxConnsPerHost,
./pkg/clients/rest_api_client.go-		IdleConnTimeout:     90 * time.Second,
./pkg/clients/rest_api_client.go-	}
./pkg/clients/rest_api_client.go-
./pkg/clients/rest_api_client.go-	httpClient := &http.Client{
./pkg/clients/rest_api_client.go-		Transport: transport,
./pkg/clients/rest_api_client.go-		Timeout:   config.Timeout,
./pkg/clients/rest_api_client.go-	}
./pkg/clients/rest_api_client.go-
--
./pkg/clients/security_middleware.go:type SecurityMiddlewareConfig struct {
./pkg/clients/security_middleware.go-	// Security headers
./pkg/clients/security_middleware.go-	EnableSecurityHeaders bool
./pkg/clients/security_middleware.go-	CSPPolicy             string
./pkg/clients/security_middleware.go-	HSTSMaxAge            int
./pkg/clients/security_middleware.go-
./pkg/clients/security_middleware.go-	// CORS configuration
./pkg/clients/security_middleware.go-	EnableCORS       bool
./pkg/clients/security_middleware.go-	AllowedOrigins   []string
./pkg/clients/security_middleware.go-	AllowedMethods   []string
./pkg/clients/security_middleware.go-	AllowedHeaders   []string
./pkg/clients/security_middleware.go-	ExposedHeaders   []string
./pkg/clients/security_middleware.go-	AllowCredentials bool
./pkg/clients/security_middleware.go-	MaxAge           int
./pkg/clients/security_middleware.go-
./pkg/clients/security_middleware.go-	// Request validation
./pkg/clients/security_middleware.go-	ValidateInput  bool
./pkg/clients/security_middleware.go-	MaxRequestSize int64
./pkg/clients/security_middleware.go-	MaxHeaderSize  int
./pkg/clients/security_middleware.go-
./pkg/clients/security_middleware.go-	// Authentication
./pkg/clients/security_middleware.go-	RequireAuth bool
./pkg/clients/security_middleware.go-	AuthHeader  string
./pkg/clients/security_middleware.go-
./pkg/clients/security_middleware.go-	// Rate limiting
./pkg/clients/security_middleware.go-	EnableRateLimit bool
./pkg/clients/security_middleware.go-
./pkg/clients/security_middleware.go-	// Audit logging
./pkg/clients/security_middleware.go-	EnableAudit bool
./pkg/clients/security_middleware.go-}
./pkg/clients/security_middleware.go-
./pkg/clients/security_middleware.go-// DefaultSecurityMiddlewareConfig returns default middleware configuration
./pkg/clients/security_middleware.go-func DefaultSecurityMiddlewareConfig() SecurityMiddlewareConfig {
./pkg/clients/security_middleware.go-	return SecurityMiddlewareConfig{
./pkg/clients/security_middleware.go-		EnableSecurityHeaders: true,
./pkg/clients/security_middleware.go-		CSPPolicy:             "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'",
./pkg/clients/security_middleware.go-		HSTSMaxAge:            31536000, // 1 year
./pkg/clients/security_middleware.go-		EnableCORS:            true,
./pkg/clients/security_middleware.go-		AllowedOrigins:        []string{"*"},
./pkg/clients/security_middleware.go-		AllowedMethods:        []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
./pkg/clients/security_middleware.go-		AllowedHeaders:        []string{"Content-Type", "Authorization", "X-Correlation-ID"},
./pkg/clients/security_middleware.go-		ExposedHeaders:        []string{"X-Correlation-ID", "X-Request-ID"},
./pkg/clients/security_middleware.go-		AllowCredentials:      false,
./pkg/clients/security_middleware.go-		MaxAge:                3600,
./pkg/clients/security_middleware.go-		ValidateInput:         true,
./pkg/clients/security_middleware.go-		MaxRequestSize:        10 * 1024 * 1024, // 10MB
./pkg/clients/security_middleware.go-		MaxHeaderSize:         8192,
./pkg/clients/security_middleware.go-		RequireAuth:           true,
./pkg/clients/security_middleware.go-		AuthHeader:            "Authorization",
./pkg/clients/security_middleware.go-		EnableRateLimit:       true,
./pkg/clients/security_middleware.go-		EnableAudit:           true,
--
./pkg/clients/performance_optimizer.go:type OptimizationConfig struct {
./pkg/clients/performance_optimizer.go-	// Connection pooling
./pkg/clients/performance_optimizer.go-	EnableDynamicPooling bool          `json:"enable_dynamic_pooling"`
./pkg/clients/performance_optimizer.go-	MinConnections       int           `json:"min_connections"`
./pkg/clients/performance_optimizer.go-	MaxConnections       int           `json:"max_connections"`
./pkg/clients/performance_optimizer.go-	ConnectionTTL        time.Duration `json:"connection_ttl"`
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-	// Compression
./pkg/clients/performance_optimizer.go-	EnableCompression  bool   `json:"enable_compression"`
./pkg/clients/performance_optimizer.go-	CompressionLevel   int    `json:"compression_level"`
./pkg/clients/performance_optimizer.go-	MinCompressionSize int    `json:"min_compression_size"`
./pkg/clients/performance_optimizer.go-	AcceptEncodings    string `json:"accept_encodings"`
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-	// Load balancing
./pkg/clients/performance_optimizer.go-	EnableLoadBalancing bool     `json:"enable_load_balancing"`
./pkg/clients/performance_optimizer.go-	Endpoints           []string `json:"endpoints"`
./pkg/clients/performance_optimizer.go-	BalancingStrategy   string   `json:"balancing_strategy"` // round-robin, least-connections, weighted
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-	// Performance tuning
./pkg/clients/performance_optimizer.go-	EnableHTTP2         bool          `json:"enable_http2"`
./pkg/clients/performance_optimizer.go-	EnableKeepAlive     bool          `json:"enable_keep_alive"`
./pkg/clients/performance_optimizer.go-	KeepAliveTimeout    time.Duration `json:"keep_alive_timeout"`
./pkg/clients/performance_optimizer.go-	ResponseTimeout     time.Duration `json:"response_timeout"`
./pkg/clients/performance_optimizer.go-	MaxIdleConnsPerHost int           `json:"max_idle_conns_per_host"`
./pkg/clients/performance_optimizer.go-}
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-// ConnectionPoolManager manages dynamic connection pooling
./pkg/clients/performance_optimizer.go-type ConnectionPoolManager struct {
./pkg/clients/performance_optimizer.go-	// mu sync.RWMutex // TODO: Implement locking when methods are added
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-	// Pool configuration
./pkg/clients/performance_optimizer.go-	minConns     int
./pkg/clients/performance_optimizer.go-	maxConns     int
./pkg/clients/performance_optimizer.go-	currentConns int32
./pkg/clients/performance_optimizer.go-	activeConns  int32
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-	// Connection tracking
./pkg/clients/performance_optimizer.go-	connections map[string]*PooledConnection
./pkg/clients/performance_optimizer.go-	connMutex   sync.RWMutex
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-	// Pool statistics
./pkg/clients/performance_optimizer.go-	// totalRequests int64          // TODO: Implement request counting
./pkg/clients/performance_optimizer.go-	poolHits   int64
./pkg/clients/performance_optimizer.go-	poolMisses int64
./pkg/clients/performance_optimizer.go-	// avgWaitTime   time.Duration // TODO: Implement wait time tracking
./pkg/clients/performance_optimizer.go-
./pkg/clients/performance_optimizer.go-	// Dynamic adjustment
./pkg/clients/performance_optimizer.go-	// lastAdjustment time.Time // TODO: Implement dynamic adjustment
./pkg/clients/performance_optimizer.go-	adjustInterval time.Duration
./pkg/clients/performance_optimizer.go-}
./pkg/clients/performance_optimizer.go-
--
./pkg/middleware/rate_limit.go:type RateLimitConfig struct {
./pkg/middleware/rate_limit.go-	// Global limits
./pkg/middleware/rate_limit.go-	GlobalRPS   int // Requests per second globally
./pkg/middleware/rate_limit.go-	GlobalBurst int // Burst size globally
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-	// Per-tenant limits
./pkg/middleware/rate_limit.go-	TenantRPS   int // Requests per second per tenant
./pkg/middleware/rate_limit.go-	TenantBurst int // Burst size per tenant
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-	// Per-tool limits
./pkg/middleware/rate_limit.go-	ToolRPS   int // Requests per second per tool
./pkg/middleware/rate_limit.go-	ToolBurst int // Burst size per tool
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-	// Cleanup
./pkg/middleware/rate_limit.go-	CleanupInterval time.Duration // How often to clean up old limiters
./pkg/middleware/rate_limit.go-	MaxAge          time.Duration // Maximum age for unused limiters
./pkg/middleware/rate_limit.go-}
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-// rateLimiterEntry holds a rate limiter and its last access time
./pkg/middleware/rate_limit.go-type rateLimiterEntry struct {
./pkg/middleware/rate_limit.go-	limiter    *rate.Limiter
./pkg/middleware/rate_limit.go-	lastAccess time.Time
./pkg/middleware/rate_limit.go-}
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-// DefaultRateLimitConfig returns default rate limit configuration
./pkg/middleware/rate_limit.go-func DefaultRateLimitConfig() RateLimitConfig {
./pkg/middleware/rate_limit.go-	return RateLimitConfig{
./pkg/middleware/rate_limit.go-		GlobalRPS:       1000,
./pkg/middleware/rate_limit.go-		GlobalBurst:     2000,
./pkg/middleware/rate_limit.go-		TenantRPS:       100,
./pkg/middleware/rate_limit.go-		TenantBurst:     200,
./pkg/middleware/rate_limit.go-		ToolRPS:         50,
./pkg/middleware/rate_limit.go-		ToolBurst:       100,
./pkg/middleware/rate_limit.go-		CleanupInterval: 5 * time.Minute,
./pkg/middleware/rate_limit.go-		MaxAge:          1 * time.Hour,
./pkg/middleware/rate_limit.go-	}
./pkg/middleware/rate_limit.go-}
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-// NewRateLimiter creates a new rate limiter
./pkg/middleware/rate_limit.go-func NewRateLimiter(config RateLimitConfig, logger observability.Logger, metrics observability.MetricsClient) *RateLimiter {
./pkg/middleware/rate_limit.go-	rl := &RateLimiter{
./pkg/middleware/rate_limit.go-		limiters: make(map[string]*rateLimiterEntry),
./pkg/middleware/rate_limit.go-		config:   config,
./pkg/middleware/rate_limit.go-		logger:   logger,
./pkg/middleware/rate_limit.go-		metrics:  metrics,
./pkg/middleware/rate_limit.go-	}
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-	// Start cleanup routine
./pkg/middleware/rate_limit.go-	go rl.cleanupRoutine()
./pkg/middleware/rate_limit.go-
./pkg/middleware/rate_limit.go-	return rl
--
./pkg/database/config.go:type Config struct {
./pkg/database/config.go-	// Core database settings
./pkg/database/config.go-	Driver          string
./pkg/database/config.go-	DSN             string
./pkg/database/config.go-	Host            string
./pkg/database/config.go-	Port            int
./pkg/database/config.go-	Database        string
./pkg/database/config.go-	Username        string
./pkg/database/config.go-	Password        string
./pkg/database/config.go-	SSLMode         string
./pkg/database/config.go-	MaxOpenConns    int
./pkg/database/config.go-	MaxIdleConns    int
./pkg/database/config.go-	ConnMaxLifetime time.Duration
./pkg/database/config.go-
./pkg/database/config.go-	// TLS Configuration
./pkg/database/config.go-	TLS *securitytls.Config
./pkg/database/config.go-
./pkg/database/config.go-	// Timeout configurations (best practice)
./pkg/database/config.go-	QueryTimeout   time.Duration // Default: 30s
./pkg/database/config.go-	ConnectTimeout time.Duration // Default: 10s
./pkg/database/config.go-
./pkg/database/config.go-	// AWS RDS specific settings (optional)
./pkg/database/config.go-	UseAWS     bool
./pkg/database/config.go-	UseIAM     bool
./pkg/database/config.go-	AWSRegion  string
./pkg/database/config.go-	AWSRoleARN string
./pkg/database/config.go-
./pkg/database/config.go-	// RDS-specific configuration
./pkg/database/config.go-	RDSHost              string
./pkg/database/config.go-	RDSPort              int
./pkg/database/config.go-	RDSDatabase          string
./pkg/database/config.go-	RDSUsername          string
./pkg/database/config.go-	RDSTokenExpiration   int // seconds
./pkg/database/config.go-	RDSEnablePooling     bool
./pkg/database/config.go-	RDSMinPoolSize       int
./pkg/database/config.go-	RDSMaxPoolSize       int
./pkg/database/config.go-	RDSConnectionTimeout int // seconds
./pkg/database/config.go-
./pkg/database/config.go-	// Migration settings
./pkg/database/config.go-	AutoMigrate          bool
./pkg/database/config.go-	MigrationsPath       string
./pkg/database/config.go-	FailOnMigrationError bool
./pkg/database/config.go-
./pkg/database/config.go-	// Schema settings
./pkg/database/config.go-	SearchPath string
./pkg/database/config.go-}
./pkg/database/config.go-
./pkg/database/config.go-// NewConfig creates config with sensible defaults
./pkg/database/config.go-func NewConfig() *Config {
./pkg/database/config.go-	return &Config{
./pkg/database/config.go-		Driver:          "postgres",
--
./pkg/database/vector.go:type VectorConfig struct {
./pkg/database/vector.go-	Enabled           bool
./pkg/database/vector.go-	ExtensionSchema   string
./pkg/database/vector.go-	IndexType         string
./pkg/database/vector.go-	DistanceMetric    string
./pkg/database/vector.go-	MaxDimensions     int
./pkg/database/vector.go-	DefaultDimensions int
./pkg/database/vector.go-}
./pkg/database/vector.go-
./pkg/database/vector.go-// VectorDatabase provides specialized database operations for vector data
./pkg/database/vector.go-type VectorDatabase struct {
./pkg/database/vector.go-	db          *sqlx.DB
./pkg/database/vector.go-	vectorDB    *sqlx.DB
./pkg/database/vector.go-	logger      observability.Logger
./pkg/database/vector.go-	config      *VectorConfig
./pkg/database/vector.go-	initialized bool
./pkg/database/vector.go-	lock        sync.RWMutex
./pkg/database/vector.go-}
./pkg/database/vector.go-
./pkg/database/vector.go-// NewVectorDatabase creates a new vector database
./pkg/database/vector.go-func NewVectorDatabase(db *sqlx.DB, cfg any, logger observability.Logger) (*VectorDatabase, error) {
./pkg/database/vector.go-	if logger == nil {
./pkg/database/vector.go-		logger = observability.NewStandardLogger("vector_database")
./pkg/database/vector.go-	}
./pkg/database/vector.go-
./pkg/database/vector.go-	// Use the main database connection pool by default
./pkg/database/vector.go-	vectorDB := db
./pkg/database/vector.go-
./pkg/database/vector.go-	// Try to extract vector config from the provided config
./pkg/database/vector.go-	var vectorConfig *VectorConfig
./pkg/database/vector.go-
./pkg/database/vector.go-	// If the config is already a VectorConfig
./pkg/database/vector.go-	if vConfig, ok := cfg.(*VectorConfig); ok && vConfig != nil {
./pkg/database/vector.go-		vectorConfig = vConfig
./pkg/database/vector.go-	} else {
./pkg/database/vector.go-		// Create a default config if none provided
./pkg/database/vector.go-		vectorConfig = &VectorConfig{
./pkg/database/vector.go-			Enabled:           true,
./pkg/database/vector.go-			DefaultDimensions: 1536,
./pkg/database/vector.go-			DistanceMetric:    "cosine",
./pkg/database/vector.go-			IndexType:         "ivfflat",
./pkg/database/vector.go-			ExtensionSchema:   "public",
./pkg/database/vector.go-			MaxDimensions:     2000,
./pkg/database/vector.go-		}
./pkg/database/vector.go-	}
./pkg/database/vector.go-
./pkg/database/vector.go-	return &VectorDatabase{
./pkg/database/vector.go-		db:          db,
./pkg/database/vector.go-		vectorDB:    vectorDB,
./pkg/database/vector.go-		logger:      logger,
./pkg/database/vector.go-		config:      vectorConfig,
--
./pkg/database/migration/manager.go:type Config struct {
./pkg/database/migration/manager.go-	// Path to migration files directory
./pkg/database/migration/manager.go-	MigrationsPath string `json:"migrations_path" yaml:"migrations_path"`
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	// Whether to automatically run migrations on startup
./pkg/database/migration/manager.go-	AutoMigrate bool `json:"auto_migrate" yaml:"auto_migrate"`
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	// Timeout for migration operations
./pkg/database/migration/manager.go-	MigrationTimeout time.Duration `json:"migration_timeout" yaml:"migration_timeout"`
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	// Whether to validate migrations without applying them
./pkg/database/migration/manager.go-	ValidateOnly bool `json:"validate_only" yaml:"validate_only"`
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	// Use a specific number of steps for migration (0 means all)
./pkg/database/migration/manager.go-	Steps int `json:"steps" yaml:"steps"`
./pkg/database/migration/manager.go-}
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-// Manager handles database migrations
./pkg/database/migration/manager.go-type Manager struct {
./pkg/database/migration/manager.go-	db         *sqlx.DB
./pkg/database/migration/manager.go-	config     Config
./pkg/database/migration/manager.go-	migrator   *migrate.Migrate
./pkg/database/migration/manager.go-	driverName string
./pkg/database/migration/manager.go-}
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-// NewManager creates a new migration manager
./pkg/database/migration/manager.go-func NewManager(db *sqlx.DB, config Config, driverName string) (*Manager, error) {
./pkg/database/migration/manager.go-	if db == nil {
./pkg/database/migration/manager.go-		return nil, errors.New("db connection cannot be nil")
./pkg/database/migration/manager.go-	}
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	if config.MigrationsPath == "" {
./pkg/database/migration/manager.go-		// Default to a standard location if not specified
./pkg/database/migration/manager.go-		config.MigrationsPath = "migrations/sql"
./pkg/database/migration/manager.go-	}
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	if config.MigrationTimeout == 0 {
./pkg/database/migration/manager.go-		// Default timeout of 1 minute
./pkg/database/migration/manager.go-		config.MigrationTimeout = 1 * time.Minute
./pkg/database/migration/manager.go-	}
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	// Resolve the absolute path to migrations to validate it exists
./pkg/database/migration/manager.go-	_, err := filepath.Abs(config.MigrationsPath)
./pkg/database/migration/manager.go-	if err != nil {
./pkg/database/migration/manager.go-		return nil, fmt.Errorf("failed to resolve migrations path: %w", err)
./pkg/database/migration/manager.go-	}
./pkg/database/migration/manager.go-
./pkg/database/migration/manager.go-	return &Manager{
./pkg/database/migration/manager.go-		db:         db,
./pkg/database/migration/manager.go-		config:     config,
./pkg/database/migration/manager.go-		driverName: driverName,
--
./pkg/repository/webhook_config_repository.go:	type dbWebhookConfig struct {
./pkg/repository/webhook_config_repository.go-		ID               uuid.UUID      `db:"id"`
./pkg/repository/webhook_config_repository.go-		TenantID         uuid.UUID      `db:"tenant_id"`
./pkg/repository/webhook_config_repository.go-		OrganizationName string         `db:"organization_name"`
./pkg/repository/webhook_config_repository.go-		URL              string         `db:"url"`
./pkg/repository/webhook_config_repository.go-		WebhookSecret    string         `db:"webhook_secret"`
./pkg/repository/webhook_config_repository.go-		Enabled          bool           `db:"enabled"`
./pkg/repository/webhook_config_repository.go-		AllowedEvents    pq.StringArray `db:"allowed_events"`
./pkg/repository/webhook_config_repository.go-		Metadata         models.JSONMap `db:"metadata"`
./pkg/repository/webhook_config_repository.go-		CreatedAt        sql.NullTime   `db:"created_at"`
./pkg/repository/webhook_config_repository.go-		UpdatedAt        sql.NullTime   `db:"updated_at"`
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	var dbConfig dbWebhookConfig
./pkg/repository/webhook_config_repository.go-	query := `
./pkg/repository/webhook_config_repository.go-		SELECT id, tenant_id, organization_name, url, webhook_secret, enabled, allowed_events, metadata, created_at, updated_at
./pkg/repository/webhook_config_repository.go-		FROM mcp.webhook_configs
./pkg/repository/webhook_config_repository.go-		WHERE organization_name = $1
./pkg/repository/webhook_config_repository.go-	`
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	err := r.db.GetContext(ctx, &dbConfig, query, orgName)
./pkg/repository/webhook_config_repository.go-	if err != nil {
./pkg/repository/webhook_config_repository.go-		if err == sql.ErrNoRows {
./pkg/repository/webhook_config_repository.go-			return nil, errors.Wrap(err, "webhook configuration not found")
./pkg/repository/webhook_config_repository.go-		}
./pkg/repository/webhook_config_repository.go-		return nil, errors.Wrap(err, "failed to get webhook configuration")
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	// Convert to the model struct
./pkg/repository/webhook_config_repository.go-	config := &models.WebhookConfig{
./pkg/repository/webhook_config_repository.go-		ID:               dbConfig.ID,
./pkg/repository/webhook_config_repository.go-		OrganizationName: dbConfig.OrganizationName,
./pkg/repository/webhook_config_repository.go-		WebhookSecret:    dbConfig.WebhookSecret,
./pkg/repository/webhook_config_repository.go-		Enabled:          dbConfig.Enabled,
./pkg/repository/webhook_config_repository.go-		AllowedEvents:    dbConfig.AllowedEvents,
./pkg/repository/webhook_config_repository.go-		Metadata:         dbConfig.Metadata,
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	if dbConfig.CreatedAt.Valid {
./pkg/repository/webhook_config_repository.go-		config.CreatedAt = dbConfig.CreatedAt.Time
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-	if dbConfig.UpdatedAt.Valid {
./pkg/repository/webhook_config_repository.go-		config.UpdatedAt = dbConfig.UpdatedAt.Time
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	return config, nil
./pkg/repository/webhook_config_repository.go-}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-// GetWebhookSecret retrieves just the webhook secret for an organization
./pkg/repository/webhook_config_repository.go-func (r *webhookConfigRepository) GetWebhookSecret(ctx context.Context, orgName string) (string, error) {
./pkg/repository/webhook_config_repository.go-	var secret string
--
./pkg/repository/webhook_config_repository.go:	type dbWebhookConfig struct {
./pkg/repository/webhook_config_repository.go-		ID               uuid.UUID      `db:"id"`
./pkg/repository/webhook_config_repository.go-		TenantID         uuid.UUID      `db:"tenant_id"`
./pkg/repository/webhook_config_repository.go-		OrganizationName string         `db:"organization_name"`
./pkg/repository/webhook_config_repository.go-		URL              string         `db:"url"`
./pkg/repository/webhook_config_repository.go-		WebhookSecret    string         `db:"webhook_secret"`
./pkg/repository/webhook_config_repository.go-		Enabled          bool           `db:"enabled"`
./pkg/repository/webhook_config_repository.go-		AllowedEvents    pq.StringArray `db:"allowed_events"`
./pkg/repository/webhook_config_repository.go-		Metadata         models.JSONMap `db:"metadata"`
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	dbConfig := dbWebhookConfig{
./pkg/repository/webhook_config_repository.go-		ID:               newConfig.ID,
./pkg/repository/webhook_config_repository.go-		TenantID:         defaultTenantID,
./pkg/repository/webhook_config_repository.go-		OrganizationName: newConfig.OrganizationName,
./pkg/repository/webhook_config_repository.go-		URL:              webhookURL,
./pkg/repository/webhook_config_repository.go-		WebhookSecret:    newConfig.WebhookSecret,
./pkg/repository/webhook_config_repository.go-		Enabled:          newConfig.Enabled,
./pkg/repository/webhook_config_repository.go-		AllowedEvents:    newConfig.AllowedEvents,
./pkg/repository/webhook_config_repository.go-		Metadata:         newConfig.Metadata,
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	query := `
./pkg/repository/webhook_config_repository.go-		INSERT INTO mcp.webhook_configs 
./pkg/repository/webhook_config_repository.go-		(id, tenant_id, organization_name, url, webhook_secret, enabled, allowed_events, metadata)
./pkg/repository/webhook_config_repository.go-		VALUES (:id, :tenant_id, :organization_name, :url, :webhook_secret, :enabled, :allowed_events, :metadata)
./pkg/repository/webhook_config_repository.go-		RETURNING created_at, updated_at
./pkg/repository/webhook_config_repository.go-	`
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	rows, err := r.db.NamedQueryContext(ctx, query, dbConfig)
./pkg/repository/webhook_config_repository.go-	if err != nil {
./pkg/repository/webhook_config_repository.go-		return nil, errors.Wrap(err, "failed to create webhook configuration")
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-	defer func() {
./pkg/repository/webhook_config_repository.go-		_ = rows.Close()
./pkg/repository/webhook_config_repository.go-	}()
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	if rows.Next() {
./pkg/repository/webhook_config_repository.go-		err = rows.Scan(&newConfig.CreatedAt, &newConfig.UpdatedAt)
./pkg/repository/webhook_config_repository.go-		if err != nil {
./pkg/repository/webhook_config_repository.go-			return nil, errors.Wrap(err, "failed to scan timestamps")
./pkg/repository/webhook_config_repository.go-		}
./pkg/repository/webhook_config_repository.go-	}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-	return newConfig, nil
./pkg/repository/webhook_config_repository.go-}
./pkg/repository/webhook_config_repository.go-
./pkg/repository/webhook_config_repository.go-// Update updates an existing webhook configuration
./pkg/repository/webhook_config_repository.go-func (r *webhookConfigRepository) Update(ctx context.Context, orgName string, config *models.WebhookConfigUpdate) (*models.WebhookConfig, error) {
./pkg/repository/webhook_config_repository.go-	// Build dynamic update query
./pkg/repository/webhook_config_repository.go-	updates := make(map[string]interface{})
--
./pkg/repository/postgres/base_repository.go:type BaseRepositoryConfig struct {
./pkg/repository/postgres/base_repository.go-	QueryTimeout   time.Duration
./pkg/repository/postgres/base_repository.go-	MaxRetries     int
./pkg/repository/postgres/base_repository.go-	CacheTimeout   time.Duration
./pkg/repository/postgres/base_repository.go-	CircuitBreaker *resilience.CircuitBreaker
./pkg/repository/postgres/base_repository.go-}
./pkg/repository/postgres/base_repository.go-
./pkg/repository/postgres/base_repository.go-// NewBaseRepository creates a new base repository
./pkg/repository/postgres/base_repository.go-func NewBaseRepository(
./pkg/repository/postgres/base_repository.go-	writeDB, readDB *sqlx.DB,
./pkg/repository/postgres/base_repository.go-	cache cache.Cache,
./pkg/repository/postgres/base_repository.go-	logger observability.Logger,
./pkg/repository/postgres/base_repository.go-	tracer observability.StartSpanFunc,
./pkg/repository/postgres/base_repository.go-	metrics observability.MetricsClient,
./pkg/repository/postgres/base_repository.go-	config BaseRepositoryConfig,
./pkg/repository/postgres/base_repository.go-) *BaseRepository {
./pkg/repository/postgres/base_repository.go-	if config.QueryTimeout == 0 {
./pkg/repository/postgres/base_repository.go-		config.QueryTimeout = 30 * time.Second
./pkg/repository/postgres/base_repository.go-	}
./pkg/repository/postgres/base_repository.go-	if config.MaxRetries == 0 {
./pkg/repository/postgres/base_repository.go-		config.MaxRetries = 3
./pkg/repository/postgres/base_repository.go-	}
./pkg/repository/postgres/base_repository.go-	if config.CacheTimeout == 0 {
./pkg/repository/postgres/base_repository.go-		config.CacheTimeout = 5 * time.Minute
./pkg/repository/postgres/base_repository.go-	}
./pkg/repository/postgres/base_repository.go-
./pkg/repository/postgres/base_repository.go-	return &BaseRepository{
./pkg/repository/postgres/base_repository.go-		writeDB:      writeDB,
./pkg/repository/postgres/base_repository.go-		readDB:       readDB,
./pkg/repository/postgres/base_repository.go-		tx:           nil,
./pkg/repository/postgres/base_repository.go-		cache:        cache,
./pkg/repository/postgres/base_repository.go-		logger:       logger,
./pkg/repository/postgres/base_repository.go-		tracer:       tracer,
./pkg/repository/postgres/base_repository.go-		metrics:      metrics,
./pkg/repository/postgres/base_repository.go-		cb:           config.CircuitBreaker,
./pkg/repository/postgres/base_repository.go-		stmtCache:    make(map[string]*sqlx.NamedStmt),
./pkg/repository/postgres/base_repository.go-		queryTimeout: config.QueryTimeout,
./pkg/repository/postgres/base_repository.go-		maxRetries:   config.MaxRetries,
./pkg/repository/postgres/base_repository.go-		cacheTimeout: config.CacheTimeout,
./pkg/repository/postgres/base_repository.go-	}
./pkg/repository/postgres/base_repository.go-}
./pkg/repository/postgres/base_repository.go-
./pkg/repository/postgres/base_repository.go-// WithTx creates a new repository instance that uses the provided transaction
./pkg/repository/postgres/base_repository.go-func (r *BaseRepository) WithTx(tx *sqlx.Tx) *BaseRepository {
./pkg/repository/postgres/base_repository.go-	return &BaseRepository{
./pkg/repository/postgres/base_repository.go-		writeDB:      r.writeDB,
./pkg/repository/postgres/base_repository.go-		readDB:       r.readDB,
./pkg/repository/postgres/base_repository.go-		tx:           tx,
./pkg/repository/postgres/base_repository.go-		cache:        r.cache,
./pkg/repository/postgres/base_repository.go-		logger:       r.logger,
./pkg/repository/postgres/base_repository.go-		tracer:       r.tracer,
--
./pkg/tools/plugin.go:type ToolConfig struct {
./pkg/tools/plugin.go-	ID                string                  `json:"id"`
./pkg/tools/plugin.go-	TenantID          string                  `json:"tenant_id"`
./pkg/tools/plugin.go-	Name              string                  `json:"name"`
./pkg/tools/plugin.go-	BaseURL           string                  `json:"base_url"`
./pkg/tools/plugin.go-	DocumentationURL  string                  `json:"documentation_url,omitempty"`
./pkg/tools/plugin.go-	OpenAPIURL        string                  `json:"openapi_url,omitempty"`
./pkg/tools/plugin.go-	Config            map[string]interface{}  `json:"config"`
./pkg/tools/plugin.go-	Credential        *models.TokenCredential `json:"-"` // Never serialize credentials
./pkg/tools/plugin.go-	RetryPolicy       *ToolRetryPolicy        `json:"retry_policy,omitempty"`
./pkg/tools/plugin.go-	HealthConfig      *HealthCheckConfig      `json:"health_config,omitempty"`
./pkg/tools/plugin.go-	Provider          string                  `json:"provider,omitempty"`
./pkg/tools/plugin.go-	PassthroughConfig *PassthroughConfig      `json:"passthrough_config,omitempty"`
./pkg/tools/plugin.go-}
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// PassthroughConfig defines how user token passthrough should be handled
./pkg/tools/plugin.go:type PassthroughConfig struct {
./pkg/tools/plugin.go-	Mode              string `json:"mode"`                // optional, required, disabled
./pkg/tools/plugin.go-	FallbackToService bool   `json:"fallback_to_service"` // Allow fallback to service account
./pkg/tools/plugin.go-}
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// ToolRetryPolicy extends the base retry policy with tool-specific settings
./pkg/tools/plugin.go-type ToolRetryPolicy struct {
./pkg/tools/plugin.go-	resilience.RetryPolicy
./pkg/tools/plugin.go-	RetryableErrors  []string `json:"retryable_errors"`
./pkg/tools/plugin.go-	RetryOnTimeout   bool     `json:"retry_on_timeout"`
./pkg/tools/plugin.go-	RetryOnRateLimit bool     `json:"retry_on_rate_limit"`
./pkg/tools/plugin.go-}
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// HealthCheckConfig defines health check configuration
./pkg/tools/plugin.go:type HealthCheckConfig struct {
./pkg/tools/plugin.go-	Mode           string        `json:"mode"` // "on_demand", "periodic", "disabled"
./pkg/tools/plugin.go-	CacheDuration  time.Duration `json:"cache_duration"`
./pkg/tools/plugin.go-	StaleThreshold time.Duration `json:"stale_threshold"`
./pkg/tools/plugin.go-	CheckTimeout   time.Duration `json:"check_timeout"`
./pkg/tools/plugin.go-	HealthEndpoint string        `json:"health_endpoint,omitempty"`
./pkg/tools/plugin.go-}
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// HealthStatus represents the health status of a tool
./pkg/tools/plugin.go-type HealthStatus struct {
./pkg/tools/plugin.go-	IsHealthy    bool                   `json:"is_healthy"`
./pkg/tools/plugin.go-	LastChecked  time.Time              `json:"last_checked"`
./pkg/tools/plugin.go-	ResponseTime int                    `json:"response_time_ms"`
./pkg/tools/plugin.go-	Error        string                 `json:"error,omitempty"`
./pkg/tools/plugin.go-	Version      string                 `json:"version,omitempty"`
./pkg/tools/plugin.go-	Details      map[string]interface{} `json:"details,omitempty"`
./pkg/tools/plugin.go-}
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// DiscoveryResult contains the results of API discovery
./pkg/tools/plugin.go-type DiscoveryResult struct {
./pkg/tools/plugin.go-	Status           DiscoveryStatus           `json:"status"`
./pkg/tools/plugin.go-	OpenAPISpec      *openapi3.T               `json:"-"` // Don't serialize the full spec
./pkg/tools/plugin.go-	SpecURL          string                    `json:"spec_url,omitempty"`
./pkg/tools/plugin.go-	DiscoveredURLs   []string                  `json:"discovered_urls"`
./pkg/tools/plugin.go-	Capabilities     []Capability              `json:"capabilities"`
./pkg/tools/plugin.go-	RequiresManual   bool                      `json:"requires_manual"`
./pkg/tools/plugin.go-	SuggestedActions []string                  `json:"suggested_actions,omitempty"`
./pkg/tools/plugin.go-	Metadata         map[string]interface{}    `json:"metadata,omitempty"`
./pkg/tools/plugin.go-	WebhookConfig    *models.ToolWebhookConfig `json:"webhook_config,omitempty"`
./pkg/tools/plugin.go-}
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// DiscoveryStatus represents the status of API discovery
./pkg/tools/plugin.go-type DiscoveryStatus string
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-const (
./pkg/tools/plugin.go-	DiscoveryStatusSuccess      DiscoveryStatus = "success"
./pkg/tools/plugin.go-	DiscoveryStatusPartial      DiscoveryStatus = "partial"
./pkg/tools/plugin.go-	DiscoveryStatusFailed       DiscoveryStatus = "failed"
./pkg/tools/plugin.go-	DiscoveryStatusManualNeeded DiscoveryStatus = "manual_needed"
./pkg/tools/plugin.go-)
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// Capability represents a tool capability
./pkg/tools/plugin.go-type Capability struct {
./pkg/tools/plugin.go-	Name        string   `json:"name"`
./pkg/tools/plugin.go-	Description string   `json:"description"`
./pkg/tools/plugin.go-	Actions     []string `json:"actions"`
./pkg/tools/plugin.go-	Required    bool     `json:"required"`
./pkg/tools/plugin.go-}
./pkg/tools/plugin.go-
./pkg/tools/plugin.go-// Common capabilities
./pkg/tools/plugin.go-var (
--
./pkg/tools/dynamic_auth.go:type OAuth2Config struct {
./pkg/tools/dynamic_auth.go-	TokenURL string            `json:"token_url"`
./pkg/tools/dynamic_auth.go-	Scopes   map[string]string `json:"scopes"`
./pkg/tools/dynamic_auth.go-}
./pkg/tools/dynamic_auth.go-
./pkg/tools/dynamic_auth.go-// removeDuplicates removes duplicate strings from a slice
./pkg/tools/dynamic_auth.go-func removeDuplicates(items []string) []string {
./pkg/tools/dynamic_auth.go-	seen := make(map[string]bool)
./pkg/tools/dynamic_auth.go-	result := []string{}
./pkg/tools/dynamic_auth.go-
./pkg/tools/dynamic_auth.go-	for _, item := range items {
./pkg/tools/dynamic_auth.go-		if !seen[item] {
./pkg/tools/dynamic_auth.go-			seen[item] = true
./pkg/tools/dynamic_auth.go-			result = append(result, item)
./pkg/tools/dynamic_auth.go-		}
./pkg/tools/dynamic_auth.go-	}
./pkg/tools/dynamic_auth.go-
./pkg/tools/dynamic_auth.go-	return result
./pkg/tools/dynamic_auth.go-}
--
./pkg/retry/retry.go:type Config struct {
./pkg/retry/retry.go-	InitialInterval time.Duration
./pkg/retry/retry.go-	MaxInterval     time.Duration
./pkg/retry/retry.go-	MaxElapsedTime  time.Duration
./pkg/retry/retry.go-	Multiplier      float64
./pkg/retry/retry.go-	MaxRetries      int
./pkg/retry/retry.go-}
./pkg/retry/retry.go-
./pkg/retry/retry.go-// ExponentialBackoff implements exponential backoff retry policy
./pkg/retry/retry.go-type ExponentialBackoff struct {
./pkg/retry/retry.go-	config Config
./pkg/retry/retry.go-}
./pkg/retry/retry.go-
./pkg/retry/retry.go-// NewExponentialBackoff creates a new exponential backoff retry policy
./pkg/retry/retry.go-func NewExponentialBackoff(config Config) Policy {
./pkg/retry/retry.go-	if config.InitialInterval <= 0 {
./pkg/retry/retry.go-		config.InitialInterval = 100 * time.Millisecond
./pkg/retry/retry.go-	}
./pkg/retry/retry.go-	if config.MaxInterval <= 0 {
./pkg/retry/retry.go-		config.MaxInterval = 30 * time.Second
./pkg/retry/retry.go-	}
./pkg/retry/retry.go-	if config.MaxElapsedTime <= 0 {
./pkg/retry/retry.go-		config.MaxElapsedTime = 5 * time.Minute
./pkg/retry/retry.go-	}
./pkg/retry/retry.go-	if config.Multiplier <= 1.0 {
./pkg/retry/retry.go-		config.Multiplier = 2.0
./pkg/retry/retry.go-	}
./pkg/retry/retry.go-	if config.MaxRetries <= 0 {
./pkg/retry/retry.go-		config.MaxRetries = 10
./pkg/retry/retry.go-	}
./pkg/retry/retry.go-
./pkg/retry/retry.go-	return &ExponentialBackoff{config: config}
./pkg/retry/retry.go-}
./pkg/retry/retry.go-
./pkg/retry/retry.go-// Execute executes the function with exponential backoff retry
./pkg/retry/retry.go-func (e *ExponentialBackoff) Execute(ctx context.Context, fn func(ctx context.Context) error) error {
./pkg/retry/retry.go-	start := time.Now()
./pkg/retry/retry.go-	attempt := 0
./pkg/retry/retry.go-
./pkg/retry/retry.go-	for {
./pkg/retry/retry.go-		err := fn(ctx)
./pkg/retry/retry.go-		if err == nil {
./pkg/retry/retry.go-			return nil
./pkg/retry/retry.go-		}
./pkg/retry/retry.go-
./pkg/retry/retry.go-		attempt++
./pkg/retry/retry.go-
./pkg/retry/retry.go-		// Check if we've exceeded max retries
./pkg/retry/retry.go-		if e.config.MaxRetries > 0 && attempt >= e.config.MaxRetries {
./pkg/retry/retry.go-			return err
./pkg/retry/retry.go-		}
--
./pkg/intelligence/service.go:type ServiceConfig struct {
./pkg/intelligence/service.go-	// Execution modes
./pkg/intelligence/service.go-	DefaultMode         ExecutionMode
./pkg/intelligence/service.go-	EnableAsyncFallback bool
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Performance
./pkg/intelligence/service.go-	MaxConcurrency int64
./pkg/intelligence/service.go-	TimeoutSeconds int
./pkg/intelligence/service.go-	CacheEnabled   bool
./pkg/intelligence/service.go-	CacheTTL       time.Duration
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Resilience
./pkg/intelligence/service.go-	CircuitBreakerConfig CircuitBreakerConfig
./pkg/intelligence/service.go-	RetryConfig          RetryConfig
./pkg/intelligence/service.go-	RateLimitConfig      RateLimitConfig
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Security
./pkg/intelligence/service.go-	SecurityConfig SecurityConfig
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Cost
./pkg/intelligence/service.go-	CostThresholdUSD float64
./pkg/intelligence/service.go-	DailyBudgetUSD   float64
./pkg/intelligence/service.go-}
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-// SLOConfig defines service level objectives
./pkg/intelligence/service.go:type SLOConfig struct {
./pkg/intelligence/service.go-	P50LatencyMs    float64 // 200ms
./pkg/intelligence/service.go-	P99LatencyMs    float64 // 500ms
./pkg/intelligence/service.go-	ErrorRatePct    float64 // 0.1%
./pkg/intelligence/service.go-	AvailabilityPct float64 // 99.9%
./pkg/intelligence/service.go-}
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-// NewResilientExecutionService creates a production-ready execution service
./pkg/intelligence/service.go-func NewResilientExecutionService(config *ServiceConfig, deps ServiceDependencies) (*ResilientExecutionService, error) {
./pkg/intelligence/service.go-	// Initialize tracer
./pkg/intelligence/service.go-	tracer := otel.Tracer("intelligence.execution")
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Initialize meter
./pkg/intelligence/service.go-	meter := otel.Meter("intelligence.execution")
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Create circuit breaker
./pkg/intelligence/service.go-	cbSettings := gobreaker.Settings{
./pkg/intelligence/service.go-		Name:        "execution-service",
./pkg/intelligence/service.go-		MaxRequests: uint32(config.CircuitBreakerConfig.MaxRequests),
./pkg/intelligence/service.go-		Interval:    config.CircuitBreakerConfig.Interval,
./pkg/intelligence/service.go-		Timeout:     config.CircuitBreakerConfig.Timeout,
./pkg/intelligence/service.go-		ReadyToTrip: func(counts gobreaker.Counts) bool {
./pkg/intelligence/service.go-			failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
./pkg/intelligence/service.go-			return counts.Requests >= 3 && failureRatio >= 0.6
./pkg/intelligence/service.go-		},
./pkg/intelligence/service.go-		OnStateChange: func(name string, from gobreaker.State, to gobreaker.State) {
./pkg/intelligence/service.go-			deps.Logger.Info("Circuit breaker state changed", map[string]interface{}{
./pkg/intelligence/service.go-				"name": name,
./pkg/intelligence/service.go-				"from": from,
./pkg/intelligence/service.go-				"to":   to,
./pkg/intelligence/service.go-			})
./pkg/intelligence/service.go-		},
./pkg/intelligence/service.go-	}
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	cb := gobreaker.NewCircuitBreaker(cbSettings)
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Create rate limiter
./pkg/intelligence/service.go-	rateLimiter := rate.NewLimiter(
./pkg/intelligence/service.go-		rate.Limit(config.RateLimitConfig.RequestsPerSecond),
./pkg/intelligence/service.go-		config.RateLimitConfig.BurstSize,
./pkg/intelligence/service.go-	)
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Create semaphore for concurrency control
./pkg/intelligence/service.go-	sem := semaphore.NewWeighted(config.MaxConcurrency)
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Create retry policy
./pkg/intelligence/service.go-	retryPolicy := backoff.NewExponentialBackOff()
./pkg/intelligence/service.go-	retryPolicy.MaxElapsedTime = 30 * time.Second
./pkg/intelligence/service.go-
./pkg/intelligence/service.go-	// Create security layer
./pkg/intelligence/service.go-	securityLayer := NewSecurityLayer(config.SecurityConfig)
--
./pkg/intelligence/types.go:type CircuitBreakerConfig struct {
./pkg/intelligence/types.go-	MaxRequests uint32
./pkg/intelligence/types.go-	Interval    time.Duration
./pkg/intelligence/types.go-	Timeout     time.Duration
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go:type RetryConfig struct {
./pkg/intelligence/types.go-	MaxRetries     int
./pkg/intelligence/types.go-	InitialBackoff time.Duration
./pkg/intelligence/types.go-	MaxBackoff     time.Duration
./pkg/intelligence/types.go-	Multiplier     float64
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go:type RateLimitConfig struct {
./pkg/intelligence/types.go-	RequestsPerSecond float64
./pkg/intelligence/types.go-	BurstSize         int
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-// Metrics types
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-type ExecutionMetricsCollector struct {
./pkg/intelligence/types.go-	totalExecutions  atomic.Uint64
./pkg/intelligence/types.go-	failedExecutions atomic.Uint64
./pkg/intelligence/types.go-	totalDuration    atomic.Value // time.Duration
./pkg/intelligence/types.go-	totalTokens      atomic.Uint64
./pkg/intelligence/types.go-	totalCost        atomic.Value // float64
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-func NewExecutionMetricsCollector(meter interface{}) *ExecutionMetricsCollector {
./pkg/intelligence/types.go-	collector := &ExecutionMetricsCollector{}
./pkg/intelligence/types.go-	collector.totalDuration.Store(time.Duration(0))
./pkg/intelligence/types.go-	collector.totalCost.Store(float64(0))
./pkg/intelligence/types.go-	return collector
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-func (c *ExecutionMetricsCollector) GetStats() map[string]interface{} {
./pkg/intelligence/types.go-	total := c.totalExecutions.Load()
./pkg/intelligence/types.go-	failed := c.failedExecutions.Load()
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-	return map[string]interface{}{
./pkg/intelligence/types.go-		"total":        total,
./pkg/intelligence/types.go-		"failed":       failed,
./pkg/intelligence/types.go-		"success_rate": float64(total-failed) / float64(total) * 100,
./pkg/intelligence/types.go-		"avg_duration": c.totalDuration.Load().(time.Duration) / time.Duration(total),
./pkg/intelligence/types.go-		"total_tokens": c.totalTokens.Load(),
./pkg/intelligence/types.go-		"total_cost":   c.totalCost.Load().(float64),
./pkg/intelligence/types.go-	}
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-type CostMetricsCollector struct {
./pkg/intelligence/types.go-	dailySpend   atomic.Value // decimal.Decimal
./pkg/intelligence/types.go-	monthlySpend atomic.Value // decimal.Decimal
./pkg/intelligence/types.go-	overBudget   atomic.Uint64
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-func NewCostMetricsCollector(meter interface{}) *CostMetricsCollector {
./pkg/intelligence/types.go-	collector := &CostMetricsCollector{}
./pkg/intelligence/types.go-	collector.dailySpend.Store(decimal.Zero)
./pkg/intelligence/types.go-	collector.monthlySpend.Store(decimal.Zero)
./pkg/intelligence/types.go-	return collector
./pkg/intelligence/types.go-}
./pkg/intelligence/types.go-
./pkg/intelligence/types.go-func (c *CostMetricsCollector) GetStats() map[string]interface{} {
./pkg/intelligence/types.go-	return map[string]interface{}{
--
./pkg/intelligence/security.go:type SecurityConfig struct {
./pkg/intelligence/security.go-	EnablePIIDetection   bool
./pkg/intelligence/security.go-	EnableSecretScanning bool
./pkg/intelligence/security.go-	EnableEncryption     bool
./pkg/intelligence/security.go-	EncryptionKey        []byte
./pkg/intelligence/security.go-	RedactPII            bool
./pkg/intelligence/security.go-	BlockOnSecrets       bool
./pkg/intelligence/security.go-	AuditEnabled         bool
./pkg/intelligence/security.go-	SensitivePatterns    []string
./pkg/intelligence/security.go-}
./pkg/intelligence/security.go-
./pkg/intelligence/security.go-// NewSecurityLayer creates a new security layer
./pkg/intelligence/security.go-func NewSecurityLayer(config SecurityConfig) *SecurityLayer {
./pkg/intelligence/security.go-	return &SecurityLayer{
./pkg/intelligence/security.go-		piiDetector:    NewPIIDetector(),
./pkg/intelligence/security.go-		secretScanner:  NewSecretScanner(),
./pkg/intelligence/security.go-		dataClassifier: NewDataClassifier(),
./pkg/intelligence/security.go-		encryptor:      NewEncryptor(config.EncryptionKey),
./pkg/intelligence/security.go-		config:         config,
./pkg/intelligence/security.go-	}
./pkg/intelligence/security.go-}
./pkg/intelligence/security.go-
./pkg/intelligence/security.go-// ValidateContent performs security validation on content
./pkg/intelligence/security.go-func (s *SecurityLayer) ValidateContent(ctx context.Context, content []byte) (*SecurityValidation, error) {
./pkg/intelligence/security.go-	validation := &SecurityValidation{
./pkg/intelligence/security.go-		ID:        uuid.New(),
./pkg/intelligence/security.go-		Timestamp: timeNow(),
./pkg/intelligence/security.go-		Passed:    true,
./pkg/intelligence/security.go-	}
./pkg/intelligence/security.go-
./pkg/intelligence/security.go-	// Check for PII
./pkg/intelligence/security.go-	if s.config.EnablePIIDetection {
./pkg/intelligence/security.go-		piiResults := s.piiDetector.Detect(content)
./pkg/intelligence/security.go-		validation.PIIDetected = len(piiResults) > 0
./pkg/intelligence/security.go-		validation.PIITypes = piiResults
./pkg/intelligence/security.go-
./pkg/intelligence/security.go-		if validation.PIIDetected && s.config.RedactPII {
./pkg/intelligence/security.go-			content = s.piiDetector.Redact(content, piiResults)
./pkg/intelligence/security.go-			validation.ContentRedacted = true
./pkg/intelligence/security.go-		}
./pkg/intelligence/security.go-	}
./pkg/intelligence/security.go-
./pkg/intelligence/security.go-	// Check for secrets
./pkg/intelligence/security.go-	if s.config.EnableSecretScanning {
./pkg/intelligence/security.go-		secrets := s.secretScanner.Scan(content)
./pkg/intelligence/security.go-		validation.SecretsDetected = len(secrets) > 0
./pkg/intelligence/security.go-		validation.SecretTypes = secrets
./pkg/intelligence/security.go-
./pkg/intelligence/security.go-		if validation.SecretsDetected && s.config.BlockOnSecrets {
./pkg/intelligence/security.go-			validation.Passed = false
./pkg/intelligence/security.go-			validation.BlockReason = "Secrets detected in content"
--
./pkg/intelligence/integration.go:type IntegrationConfig struct {
./pkg/intelligence/integration.go-	// Feature flags
./pkg/intelligence/integration.go-	AutoEmbedding       bool
./pkg/intelligence/integration.go-	IntelligenceEnabled bool
./pkg/intelligence/integration.go-	SecurityChecks      bool
./pkg/intelligence/integration.go-	CostTracking        bool
./pkg/intelligence/integration.go-
./pkg/intelligence/integration.go-	// Execution modes
./pkg/intelligence/integration.go-	DefaultMode    ExecutionMode
./pkg/intelligence/integration.go-	AsyncThreshold int // Use async for results > this size
./pkg/intelligence/integration.go-
./pkg/intelligence/integration.go-	// Performance
./pkg/intelligence/integration.go-	CacheEnabled    bool
./pkg/intelligence/integration.go-	BatchingEnabled bool
./pkg/intelligence/integration.go-}
./pkg/intelligence/integration.go-
./pkg/intelligence/integration.go-// NewDynamicToolsIntegration creates the integration layer
./pkg/intelligence/integration.go-func NewDynamicToolsIntegration(
./pkg/intelligence/integration.go-	config IntegrationConfig,
./pkg/intelligence/integration.go-	deps IntegrationDependencies,
./pkg/intelligence/integration.go-) (*DynamicToolsIntegration, error) {
./pkg/intelligence/integration.go-	// Create execution service if intelligence is enabled
./pkg/intelligence/integration.go-	var executionService *ResilientExecutionService
./pkg/intelligence/integration.go-	if config.IntelligenceEnabled {
./pkg/intelligence/integration.go-		serviceConfig := &ServiceConfig{
./pkg/intelligence/integration.go-			DefaultMode:         config.DefaultMode,
./pkg/intelligence/integration.go-			EnableAsyncFallback: true,
./pkg/intelligence/integration.go-			MaxConcurrency:      10,
./pkg/intelligence/integration.go-			TimeoutSeconds:      30,
./pkg/intelligence/integration.go-			CacheEnabled:        config.CacheEnabled,
./pkg/intelligence/integration.go-			CacheTTL:            5 * time.Minute,
./pkg/intelligence/integration.go-		}
./pkg/intelligence/integration.go-
./pkg/intelligence/integration.go-		serviceDeps := ServiceDependencies{
./pkg/intelligence/integration.go-			ToolExecutor:     deps.ToolExecutor,
./pkg/intelligence/integration.go-			ContentAnalyzer:  deps.ContentAnalyzer,
./pkg/intelligence/integration.go-			EmbeddingService: deps.EmbeddingService,
./pkg/intelligence/integration.go-			SemanticGraph:    deps.SemanticGraph,
./pkg/intelligence/integration.go-			DB:               deps.DB,
./pkg/intelligence/integration.go-			Cache:            deps.CacheService,
./pkg/intelligence/integration.go-			EventStore:       deps.EventStore,
./pkg/intelligence/integration.go-			Logger:           deps.Logger,
./pkg/intelligence/integration.go-		}
./pkg/intelligence/integration.go-
./pkg/intelligence/integration.go-		var err error
./pkg/intelligence/integration.go-		executionService, err = NewResilientExecutionService(serviceConfig, serviceDeps)
./pkg/intelligence/integration.go-		if err != nil {
./pkg/intelligence/integration.go-			return nil, fmt.Errorf("failed to create execution service: %w", err)
./pkg/intelligence/integration.go-		}
./pkg/intelligence/integration.go-	}
./pkg/intelligence/integration.go-
--
./pkg/intelligence/dependencies.go:type BatchProcessorConfig struct {
./pkg/intelligence/dependencies.go-	BatchSize    int
./pkg/intelligence/dependencies.go-	BatchTimeout time.Duration
./pkg/intelligence/dependencies.go-	MaxWait      time.Duration
./pkg/intelligence/dependencies.go-	Logger       observability.Logger
./pkg/intelligence/dependencies.go-}
./pkg/intelligence/dependencies.go-
./pkg/intelligence/dependencies.go-type Prefetcher struct{}
./pkg/intelligence/dependencies.go-
./pkg/intelligence/dependencies.go-func NewPrefetcher(config PrefetcherConfig) *Prefetcher {
./pkg/intelligence/dependencies.go-	return &Prefetcher{}
./pkg/intelligence/dependencies.go-}
./pkg/intelligence/dependencies.go-
./pkg/intelligence/dependencies.go:type PrefetcherConfig struct {
./pkg/intelligence/dependencies.go-	Workers   int
./pkg/intelligence/dependencies.go-	Threshold float64
./pkg/intelligence/dependencies.go-	Logger    observability.Logger
./pkg/intelligence/dependencies.go-}
--
./pkg/intelligence/performance.go:type PerformanceConfig struct {
./pkg/intelligence/performance.go-	// Cache settings
./pkg/intelligence/performance.go-	L1CacheSize int
./pkg/intelligence/performance.go-	L2CacheTTL  time.Duration
./pkg/intelligence/performance.go-	CacheWarmup bool
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	// Batching settings
./pkg/intelligence/performance.go-	BatchSize    int
./pkg/intelligence/performance.go-	BatchTimeout time.Duration
./pkg/intelligence/performance.go-	MaxBatchWait time.Duration
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	// Connection pool settings
./pkg/intelligence/performance.go-	DBMaxConns     int
./pkg/intelligence/performance.go-	DBMaxIdleConns int
./pkg/intelligence/performance.go-	RedisPoolSize  int
./pkg/intelligence/performance.go-	HTTPMaxConns   int
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	// Prefetch settings
./pkg/intelligence/performance.go-	PrefetchEnabled   bool
./pkg/intelligence/performance.go-	PrefetchThreshold float64 // 0.8 = prefetch when 80% likely
./pkg/intelligence/performance.go-	PrefetchWorkers   int
./pkg/intelligence/performance.go-}
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-// CacheConfig defines cache behavior
./pkg/intelligence/performance.go:type CacheConfig struct {
./pkg/intelligence/performance.go-	EnableL1         bool
./pkg/intelligence/performance.go-	EnableL2         bool
./pkg/intelligence/performance.go-	TTL              time.Duration
./pkg/intelligence/performance.go-	MaxSize          int
./pkg/intelligence/performance.go-	EvictionPolicy   string // "lru", "lfu", "arc"
./pkg/intelligence/performance.go-	CompressionLevel int    // 0-9
./pkg/intelligence/performance.go-}
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-// NewPerformanceOptimizer creates a performance optimization layer
./pkg/intelligence/performance.go-func NewPerformanceOptimizer(config PerformanceConfig, deps OptimizationDependencies) (*PerformanceOptimizer, error) {
./pkg/intelligence/performance.go-	// Create L1 cache
./pkg/intelligence/performance.go-	l1Cache, err := lru.New[string, CachedItem](config.L1CacheSize)
./pkg/intelligence/performance.go-	if err != nil {
./pkg/intelligence/performance.go-		return nil, fmt.Errorf("failed to create L1 cache: %w", err)
./pkg/intelligence/performance.go-	}
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	// Create batch processor
./pkg/intelligence/performance.go-	batchProcessor := NewBatchProcessor(BatchProcessorConfig{
./pkg/intelligence/performance.go-		BatchSize:    config.BatchSize,
./pkg/intelligence/performance.go-		BatchTimeout: config.BatchTimeout,
./pkg/intelligence/performance.go-		MaxWait:      config.MaxBatchWait,
./pkg/intelligence/performance.go-		Logger:       deps.Logger,
./pkg/intelligence/performance.go-	})
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	// Create prefetcher
./pkg/intelligence/performance.go-	prefetcher := NewPrefetcher(PrefetcherConfig{
./pkg/intelligence/performance.go-		Workers:   config.PrefetchWorkers,
./pkg/intelligence/performance.go-		Threshold: config.PrefetchThreshold,
./pkg/intelligence/performance.go-		Logger:    deps.Logger,
./pkg/intelligence/performance.go-	})
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	optimizer := &PerformanceOptimizer{
./pkg/intelligence/performance.go-		l1Cache:        l1Cache,
./pkg/intelligence/performance.go-		l2Cache:        deps.RedisClient,
./pkg/intelligence/performance.go-		cacheConfig:    deps.CacheConfig,
./pkg/intelligence/performance.go-		batchProcessor: batchProcessor,
./pkg/intelligence/performance.go-		batchQueue:     make(chan BatchItem, config.BatchSize*10),
./pkg/intelligence/performance.go-		dbPool:         deps.DBPool,
./pkg/intelligence/performance.go-		redisPool:      deps.RedisClient,
./pkg/intelligence/performance.go-		httpPool:       NewHTTPConnectionPool(config.HTTPMaxConns),
./pkg/intelligence/performance.go-		prefetcher:     prefetcher,
./pkg/intelligence/performance.go-		prefetchQueue:  make(chan PrefetchRequest, 100),
./pkg/intelligence/performance.go-		config:         config,
./pkg/intelligence/performance.go-		logger:         deps.Logger,
./pkg/intelligence/performance.go-	}
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	// Start background workers
./pkg/intelligence/performance.go-	optimizer.startWorkers()
./pkg/intelligence/performance.go-
./pkg/intelligence/performance.go-	// Warm up cache if enabled
--
./pkg/intelligence/cost_control.go:type CostControlConfig struct {
./pkg/intelligence/cost_control.go-	// Global limits
./pkg/intelligence/cost_control.go-	GlobalDailyLimit   float64
./pkg/intelligence/cost_control.go-	GlobalMonthlyLimit float64
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	// Alert thresholds
./pkg/intelligence/cost_control.go-	WarningThreshold  float64 // 0.8 = alert at 80% of budget
./pkg/intelligence/cost_control.go-	CriticalThreshold float64 // 0.95 = critical at 95%
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	// Rate limits
./pkg/intelligence/cost_control.go-	EnableRateLimiting bool
./pkg/intelligence/cost_control.go-	CostPerMinute      float64 // Max cost per minute per tenant
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	// Tracking
./pkg/intelligence/cost_control.go-	TrackingGranularity string // "execution", "hourly", "daily"
./pkg/intelligence/cost_control.go-	RetentionDays       int
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	// Enforcement
./pkg/intelligence/cost_control.go-	StrictEnforcement  bool // Block when budget exceeded
./pkg/intelligence/cost_control.go-	GracePeriodMinutes int  // Allow temporary overages
./pkg/intelligence/cost_control.go-}
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-// NewCostController creates a new cost controller
./pkg/intelligence/cost_control.go-func NewCostController(config CostControlConfig, deps CostControlDependencies) (*CostController, error) {
./pkg/intelligence/cost_control.go-	controller := &CostController{
./pkg/intelligence/cost_control.go-		costRates:      NewCostRateTable(),
./pkg/intelligence/cost_control.go-		globalLimit:    decimal.NewFromFloat(config.GlobalDailyLimit),
./pkg/intelligence/cost_control.go-		warningPercent: config.WarningThreshold,
./pkg/intelligence/cost_control.go-		db:             deps.DB,
./pkg/intelligence/cost_control.go-		repository:     deps.Repository,
./pkg/intelligence/cost_control.go-		config:         config,
./pkg/intelligence/cost_control.go-		logger:         deps.Logger,
./pkg/intelligence/cost_control.go-		alertChan:      make(chan CostAlert, 100),
./pkg/intelligence/cost_control.go-	}
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	// Initialize total spend
./pkg/intelligence/cost_control.go-	controller.totalSpend.Store(decimal.Zero)
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	// Load tenant budgets
./pkg/intelligence/cost_control.go-	if err := controller.loadTenantBudgets(context.Background()); err != nil {
./pkg/intelligence/cost_control.go-		return nil, fmt.Errorf("failed to load tenant budgets: %w", err)
./pkg/intelligence/cost_control.go-	}
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	// Start background workers
./pkg/intelligence/cost_control.go-	controller.startWorkers()
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-	return controller, nil
./pkg/intelligence/cost_control.go-}
./pkg/intelligence/cost_control.go-
./pkg/intelligence/cost_control.go-// CheckBudget checks if an operation can proceed within budget
./pkg/intelligence/cost_control.go-func (c *CostController) CheckBudget(ctx context.Context, req CostCheckRequest) (*CostCheckResponse, error) {
--
./pkg/config/config.go:type Config struct {
./pkg/config/config.go-	API         APIConfig              `mapstructure:"api"`
./pkg/config/config.go-	Cache       interface{}            `mapstructure:"cache"`
./pkg/config/config.go-	Database    DatabaseConfig         `mapstructure:"database"`
./pkg/config/config.go-	Engine      CoreConfig             `mapstructure:"engine"`
./pkg/config/config.go-	Metrics     interface{}            `mapstructure:"metrics"`
./pkg/config/config.go-	AWS         interface{}            `mapstructure:"aws"`
./pkg/config/config.go-	Environment string                 `mapstructure:"environment"`
./pkg/config/config.go-	Adapters    map[string]interface{} `mapstructure:"adapters"`
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// APIConfig defines the API server configuration
./pkg/config/config.go:type APIConfig struct {
./pkg/config/config.go-	ListenAddress  string                 `mapstructure:"listen_address"`
./pkg/config/config.go-	BaseURL        string                 `mapstructure:"base_url"`
./pkg/config/config.go-	TLSCertFile    string                 `mapstructure:"tls_cert_file"`
./pkg/config/config.go-	TLSKeyFile     string                 `mapstructure:"tls_key_file"`
./pkg/config/config.go-	CORSAllowed    string                 `mapstructure:"cors_allowed"`
./pkg/config/config.go-	RateLimit      map[string]interface{} `mapstructure:"rate_limit"`
./pkg/config/config.go-	RequestTimeout int                    `mapstructure:"request_timeout"`
./pkg/config/config.go-	ReadTimeout    interface{}            `mapstructure:"read_timeout"`
./pkg/config/config.go-	WriteTimeout   interface{}            `mapstructure:"write_timeout"`
./pkg/config/config.go-	IdleTimeout    interface{}            `mapstructure:"idle_timeout"`
./pkg/config/config.go-	EnableCORS     bool                   `mapstructure:"enable_cors"`
./pkg/config/config.go-	EnableSwagger  bool                   `mapstructure:"enable_swagger"`
./pkg/config/config.go-	Auth           map[string]interface{} `mapstructure:"auth"`
./pkg/config/config.go-	Webhook        map[string]interface{} `mapstructure:"webhook"`
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// CoreConfig defines the engine core configuration
./pkg/config/config.go:type CoreConfig struct {
./pkg/config/config.go-	EventBufferSize  int         `mapstructure:"event_buffer_size"`
./pkg/config/config.go-	ConcurrencyLimit int         `mapstructure:"concurrency_limit"`
./pkg/config/config.go-	EventTimeout     interface{} `mapstructure:"event_timeout"`
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// DatabaseConfig holds configuration for the database
./pkg/config/config.go:type DatabaseConfig struct {
./pkg/config/config.go-	Driver        string      `mapstructure:"driver"`
./pkg/config/config.go-	DSN           string      `mapstructure:"dsn"`
./pkg/config/config.go-	Host          string      `mapstructure:"host"`
./pkg/config/config.go-	Port          int         `mapstructure:"port"`
./pkg/config/config.go-	Database      string      `mapstructure:"database"`
./pkg/config/config.go-	Username      string      `mapstructure:"username"`
./pkg/config/config.go-	Password      string      `mapstructure:"password"`
./pkg/config/config.go-	MaxOpenConns  int         `mapstructure:"max_open_conns"`
./pkg/config/config.go-	MaxIdleConns  int         `mapstructure:"max_idle_conns"`
./pkg/config/config.go-	UseIAM        bool        `mapstructure:"use_iam"`
./pkg/config/config.go-	SSLMode       string      `mapstructure:"ssl_mode"`
./pkg/config/config.go-	SSLRootCert   string      `mapstructure:"ssl_root_cert"`
./pkg/config/config.go-	SSLCert       string      `mapstructure:"ssl_cert"`
./pkg/config/config.go-	SSLKey        string      `mapstructure:"ssl_key"`
./pkg/config/config.go-	SearchPath    string      `mapstructure:"search_path"`
./pkg/config/config.go-	MigrationsDir string      `mapstructure:"migrations_dir"`
./pkg/config/config.go-	Vector        interface{} `mapstructure:"vector"`
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// Function stubs for backward compatibility
./pkg/config/config.go-
./pkg/config/config.go-// Load loads configuration from file and environment variables
./pkg/config/config.go-func Load() (*Config, error) {
./pkg/config/config.go-	// This is a stub that will be overridden by the real implementation
./pkg/config/config.go-	return nil, nil
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// IsProduction returns true if the environment is production
./pkg/config/config.go-func (c *Config) IsProduction() bool {
./pkg/config/config.go-	return c.Environment == "prod" || c.Environment == "production"
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// IsDevelopment returns true if the environment is development
./pkg/config/config.go-func (c *Config) IsDevelopment() bool {
./pkg/config/config.go-	return c.Environment == "dev" || c.Environment == "development"
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// IsStaging returns true if the environment is staging
./pkg/config/config.go-func (c *Config) IsStaging() bool {
./pkg/config/config.go-	return c.Environment == "staging" || c.Environment == "stage"
./pkg/config/config.go-}
./pkg/config/config.go-
./pkg/config/config.go-// GetListenPort returns the port number the API should listen on
./pkg/config/config.go-func (c *Config) GetListenPort() int {
./pkg/config/config.go-	// Default port
./pkg/config/config.go-	return 8080
./pkg/config/config.go-}
--
./pkg/security/tls/config.go:type Config struct {
./pkg/security/tls/config.go-	Enabled            bool     `mapstructure:"enabled" json:"enabled"`
./pkg/security/tls/config.go-	MinVersion         string   `mapstructure:"min_version" json:"min_version"`
./pkg/security/tls/config.go-	MaxVersion         string   `mapstructure:"max_version" json:"max_version"`
./pkg/security/tls/config.go-	CipherSuites       []string `mapstructure:"cipher_suites" json:"cipher_suites"`
./pkg/security/tls/config.go-	InsecureSkipVerify bool     `mapstructure:"insecure_skip_verify" json:"insecure_skip_verify"`
./pkg/security/tls/config.go-	VerifyCertificates bool     `mapstructure:"verify_certificates" json:"verify_certificates"`
./pkg/security/tls/config.go-	ServerName         string   `mapstructure:"server_name" json:"server_name"`
./pkg/security/tls/config.go-	ClientAuth         string   `mapstructure:"client_auth" json:"client_auth"`
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-	// Certificate files
./pkg/security/tls/config.go-	CertFile     string `mapstructure:"cert_file" json:"cert_file"`
./pkg/security/tls/config.go-	KeyFile      string `mapstructure:"key_file" json:"key_file"`
./pkg/security/tls/config.go-	CAFile       string `mapstructure:"ca_file" json:"ca_file"`
./pkg/security/tls/config.go-	ClientCAFile string `mapstructure:"client_ca_file" json:"client_ca_file"`
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-	// Performance optimizations
./pkg/security/tls/config.go-	SessionTickets    bool `mapstructure:"session_tickets" json:"session_tickets"`
./pkg/security/tls/config.go-	SessionCacheSize  int  `mapstructure:"session_cache_size" json:"session_cache_size"`
./pkg/security/tls/config.go-	Enable0RTT        bool `mapstructure:"enable_0rtt" json:"enable_0rtt"`
./pkg/security/tls/config.go-	ReuseSessionState bool `mapstructure:"reuse_session_state" json:"reuse_session_state"`
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-	// Connection optimization
./pkg/security/tls/config.go-	KeepAlive        bool   `mapstructure:"keepalive" json:"keepalive"`
./pkg/security/tls/config.go-	KeepAliveTimeout string `mapstructure:"keepalive_timeout" json:"keepalive_timeout"`
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-	// Monitoring
./pkg/security/tls/config.go-	LogHandshakeDuration bool `mapstructure:"log_handshake_duration" json:"log_handshake_duration"`
./pkg/security/tls/config.go-	TrackCipherUsage     bool `mapstructure:"track_cipher_usage" json:"track_cipher_usage"`
./pkg/security/tls/config.go-}
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-// DefaultConfig returns a secure default TLS configuration
./pkg/security/tls/config.go-func DefaultConfig() *Config {
./pkg/security/tls/config.go-	return &Config{
./pkg/security/tls/config.go-		Enabled:            true,
./pkg/security/tls/config.go-		MinVersion:         DefaultMinVersion,
./pkg/security/tls/config.go-		VerifyCertificates: true,
./pkg/security/tls/config.go-		SessionTickets:     true,
./pkg/security/tls/config.go-		SessionCacheSize:   1000,
./pkg/security/tls/config.go-		ReuseSessionState:  true,
./pkg/security/tls/config.go-		KeepAlive:          true,
./pkg/security/tls/config.go-		KeepAliveTimeout:   "120s",
./pkg/security/tls/config.go-	}
./pkg/security/tls/config.go-}
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-// BuildTLSConfig creates a standard crypto/tls.Config from our configuration
./pkg/security/tls/config.go-func (c *Config) BuildTLSConfig() (*tls.Config, error) {
./pkg/security/tls/config.go-	if !c.Enabled {
./pkg/security/tls/config.go-		return nil, nil
./pkg/security/tls/config.go-	}
./pkg/security/tls/config.go-
--
./pkg/security/tls/config.go:type PerformanceConfig struct {
./pkg/security/tls/config.go-	// Connection pooling
./pkg/security/tls/config.go-	MaxIdleConns        int           `mapstructure:"max_idle_conns"`
./pkg/security/tls/config.go-	MaxIdleConnsPerHost int           `mapstructure:"max_idle_conns_per_host"`
./pkg/security/tls/config.go-	IdleConnTimeout     time.Duration `mapstructure:"idle_conn_timeout"`
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-	// TLS session management
./pkg/security/tls/config.go-	SessionCacheSize int           `mapstructure:"session_cache_size"`
./pkg/security/tls/config.go-	SessionTimeout   time.Duration `mapstructure:"session_timeout"`
./pkg/security/tls/config.go-}
./pkg/security/tls/config.go-
./pkg/security/tls/config.go-// DefaultPerformanceConfig returns optimized performance settings
./pkg/security/tls/config.go-func DefaultPerformanceConfig() *PerformanceConfig {
./pkg/security/tls/config.go-	return &PerformanceConfig{
./pkg/security/tls/config.go-		MaxIdleConns:        100,
./pkg/security/tls/config.go-		MaxIdleConnsPerHost: 10,
./pkg/security/tls/config.go-		IdleConnTimeout:     90 * time.Second,
./pkg/security/tls/config.go-		SessionCacheSize:    1000,
./pkg/security/tls/config.go-		SessionTimeout:      24 * time.Hour,
./pkg/security/tls/config.go-	}
./pkg/security/tls/config.go-}
--
./pkg/redis/streams_client.go:type StreamsConfig struct {
./pkg/redis/streams_client.go-	// Connection settings
./pkg/redis/streams_client.go-	Addresses    []string      `yaml:"addresses" json:"addresses"`
./pkg/redis/streams_client.go-	Password     string        `yaml:"password" json:"password"`
./pkg/redis/streams_client.go-	DB           int           `yaml:"db" json:"db"`
./pkg/redis/streams_client.go-	MaxRetries   int           `yaml:"max_retries" json:"max_retries"`
./pkg/redis/streams_client.go-	RetryBackoff time.Duration `yaml:"retry_backoff" json:"retry_backoff"`
./pkg/redis/streams_client.go-
./pkg/redis/streams_client.go-	// TLS settings
./pkg/redis/streams_client.go-	TLSEnabled bool        `yaml:"tls_enabled" json:"tls_enabled"`
./pkg/redis/streams_client.go-	TLSConfig  *tls.Config `yaml:"-" json:"-"`
./pkg/redis/streams_client.go-
./pkg/redis/streams_client.go-	// Pool settings
./pkg/redis/streams_client.go-	PoolSize     int           `yaml:"pool_size" json:"pool_size"`
./pkg/redis/streams_client.go-	MinIdleConns int           `yaml:"min_idle_conns" json:"min_idle_conns"`
./pkg/redis/streams_client.go-	MaxConnAge   time.Duration `yaml:"max_conn_age" json:"max_conn_age"`
./pkg/redis/streams_client.go-	PoolTimeout  time.Duration `yaml:"pool_timeout" json:"pool_timeout"`
./pkg/redis/streams_client.go-	IdleTimeout  time.Duration `yaml:"idle_timeout" json:"idle_timeout"`
./pkg/redis/streams_client.go-
./pkg/redis/streams_client.go-	// Cluster settings
./pkg/redis/streams_client.go-	ClusterEnabled bool `yaml:"cluster_enabled" json:"cluster_enabled"`
./pkg/redis/streams_client.go-	ReadOnly       bool `yaml:"read_only" json:"read_only"`
./pkg/redis/streams_client.go-	RouteByLatency bool `yaml:"route_by_latency" json:"route_by_latency"`
./pkg/redis/streams_client.go-
./pkg/redis/streams_client.go-	// Sentinel settings
./pkg/redis/streams_client.go-	SentinelEnabled  bool     `yaml:"sentinel_enabled" json:"sentinel_enabled"`
./pkg/redis/streams_client.go-	MasterName       string   `yaml:"master_name" json:"master_name"`
./pkg/redis/streams_client.go-	SentinelAddrs    []string `yaml:"sentinel_addrs" json:"sentinel_addrs"`
./pkg/redis/streams_client.go-	SentinelPassword string   `yaml:"sentinel_password" json:"sentinel_password"`
./pkg/redis/streams_client.go-}
./pkg/redis/streams_client.go-
./pkg/redis/streams_client.go-// DefaultConfig returns a default configuration for Redis Streams
./pkg/redis/streams_client.go-func DefaultConfig() *StreamsConfig {
./pkg/redis/streams_client.go-	return &StreamsConfig{
./pkg/redis/streams_client.go-		Addresses:      []string{"localhost:6379"},
./pkg/redis/streams_client.go-		MaxRetries:     3,
./pkg/redis/streams_client.go-		RetryBackoff:   100 * time.Millisecond,
./pkg/redis/streams_client.go-		PoolSize:       10,
./pkg/redis/streams_client.go-		MinIdleConns:   5,
./pkg/redis/streams_client.go-		MaxConnAge:     30 * time.Minute,
./pkg/redis/streams_client.go-		PoolTimeout:    4 * time.Second,
./pkg/redis/streams_client.go-		IdleTimeout:    5 * time.Minute,
./pkg/redis/streams_client.go-		RouteByLatency: true,
./pkg/redis/streams_client.go-	}
./pkg/redis/streams_client.go-}
./pkg/redis/streams_client.go-
./pkg/redis/streams_client.go-// StreamsClient provides Redis Streams functionality with connection pooling
./pkg/redis/streams_client.go-type StreamsClient struct {
./pkg/redis/streams_client.go-	client redis.UniversalClient
./pkg/redis/streams_client.go-	config *StreamsConfig
./pkg/redis/streams_client.go-	logger observability.Logger
--
./pkg/redis/circuit_breaker.go:type CircuitBreakerConfig struct {
./pkg/redis/circuit_breaker.go-	// FailureThreshold is the number of failures before opening the circuit
./pkg/redis/circuit_breaker.go-	FailureThreshold int
./pkg/redis/circuit_breaker.go-	// SuccessThreshold is the number of successes in half-open state before closing
./pkg/redis/circuit_breaker.go-	SuccessThreshold int
./pkg/redis/circuit_breaker.go-	// Timeout is how long to wait before attempting to close the circuit
./pkg/redis/circuit_breaker.go-	Timeout time.Duration
./pkg/redis/circuit_breaker.go-	// MaxTimeout is the maximum timeout after repeated failures
./pkg/redis/circuit_breaker.go-	MaxTimeout time.Duration
./pkg/redis/circuit_breaker.go-	// TimeoutMultiplier increases timeout after each failure
./pkg/redis/circuit_breaker.go-	TimeoutMultiplier float64
./pkg/redis/circuit_breaker.go-}
./pkg/redis/circuit_breaker.go-
./pkg/redis/circuit_breaker.go-// DefaultCircuitBreakerConfig returns default circuit breaker configuration
./pkg/redis/circuit_breaker.go-func DefaultCircuitBreakerConfig() *CircuitBreakerConfig {
./pkg/redis/circuit_breaker.go-	return &CircuitBreakerConfig{
./pkg/redis/circuit_breaker.go-		FailureThreshold:  5,
./pkg/redis/circuit_breaker.go-		SuccessThreshold:  2,
./pkg/redis/circuit_breaker.go-		Timeout:           30 * time.Second,
./pkg/redis/circuit_breaker.go-		MaxTimeout:        5 * time.Minute,
./pkg/redis/circuit_breaker.go-		TimeoutMultiplier: 2.0,
./pkg/redis/circuit_breaker.go-	}
./pkg/redis/circuit_breaker.go-}
./pkg/redis/circuit_breaker.go-
./pkg/redis/circuit_breaker.go-// CircuitBreaker implements the circuit breaker pattern for Redis operations
./pkg/redis/circuit_breaker.go-type CircuitBreaker struct {
./pkg/redis/circuit_breaker.go-	config *CircuitBreakerConfig
./pkg/redis/circuit_breaker.go-	logger observability.Logger
./pkg/redis/circuit_breaker.go-
./pkg/redis/circuit_breaker.go-	mu              sync.RWMutex
./pkg/redis/circuit_breaker.go-	state           CircuitState
./pkg/redis/circuit_breaker.go-	failures        int
./pkg/redis/circuit_breaker.go-	successes       int
./pkg/redis/circuit_breaker.go-	lastFailureTime time.Time
./pkg/redis/circuit_breaker.go-	currentTimeout  time.Duration
./pkg/redis/circuit_breaker.go-	generation      uint64 // Prevents race conditions during state transitions
./pkg/redis/circuit_breaker.go-}
./pkg/redis/circuit_breaker.go-
./pkg/redis/circuit_breaker.go-// NewCircuitBreaker creates a new circuit breaker
./pkg/redis/circuit_breaker.go-func NewCircuitBreaker(config *CircuitBreakerConfig, logger observability.Logger) *CircuitBreaker {
./pkg/redis/circuit_breaker.go-	if config == nil {
./pkg/redis/circuit_breaker.go-		config = DefaultCircuitBreakerConfig()
./pkg/redis/circuit_breaker.go-	}
./pkg/redis/circuit_breaker.go-
./pkg/redis/circuit_breaker.go-	return &CircuitBreaker{
./pkg/redis/circuit_breaker.go-		config:         config,
./pkg/redis/circuit_breaker.go-		logger:         logger,
./pkg/redis/circuit_breaker.go-		state:          StateClosed,
./pkg/redis/circuit_breaker.go-		currentTimeout: config.Timeout,
./pkg/redis/circuit_breaker.go-	}
./pkg/redis/circuit_breaker.go-}
--
./pkg/auth/auth.go:type ServiceConfig struct {
./pkg/auth/auth.go-	JWTSecret         string
./pkg/auth/auth.go-	JWTExpiration     time.Duration
./pkg/auth/auth.go-	APIKeyHeader      string
./pkg/auth/auth.go-	EnableAPIKeys     bool
./pkg/auth/auth.go-	EnableJWT         bool
./pkg/auth/auth.go-	CacheEnabled      bool
./pkg/auth/auth.go-	CacheTTL          time.Duration
./pkg/auth/auth.go-	MaxFailedAttempts int
./pkg/auth/auth.go-	LockoutDuration   time.Duration
./pkg/auth/auth.go-}
./pkg/auth/auth.go-
./pkg/auth/auth.go-// DefaultConfig returns the default configuration
./pkg/auth/auth.go-func DefaultConfig() *ServiceConfig {
./pkg/auth/auth.go-	return &ServiceConfig{
./pkg/auth/auth.go-		JWTExpiration:     24 * time.Hour,
./pkg/auth/auth.go-		APIKeyHeader:      "X-API-Key",
./pkg/auth/auth.go-		EnableAPIKeys:     true,
./pkg/auth/auth.go-		EnableJWT:         true,
./pkg/auth/auth.go-		CacheEnabled:      true,
./pkg/auth/auth.go-		CacheTTL:          5 * time.Minute,
./pkg/auth/auth.go-		MaxFailedAttempts: 5,
./pkg/auth/auth.go-		LockoutDuration:   15 * time.Minute,
./pkg/auth/auth.go-	}
./pkg/auth/auth.go-}
./pkg/auth/auth.go-
./pkg/auth/auth.go-// Service provides authentication services
./pkg/auth/auth.go-type Service struct {
./pkg/auth/auth.go-	config *ServiceConfig
./pkg/auth/auth.go-	db     *sqlx.DB
./pkg/auth/auth.go-	cache  cache.Cache
./pkg/auth/auth.go-	logger observability.Logger
./pkg/auth/auth.go-
./pkg/auth/auth.go-	// In-memory storage for development/testing
./pkg/auth/auth.go-	apiKeys map[string]*APIKey
./pkg/auth/auth.go-	mu      sync.RWMutex
./pkg/auth/auth.go-}
./pkg/auth/auth.go-
./pkg/auth/auth.go-// NewService creates a new auth service
./pkg/auth/auth.go-func NewService(config *ServiceConfig, db *sqlx.DB, cache cache.Cache, logger observability.Logger) *Service {
./pkg/auth/auth.go-	if config == nil {
./pkg/auth/auth.go-		config = DefaultConfig()
./pkg/auth/auth.go-	}
./pkg/auth/auth.go-
./pkg/auth/auth.go-	return &Service{
./pkg/auth/auth.go-		config:  config,
./pkg/auth/auth.go-		db:      db,
./pkg/auth/auth.go-		cache:   cache,
./pkg/auth/auth.go-		logger:  logger,
./pkg/auth/auth.go-		apiKeys: make(map[string]*APIKey),
./pkg/auth/auth.go-	}
--
./pkg/auth/config_types.go:type AuthSystemConfig struct {
./pkg/auth/config_types.go-	Service     *ServiceConfig
./pkg/auth/config_types.go-	RateLimiter *RateLimiterConfig
./pkg/auth/config_types.go-	APIKeys     map[string]APIKeySettings
./pkg/auth/config_types.go-}
./pkg/auth/config_types.go-
./pkg/auth/config_types.go-// TestRateLimiterConfig returns test-friendly defaults
./pkg/auth/config_types.go-func TestRateLimiterConfig() *RateLimiterConfig {
./pkg/auth/config_types.go-	return &RateLimiterConfig{
./pkg/auth/config_types.go-		Enabled:       true, // Enable rate limiting for tests
./pkg/auth/config_types.go-		MaxAttempts:   3,    // Lower for faster tests
./pkg/auth/config_types.go-		WindowSize:    1 * time.Minute,
./pkg/auth/config_types.go-		LockoutPeriod: 5 * time.Minute,
./pkg/auth/config_types.go-	}
./pkg/auth/config_types.go-}
--
./pkg/auth/factory.go:type FactoryConfig struct {
./pkg/auth/factory.go-	Mode             AuthMode
./pkg/auth/factory.go-	ProductionConfig *AuthConfig
./pkg/auth/factory.go-	Logger           observability.Logger
./pkg/auth/factory.go-	Tracer           observability.StartSpanFunc
./pkg/auth/factory.go-}
./pkg/auth/factory.go-
./pkg/auth/factory.go-// NewAuthorizer creates the appropriate authorizer based on configuration
./pkg/auth/factory.go-func NewAuthorizer(config FactoryConfig) (Authorizer, error) {
./pkg/auth/factory.go-	// Validate configuration
./pkg/auth/factory.go-	if config.Logger == nil {
./pkg/auth/factory.go-		return nil, errors.New("logger is required")
./pkg/auth/factory.go-	}
./pkg/auth/factory.go-
./pkg/auth/factory.go-	if config.Tracer == nil {
./pkg/auth/factory.go-		return nil, errors.New("tracer is required")
./pkg/auth/factory.go-	}
./pkg/auth/factory.go-
./pkg/auth/factory.go-	// Determine auth mode from environment if not explicitly set
./pkg/auth/factory.go-	if config.Mode == "" {
./pkg/auth/factory.go-		config.Mode = determineAuthMode()
./pkg/auth/factory.go-	}
./pkg/auth/factory.go-
./pkg/auth/factory.go-	// Log the auth mode with security implications
./pkg/auth/factory.go-	config.Logger.Info("Initializing authorization system", map[string]interface{}{
./pkg/auth/factory.go-		"mode":                  config.Mode,
./pkg/auth/factory.go-		"mcp_test_mode":         os.Getenv("MCP_TEST_MODE"),
./pkg/auth/factory.go-		"test_auth_enabled":     os.Getenv("TEST_AUTH_ENABLED"),
./pkg/auth/factory.go-		"environment":           os.Getenv("ENVIRONMENT"),
./pkg/auth/factory.go-		"security_implications": getSecurityImplications(config.Mode),
./pkg/auth/factory.go-	})
./pkg/auth/factory.go-
./pkg/auth/factory.go-	switch config.Mode {
./pkg/auth/factory.go-	case AuthModeProduction:
./pkg/auth/factory.go-		return createProductionAuthorizer(config)
./pkg/auth/factory.go-	case AuthModeTest:
./pkg/auth/factory.go-		return createTestAuthorizer(config)
./pkg/auth/factory.go-	default:
./pkg/auth/factory.go-		return nil, errors.Errorf("unknown auth mode: %s", config.Mode)
./pkg/auth/factory.go-	}
./pkg/auth/factory.go-}
./pkg/auth/factory.go-
./pkg/auth/factory.go-// determineAuthMode determines the auth mode from environment variables
./pkg/auth/factory.go-func determineAuthMode() AuthMode {
./pkg/auth/factory.go-	// Check if we're in test mode
./pkg/auth/factory.go-	if os.Getenv("MCP_TEST_MODE") == "true" && os.Getenv("TEST_AUTH_ENABLED") == "true" {
./pkg/auth/factory.go-		return AuthModeTest
./pkg/auth/factory.go-	}
./pkg/auth/factory.go-
./pkg/auth/factory.go-	// Default to production
./pkg/auth/factory.go-	return AuthModeProduction
--
./pkg/auth/rate_limiter.go:type RateLimiterConfig struct {
./pkg/auth/rate_limiter.go-	Enabled       bool          // Whether rate limiting is enabled
./pkg/auth/rate_limiter.go-	MaxAttempts   int           // Max attempts per window
./pkg/auth/rate_limiter.go-	WindowSize    time.Duration // Time window for attempts
./pkg/auth/rate_limiter.go-	LockoutPeriod time.Duration // Lockout duration after max attempts
./pkg/auth/rate_limiter.go-}
./pkg/auth/rate_limiter.go-
./pkg/auth/rate_limiter.go-// DefaultRateLimiterConfig returns sensible defaults
./pkg/auth/rate_limiter.go-func DefaultRateLimiterConfig() *RateLimiterConfig {
./pkg/auth/rate_limiter.go-	return &RateLimiterConfig{
./pkg/auth/rate_limiter.go-		Enabled:       true,
./pkg/auth/rate_limiter.go-		MaxAttempts:   5,
./pkg/auth/rate_limiter.go-		WindowSize:    1 * time.Minute,
./pkg/auth/rate_limiter.go-		LockoutPeriod: 15 * time.Minute,
./pkg/auth/rate_limiter.go-	}
./pkg/auth/rate_limiter.go-}
./pkg/auth/rate_limiter.go-
./pkg/auth/rate_limiter.go-// NewRateLimiter creates a new rate limiter
./pkg/auth/rate_limiter.go-func NewRateLimiter(cache cache.Cache, logger observability.Logger, config *RateLimiterConfig) *RateLimiter {
./pkg/auth/rate_limiter.go-	if config == nil {
./pkg/auth/rate_limiter.go-		config = DefaultRateLimiterConfig()
./pkg/auth/rate_limiter.go-	}
./pkg/auth/rate_limiter.go-
./pkg/auth/rate_limiter.go-	return &RateLimiter{
./pkg/auth/rate_limiter.go-		cache:         cache,
./pkg/auth/rate_limiter.go-		logger:        logger,
./pkg/auth/rate_limiter.go-		enabled:       config.Enabled,
./pkg/auth/rate_limiter.go-		maxAttempts:   config.MaxAttempts,
./pkg/auth/rate_limiter.go-		windowSize:    config.WindowSize,
./pkg/auth/rate_limiter.go-		lockoutPeriod: config.LockoutPeriod,
./pkg/auth/rate_limiter.go-	}
./pkg/auth/rate_limiter.go-}
./pkg/auth/rate_limiter.go-
./pkg/auth/rate_limiter.go-// CheckLimit checks if the identifier has exceeded rate limits
./pkg/auth/rate_limiter.go-func (rl *RateLimiter) CheckLimit(ctx context.Context, identifier string) error {
./pkg/auth/rate_limiter.go-	// If rate limiting is disabled, always allow
./pkg/auth/rate_limiter.go-	if !rl.enabled {
./pkg/auth/rate_limiter.go-		return nil
./pkg/auth/rate_limiter.go-	}
./pkg/auth/rate_limiter.go-
./pkg/auth/rate_limiter.go-	key := fmt.Sprintf("auth:ratelimit:%s", identifier)
./pkg/auth/rate_limiter.go-
./pkg/auth/rate_limiter.go-	// Try cache first
./pkg/auth/rate_limiter.go-	if rl.cache != nil {
./pkg/auth/rate_limiter.go-		return rl.checkCacheLimit(ctx, key)
./pkg/auth/rate_limiter.go-	}
./pkg/auth/rate_limiter.go-
./pkg/auth/rate_limiter.go-	// Fallback to local memory
./pkg/auth/rate_limiter.go-	return rl.checkLocalLimit(identifier)
./pkg/auth/rate_limiter.go-}
./pkg/auth/rate_limiter.go-
--
./pkg/auth/production_authorizer.go:type AuthConfig struct {
./pkg/auth/production_authorizer.go-	ModelPath     string
./pkg/auth/production_authorizer.go-	PolicyPath    string
./pkg/auth/production_authorizer.go-	DBDriver      string
./pkg/auth/production_authorizer.go-	DBSource      string
./pkg/auth/production_authorizer.go-	Cache         cache.Cache
./pkg/auth/production_authorizer.go-	Logger        observability.Logger
./pkg/auth/production_authorizer.go-	Metrics       observability.MetricsClient
./pkg/auth/production_authorizer.go-	Tracer        observability.StartSpanFunc
./pkg/auth/production_authorizer.go-	AuditLogger   *AuditLogger
./pkg/auth/production_authorizer.go-	CacheEnabled  bool
./pkg/auth/production_authorizer.go-	CacheDuration time.Duration
./pkg/auth/production_authorizer.go-}
./pkg/auth/production_authorizer.go-
./pkg/auth/production_authorizer.go-// AuthRequest represents an authorization request
./pkg/auth/production_authorizer.go-type AuthRequest struct {
./pkg/auth/production_authorizer.go-	Subject  string                 `json:"subject"`
./pkg/auth/production_authorizer.go-	Resource string                 `json:"resource"`
./pkg/auth/production_authorizer.go-	Action   string                 `json:"action"`
./pkg/auth/production_authorizer.go-	Tenant   string                 `json:"tenant"`
./pkg/auth/production_authorizer.go-	Context  map[string]interface{} `json:"context,omitempty"`
./pkg/auth/production_authorizer.go-}
./pkg/auth/production_authorizer.go-
./pkg/auth/production_authorizer.go-// Policy represents an authorization policy
./pkg/auth/production_authorizer.go-type Policy struct {
./pkg/auth/production_authorizer.go-	Subject  string `json:"subject"`
./pkg/auth/production_authorizer.go-	Resource string `json:"resource"`
./pkg/auth/production_authorizer.go-	Action   string `json:"action"`
./pkg/auth/production_authorizer.go-	Effect   string `json:"effect,omitempty"`
./pkg/auth/production_authorizer.go-	Tenant   string `json:"tenant,omitempty"`
./pkg/auth/production_authorizer.go-}
./pkg/auth/production_authorizer.go-
./pkg/auth/production_authorizer.go-// NewProductionAuthorizer creates a production authorizer
./pkg/auth/production_authorizer.go-func NewProductionAuthorizer(config AuthConfig) (*ProductionAuthorizer, error) {
./pkg/auth/production_authorizer.go-	// Validate configuration
./pkg/auth/production_authorizer.go-	if config.Logger == nil {
./pkg/auth/production_authorizer.go-		return nil, errors.New("logger is required")
./pkg/auth/production_authorizer.go-	}
./pkg/auth/production_authorizer.go-	if config.Metrics == nil {
./pkg/auth/production_authorizer.go-		return nil, errors.New("metrics is required")
./pkg/auth/production_authorizer.go-	}
./pkg/auth/production_authorizer.go-	if config.Cache == nil && config.CacheEnabled {
./pkg/auth/production_authorizer.go-		return nil, errors.New("cache is required when cache is enabled")
./pkg/auth/production_authorizer.go-	}
./pkg/auth/production_authorizer.go-	if config.AuditLogger == nil {
./pkg/auth/production_authorizer.go-		return nil, errors.New("audit logger is required")
./pkg/auth/production_authorizer.go-	}
./pkg/auth/production_authorizer.go-
./pkg/auth/production_authorizer.go-	// Initialize in-memory storage
./pkg/auth/production_authorizer.go-	roleBindings := make(map[string][]string)
./pkg/auth/production_authorizer.go-	roles := make(map[string]bool)
--
./pkg/auth/config_keys.go:type APIKeyConfig struct {
./pkg/auth/config_keys.go-	// Development keys (only loaded in dev/test environments)
./pkg/auth/config_keys.go-	DevelopmentKeys map[string]APIKeySettings `yaml:"development_keys"`
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-	// Production key sources
./pkg/auth/config_keys.go-	ProductionKeySource string `yaml:"production_key_source"` // "env", "vault", "aws-secrets"
./pkg/auth/config_keys.go-}
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-// APIKeySettings represents settings for an API key
./pkg/auth/config_keys.go-type APIKeySettings struct {
./pkg/auth/config_keys.go-	Role      string   `yaml:"role"`
./pkg/auth/config_keys.go-	Scopes    []string `yaml:"scopes"`
./pkg/auth/config_keys.go-	TenantID  string   `yaml:"tenant_id"`
./pkg/auth/config_keys.go-	ExpiresIn string   `yaml:"expires_in"` // Duration string like "30d"
./pkg/auth/config_keys.go-}
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-// KeyConfig is used for backward compatibility with existing code
./pkg/auth/config_keys.go:type KeyConfig struct {
./pkg/auth/config_keys.go-	Key      string
./pkg/auth/config_keys.go-	Role     string
./pkg/auth/config_keys.go-	Scopes   []string
./pkg/auth/config_keys.go-	TenantID string
./pkg/auth/config_keys.go-	UserID   string
./pkg/auth/config_keys.go-}
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-// LoadAPIKeys loads API keys based on environment
./pkg/auth/config_keys.go-func (s *Service) LoadAPIKeys(config *APIKeyConfig) error {
./pkg/auth/config_keys.go-	env := os.Getenv("ENVIRONMENT")
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-	switch env {
./pkg/auth/config_keys.go-	case "development", "test", "docker", "":
./pkg/auth/config_keys.go-		return s.loadDevelopmentKeys(config.DevelopmentKeys)
./pkg/auth/config_keys.go-	case "production":
./pkg/auth/config_keys.go-		return s.loadProductionKeys(config.ProductionKeySource)
./pkg/auth/config_keys.go-	default:
./pkg/auth/config_keys.go-		return fmt.Errorf("unknown environment: %s", env)
./pkg/auth/config_keys.go-	}
./pkg/auth/config_keys.go-}
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-// loadDevelopmentKeys loads keys for development/test
./pkg/auth/config_keys.go-func (s *Service) loadDevelopmentKeys(keys map[string]APIKeySettings) error {
./pkg/auth/config_keys.go-	// For docker environment, also load from environment variables
./pkg/auth/config_keys.go-	env := os.Getenv("ENVIRONMENT")
./pkg/auth/config_keys.go-	if env == "docker" {
./pkg/auth/config_keys.go-		s.logger.Info("Docker environment detected, loading keys from environment", nil)
./pkg/auth/config_keys.go-		return s.loadKeysFromEnv()
./pkg/auth/config_keys.go-	}
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-	if keys == nil {
./pkg/auth/config_keys.go-		return nil
./pkg/auth/config_keys.go-	}
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-	s.mu.Lock()
./pkg/auth/config_keys.go-	defer s.mu.Unlock()
./pkg/auth/config_keys.go-
./pkg/auth/config_keys.go-	for key, settings := range keys {
./pkg/auth/config_keys.go-		// Parse tenant ID
./pkg/auth/config_keys.go-		var tenantUUID uuid.UUID
./pkg/auth/config_keys.go-		if settings.TenantID == "" {
./pkg/auth/config_keys.go-			tenantUUID = DefaultTenantID
./pkg/auth/config_keys.go-		} else {
./pkg/auth/config_keys.go-			var err error
./pkg/auth/config_keys.go-			tenantUUID, err = uuid.Parse(settings.TenantID)
./pkg/auth/config_keys.go-			if err != nil {
./pkg/auth/config_keys.go-				s.logger.Warn("Invalid tenant ID in config, using default", map[string]interface{}{
./pkg/auth/config_keys.go-					"tenant_id": settings.TenantID,
./pkg/auth/config_keys.go-					"error":     err.Error(),
./pkg/auth/config_keys.go-				})
--
./pkg/embedding/cache/lru/manager.go:type Config struct {
./pkg/embedding/cache/lru/manager.go-	// Global limits
./pkg/embedding/cache/lru/manager.go-	MaxGlobalEntries int
./pkg/embedding/cache/lru/manager.go-	MaxGlobalBytes   int64
./pkg/embedding/cache/lru/manager.go-
./pkg/embedding/cache/lru/manager.go-	// Per-tenant limits (defaults)
./pkg/embedding/cache/lru/manager.go-	MaxTenantEntries int
./pkg/embedding/cache/lru/manager.go-	MaxTenantBytes   int64
./pkg/embedding/cache/lru/manager.go-
./pkg/embedding/cache/lru/manager.go-	// Eviction settings
./pkg/embedding/cache/lru/manager.go-	EvictionBatchSize int
./pkg/embedding/cache/lru/manager.go-	EvictionInterval  time.Duration
./pkg/embedding/cache/lru/manager.go-
./pkg/embedding/cache/lru/manager.go-	// Tracking settings
./pkg/embedding/cache/lru/manager.go-	TrackingBatchSize  int
./pkg/embedding/cache/lru/manager.go-	FlushInterval      time.Duration
./pkg/embedding/cache/lru/manager.go-	TrackingBufferSize int // Channel buffer size for async tracking
./pkg/embedding/cache/lru/manager.go-}
./pkg/embedding/cache/lru/manager.go-
./pkg/embedding/cache/lru/manager.go-// DefaultConfig returns default LRU configuration
./pkg/embedding/cache/lru/manager.go-func DefaultConfig() *Config {
./pkg/embedding/cache/lru/manager.go-	return &Config{
./pkg/embedding/cache/lru/manager.go-		MaxGlobalEntries:   1000000,
./pkg/embedding/cache/lru/manager.go-		MaxGlobalBytes:     10 * 1024 * 1024 * 1024, // 10GB
./pkg/embedding/cache/lru/manager.go-		MaxTenantEntries:   10000,
./pkg/embedding/cache/lru/manager.go-		MaxTenantBytes:     100 * 1024 * 1024, // 100MB
./pkg/embedding/cache/lru/manager.go-		EvictionBatchSize:  100,
./pkg/embedding/cache/lru/manager.go-		EvictionInterval:   5 * time.Minute,
./pkg/embedding/cache/lru/manager.go-		TrackingBatchSize:  1000,
./pkg/embedding/cache/lru/manager.go-		FlushInterval:      10 * time.Second,
./pkg/embedding/cache/lru/manager.go-		TrackingBufferSize: 1000, // Reduced from hardcoded 10000
./pkg/embedding/cache/lru/manager.go-	}
./pkg/embedding/cache/lru/manager.go-}
./pkg/embedding/cache/lru/manager.go-
./pkg/embedding/cache/lru/manager.go-// NewManager creates a new LRU manager
./pkg/embedding/cache/lru/manager.go-func NewManager(redis RedisClient, config *Config, prefix string, logger observability.Logger, metrics observability.MetricsClient) *Manager {
./pkg/embedding/cache/lru/manager.go-	if config == nil {
./pkg/embedding/cache/lru/manager.go-		config = DefaultConfig()
./pkg/embedding/cache/lru/manager.go-	}
./pkg/embedding/cache/lru/manager.go-	if logger == nil {
./pkg/embedding/cache/lru/manager.go-		logger = observability.NewLogger("embedding.cache.lru")
./pkg/embedding/cache/lru/manager.go-	}
./pkg/embedding/cache/lru/manager.go-	if metrics == nil {
./pkg/embedding/cache/lru/manager.go-		metrics = observability.NewMetricsClient()
./pkg/embedding/cache/lru/manager.go-	}
./pkg/embedding/cache/lru/manager.go-
./pkg/embedding/cache/lru/manager.go-	m := &Manager{
./pkg/embedding/cache/lru/manager.go-		redis:    redis,
./pkg/embedding/cache/lru/manager.go-		config:   config,
./pkg/embedding/cache/lru/manager.go-		logger:   logger,
./pkg/embedding/cache/lru/manager.go-		metrics:  metrics,
--
./pkg/embedding/cache/tenant/config.go:type CacheTenantConfig struct {
./pkg/embedding/cache/tenant/config.go-	*models.TenantConfig
./pkg/embedding/cache/tenant/config.go-
./pkg/embedding/cache/tenant/config.go-	// Cache-specific limits
./pkg/embedding/cache/tenant/config.go-	MaxCacheEntries  int           `json:"max_cache_entries"`
./pkg/embedding/cache/tenant/config.go-	MaxCacheBytes    int64         `json:"max_cache_bytes"`
./pkg/embedding/cache/tenant/config.go-	CacheTTLOverride time.Duration `json:"cache_ttl_override"`
./pkg/embedding/cache/tenant/config.go-
./pkg/embedding/cache/tenant/config.go-	// Feature flags
./pkg/embedding/cache/tenant/config.go-	EnabledFeatures CacheFeatureFlags `json:"enabled_features"`
./pkg/embedding/cache/tenant/config.go-}
./pkg/embedding/cache/tenant/config.go-
./pkg/embedding/cache/tenant/config.go-type CacheFeatureFlags struct {
./pkg/embedding/cache/tenant/config.go-	EnableSemanticCache bool `json:"enable_semantic_cache"`
./pkg/embedding/cache/tenant/config.go-	EnableCacheWarming  bool `json:"enable_cache_warming"`
./pkg/embedding/cache/tenant/config.go-	EnableAsyncEviction bool `json:"enable_async_eviction"`
./pkg/embedding/cache/tenant/config.go-	EnableMetrics       bool `json:"enable_metrics"`
./pkg/embedding/cache/tenant/config.go-}
./pkg/embedding/cache/tenant/config.go-
./pkg/embedding/cache/tenant/config.go-// DefaultCacheTenantConfig returns default cache configuration for a tenant
./pkg/embedding/cache/tenant/config.go-func DefaultCacheTenantConfig() *CacheTenantConfig {
./pkg/embedding/cache/tenant/config.go-	return &CacheTenantConfig{
./pkg/embedding/cache/tenant/config.go-		MaxCacheEntries:  10000,
./pkg/embedding/cache/tenant/config.go-		MaxCacheBytes:    100 * 1024 * 1024, // 100MB
./pkg/embedding/cache/tenant/config.go-		CacheTTLOverride: 0,                 // Use global default
./pkg/embedding/cache/tenant/config.go-		EnabledFeatures: CacheFeatureFlags{
./pkg/embedding/cache/tenant/config.go-			EnableSemanticCache: true,
./pkg/embedding/cache/tenant/config.go-			EnableCacheWarming:  false,
./pkg/embedding/cache/tenant/config.go-			EnableAsyncEviction: true,
./pkg/embedding/cache/tenant/config.go-			EnableMetrics:       true,
./pkg/embedding/cache/tenant/config.go-		},
./pkg/embedding/cache/tenant/config.go-	}
./pkg/embedding/cache/tenant/config.go-}
./pkg/embedding/cache/tenant/config.go-
./pkg/embedding/cache/tenant/config.go-// ParseFromTenantConfig extracts cache configuration from base tenant config
./pkg/embedding/cache/tenant/config.go-func ParseFromTenantConfig(baseConfig *models.TenantConfig) *CacheTenantConfig {
./pkg/embedding/cache/tenant/config.go-	config := &CacheTenantConfig{
./pkg/embedding/cache/tenant/config.go-		TenantConfig: baseConfig,
./pkg/embedding/cache/tenant/config.go-		// Set defaults
./pkg/embedding/cache/tenant/config.go-		MaxCacheEntries: 10000,
./pkg/embedding/cache/tenant/config.go-		MaxCacheBytes:   100 * 1024 * 1024, // 100MB
./pkg/embedding/cache/tenant/config.go-		EnabledFeatures: CacheFeatureFlags{
./pkg/embedding/cache/tenant/config.go-			EnableSemanticCache: true,
./pkg/embedding/cache/tenant/config.go-			EnableCacheWarming:  false,
./pkg/embedding/cache/tenant/config.go-			EnableAsyncEviction: true,
./pkg/embedding/cache/tenant/config.go-			EnableMetrics:       true,
./pkg/embedding/cache/tenant/config.go-		},
./pkg/embedding/cache/tenant/config.go-	}
./pkg/embedding/cache/tenant/config.go-
./pkg/embedding/cache/tenant/config.go-	// Override from features JSON if present
./pkg/embedding/cache/tenant/config.go-	if features, ok := baseConfig.Features["cache"]; ok {
--
./pkg/embedding/cache/tenant/config_cache.go:type cachedConfig struct {
./pkg/embedding/cache/tenant/config_cache.go-	config    *CacheTenantConfig
./pkg/embedding/cache/tenant/config_cache.go-	expiresAt time.Time
./pkg/embedding/cache/tenant/config_cache.go-}
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-// NewConfigCache creates a new configuration cache
./pkg/embedding/cache/tenant/config_cache.go-func NewConfigCache(repo repository.TenantConfigRepository, ttl time.Duration) *ConfigCache {
./pkg/embedding/cache/tenant/config_cache.go-	if ttl <= 0 {
./pkg/embedding/cache/tenant/config_cache.go-		ttl = 5 * time.Minute // default TTL
./pkg/embedding/cache/tenant/config_cache.go-	}
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-	ctx, cancel := context.WithCancel(context.Background())
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-	cc := &ConfigCache{
./pkg/embedding/cache/tenant/config_cache.go-		repo:       repo,
./pkg/embedding/cache/tenant/config_cache.go-		ttl:        ttl,
./pkg/embedding/cache/tenant/config_cache.go-		cancelFunc: cancel,
./pkg/embedding/cache/tenant/config_cache.go-	}
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-	// Start cleanup routine
./pkg/embedding/cache/tenant/config_cache.go-	go cc.cleanupLoop(ctx)
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-	return cc
./pkg/embedding/cache/tenant/config_cache.go-}
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-// Get retrieves a tenant configuration from cache or database
./pkg/embedding/cache/tenant/config_cache.go-func (c *ConfigCache) Get(ctx context.Context, tenantID uuid.UUID) (*CacheTenantConfig, error) {
./pkg/embedding/cache/tenant/config_cache.go-	// Check cache first
./pkg/embedding/cache/tenant/config_cache.go-	if cached, ok := c.cache.Load(tenantID); ok {
./pkg/embedding/cache/tenant/config_cache.go-		config := cached.(*cachedConfig)
./pkg/embedding/cache/tenant/config_cache.go-		if time.Now().Before(config.expiresAt) {
./pkg/embedding/cache/tenant/config_cache.go-			return config.config, nil
./pkg/embedding/cache/tenant/config_cache.go-		}
./pkg/embedding/cache/tenant/config_cache.go-		// Expired, delete it
./pkg/embedding/cache/tenant/config_cache.go-		c.cache.Delete(tenantID)
./pkg/embedding/cache/tenant/config_cache.go-	}
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-	// Load from database
./pkg/embedding/cache/tenant/config_cache.go-	dbConfig, err := c.repo.GetByTenantID(ctx, tenantID.String())
./pkg/embedding/cache/tenant/config_cache.go-	if err != nil {
./pkg/embedding/cache/tenant/config_cache.go-		return nil, err
./pkg/embedding/cache/tenant/config_cache.go-	}
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-	// Parse to cache config
./pkg/embedding/cache/tenant/config_cache.go-	cacheConfig := ParseFromTenantConfig(dbConfig)
./pkg/embedding/cache/tenant/config_cache.go-
./pkg/embedding/cache/tenant/config_cache.go-	// Cache it
./pkg/embedding/cache/tenant/config_cache.go-	c.cache.Store(tenantID, &cachedConfig{
./pkg/embedding/cache/tenant/config_cache.go-		config:    cacheConfig,
./pkg/embedding/cache/tenant/config_cache.go-		expiresAt: time.Now().Add(c.ttl),
./pkg/embedding/cache/tenant/config_cache.go-	})
--
./pkg/embedding/cache/middleware/rate_limit.go:type CacheRateLimitConfig struct {
./pkg/embedding/cache/middleware/rate_limit.go-	// Cache-specific limits
./pkg/embedding/cache/middleware/rate_limit.go-	CacheReadRPS    int // Reads per second per tenant
./pkg/embedding/cache/middleware/rate_limit.go-	CacheReadBurst  int // Burst size for reads
./pkg/embedding/cache/middleware/rate_limit.go-	CacheWriteRPS   int // Writes per second per tenant
./pkg/embedding/cache/middleware/rate_limit.go-	CacheWriteBurst int // Burst size for writes
./pkg/embedding/cache/middleware/rate_limit.go-
./pkg/embedding/cache/middleware/rate_limit.go-	// Cleanup
./pkg/embedding/cache/middleware/rate_limit.go-	CleanupInterval time.Duration
./pkg/embedding/cache/middleware/rate_limit.go-	MaxAge          time.Duration
./pkg/embedding/cache/middleware/rate_limit.go-}
./pkg/embedding/cache/middleware/rate_limit.go-
./pkg/embedding/cache/middleware/rate_limit.go-// DefaultCacheRateLimitConfig returns default cache rate limit configuration
./pkg/embedding/cache/middleware/rate_limit.go-func DefaultCacheRateLimitConfig() CacheRateLimitConfig {
./pkg/embedding/cache/middleware/rate_limit.go-	return CacheRateLimitConfig{
./pkg/embedding/cache/middleware/rate_limit.go-		CacheReadRPS:    100,
./pkg/embedding/cache/middleware/rate_limit.go-		CacheReadBurst:  200,
./pkg/embedding/cache/middleware/rate_limit.go-		CacheWriteRPS:   50,
./pkg/embedding/cache/middleware/rate_limit.go-		CacheWriteBurst: 100,
./pkg/embedding/cache/middleware/rate_limit.go-		CleanupInterval: 5 * time.Minute,
./pkg/embedding/cache/middleware/rate_limit.go-		MaxAge:          1 * time.Hour,
./pkg/embedding/cache/middleware/rate_limit.go-	}
./pkg/embedding/cache/middleware/rate_limit.go-}
./pkg/embedding/cache/middleware/rate_limit.go-
./pkg/embedding/cache/middleware/rate_limit.go-// NewCacheRateLimiter creates a new cache-aware rate limiter
./pkg/embedding/cache/middleware/rate_limit.go-func NewCacheRateLimiter(
./pkg/embedding/cache/middleware/rate_limit.go-	baseRateLimiter *middleware.RateLimiter,
./pkg/embedding/cache/middleware/rate_limit.go-	config CacheRateLimitConfig,
./pkg/embedding/cache/middleware/rate_limit.go-	logger observability.Logger,
./pkg/embedding/cache/middleware/rate_limit.go-	metrics observability.MetricsClient,
./pkg/embedding/cache/middleware/rate_limit.go-) *CacheRateLimiter {
./pkg/embedding/cache/middleware/rate_limit.go-	if logger == nil {
./pkg/embedding/cache/middleware/rate_limit.go-		logger = observability.NewLogger("embedding.cache.ratelimit")
./pkg/embedding/cache/middleware/rate_limit.go-	}
./pkg/embedding/cache/middleware/rate_limit.go-	if metrics == nil {
./pkg/embedding/cache/middleware/rate_limit.go-		metrics = observability.NewMetricsClient()
./pkg/embedding/cache/middleware/rate_limit.go-	}
./pkg/embedding/cache/middleware/rate_limit.go-
./pkg/embedding/cache/middleware/rate_limit.go-	rl := &CacheRateLimiter{
./pkg/embedding/cache/middleware/rate_limit.go-		baseRateLimiter: baseRateLimiter,
./pkg/embedding/cache/middleware/rate_limit.go-		cacheLimiters:   make(map[string]*rate.Limiter),
./pkg/embedding/cache/middleware/rate_limit.go-		config:          config,
./pkg/embedding/cache/middleware/rate_limit.go-		logger:          logger,
./pkg/embedding/cache/middleware/rate_limit.go-		metrics:         metrics,
./pkg/embedding/cache/middleware/rate_limit.go-	}
./pkg/embedding/cache/middleware/rate_limit.go-
./pkg/embedding/cache/middleware/rate_limit.go-	// Start cleanup routine
./pkg/embedding/cache/middleware/rate_limit.go-	go rl.cleanupRoutine()
./pkg/embedding/cache/middleware/rate_limit.go-
./pkg/embedding/cache/middleware/rate_limit.go-	return rl
./pkg/embedding/cache/middleware/rate_limit.go-}
--
./pkg/embedding/cache/performance_config.go:type PerformanceConfig struct {
./pkg/embedding/cache/performance_config.go-	// Cache operation timeouts
./pkg/embedding/cache/performance_config.go-	GetTimeout    time.Duration `json:"get_timeout" yaml:"get_timeout"`
./pkg/embedding/cache/performance_config.go-	SetTimeout    time.Duration `json:"set_timeout" yaml:"set_timeout"`
./pkg/embedding/cache/performance_config.go-	DeleteTimeout time.Duration `json:"delete_timeout" yaml:"delete_timeout"`
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-	// Batch processing
./pkg/embedding/cache/performance_config.go-	BatchSize     int           `json:"batch_size" yaml:"batch_size"`
./pkg/embedding/cache/performance_config.go-	FlushInterval time.Duration `json:"flush_interval" yaml:"flush_interval"`
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-	// Compression
./pkg/embedding/cache/performance_config.go-	CompressionThreshold int    `json:"compression_threshold" yaml:"compression_threshold"` // bytes
./pkg/embedding/cache/performance_config.go-	CompressionLevel     string `json:"compression_level" yaml:"compression_level"`         // none, fast, best
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-	// Similarity search
./pkg/embedding/cache/performance_config.go-	MaxCandidates       int           `json:"max_candidates" yaml:"max_candidates"`
./pkg/embedding/cache/performance_config.go-	SimilarityThreshold float32       `json:"similarity_threshold" yaml:"similarity_threshold"`
./pkg/embedding/cache/performance_config.go-	VectorSearchTimeout time.Duration `json:"vector_search_timeout" yaml:"vector_search_timeout"`
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-	// LRU tracking
./pkg/embedding/cache/performance_config.go-	TrackingBufferSize int           `json:"tracking_buffer_size" yaml:"tracking_buffer_size"`
./pkg/embedding/cache/performance_config.go-	TrackingBatchSize  int           `json:"tracking_batch_size" yaml:"tracking_batch_size"`
./pkg/embedding/cache/performance_config.go-	EvictionBatchSize  int           `json:"eviction_batch_size" yaml:"eviction_batch_size"`
./pkg/embedding/cache/performance_config.go-	EvictionInterval   time.Duration `json:"eviction_interval" yaml:"eviction_interval"`
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-	// Circuit breaker
./pkg/embedding/cache/performance_config.go-	CircuitBreakerEnabled      bool          `json:"circuit_breaker_enabled" yaml:"circuit_breaker_enabled"`
./pkg/embedding/cache/performance_config.go-	CircuitBreakerThreshold    int           `json:"circuit_breaker_threshold" yaml:"circuit_breaker_threshold"`
./pkg/embedding/cache/performance_config.go-	CircuitBreakerTimeout      time.Duration `json:"circuit_breaker_timeout" yaml:"circuit_breaker_timeout"`
./pkg/embedding/cache/performance_config.go-	CircuitBreakerResetTimeout time.Duration `json:"circuit_breaker_reset_timeout" yaml:"circuit_breaker_reset_timeout"`
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-	// Retry policy
./pkg/embedding/cache/performance_config.go-	RetryEnabled      bool          `json:"retry_enabled" yaml:"retry_enabled"`
./pkg/embedding/cache/performance_config.go-	RetryMaxAttempts  int           `json:"retry_max_attempts" yaml:"retry_max_attempts"`
./pkg/embedding/cache/performance_config.go-	RetryInitialDelay time.Duration `json:"retry_initial_delay" yaml:"retry_initial_delay"`
./pkg/embedding/cache/performance_config.go-	RetryMaxDelay     time.Duration `json:"retry_max_delay" yaml:"retry_max_delay"`
./pkg/embedding/cache/performance_config.go-	RetryMultiplier   float64       `json:"retry_multiplier" yaml:"retry_multiplier"`
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-	// Connection pooling (extends RedisPoolConfig)
./pkg/embedding/cache/performance_config.go-	ConnectionPoolProfile string `json:"connection_pool_profile" yaml:"connection_pool_profile"`
./pkg/embedding/cache/performance_config.go-}
./pkg/embedding/cache/performance_config.go-
./pkg/embedding/cache/performance_config.go-// GetPerformanceProfile returns a predefined performance configuration.
./pkg/embedding/cache/performance_config.go-// Each profile is optimized for different use cases:
./pkg/embedding/cache/performance_config.go-//
./pkg/embedding/cache/performance_config.go-//   - ProfileLowLatency: Minimal response time, smaller batches, aggressive timeouts
./pkg/embedding/cache/performance_config.go-//   - ProfileHighThroughput: Maximum throughput, larger batches, relaxed timeouts
./pkg/embedding/cache/performance_config.go-//   - ProfileBalanced: Good balance for general use cases
./pkg/embedding/cache/performance_config.go-//   - ProfileCustom: Returns base configuration for customization
./pkg/embedding/cache/performance_config.go-//
./pkg/embedding/cache/performance_config.go-// The returned configuration can be further customized as needed.
--
./pkg/embedding/cache/config_loader.go:type SemanticCacheConfig struct {
./pkg/embedding/cache/config_loader.go-	Enabled        bool                 `mapstructure:"enabled"`
./pkg/embedding/cache/config_loader.go-	Mode           string               `mapstructure:"mode"`
./pkg/embedding/cache/config_loader.go-	Redis          RedisCacheConfig     `mapstructure:"redis"`
./pkg/embedding/cache/config_loader.go-	CircuitBreaker CircuitBreakerConfig `mapstructure:"circuit_breaker"`
./pkg/embedding/cache/config_loader.go-	Retry          RetryConfig          `mapstructure:"retry"`
./pkg/embedding/cache/config_loader.go-	Validation     ValidationConfig     `mapstructure:"validation"`
./pkg/embedding/cache/config_loader.go-	Tenant         TenantConfig         `mapstructure:"tenant"`
./pkg/embedding/cache/config_loader.go-	Warmup         WarmupConfig         `mapstructure:"warmup"`
./pkg/embedding/cache/config_loader.go-	Monitoring     MonitoringConfig     `mapstructure:"monitoring"`
./pkg/embedding/cache/config_loader.go-	Eviction       EvictionConfig       `mapstructure:"eviction"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// RedisCacheConfig represents Redis-specific cache configuration
./pkg/embedding/cache/config_loader.go:type RedisCacheConfig struct {
./pkg/embedding/cache/config_loader.go-	Prefix             string `mapstructure:"prefix"`
./pkg/embedding/cache/config_loader.go-	TTL                int    `mapstructure:"ttl"`
./pkg/embedding/cache/config_loader.go-	MaxEntries         int    `mapstructure:"max_entries"`
./pkg/embedding/cache/config_loader.go-	MaxMemoryMB        int    `mapstructure:"max_memory_mb"`
./pkg/embedding/cache/config_loader.go-	CompressionEnabled bool   `mapstructure:"compression_enabled"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// CircuitBreakerConfig represents circuit breaker configuration
./pkg/embedding/cache/config_loader.go:type CircuitBreakerConfig struct {
./pkg/embedding/cache/config_loader.go-	FailureThreshold    int           `mapstructure:"failure_threshold"`
./pkg/embedding/cache/config_loader.go-	FailureRatio        float64       `mapstructure:"failure_ratio"`
./pkg/embedding/cache/config_loader.go-	ResetTimeout        time.Duration `mapstructure:"reset_timeout"`
./pkg/embedding/cache/config_loader.go-	MaxRequestsHalfOpen int           `mapstructure:"max_requests_half_open"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// RetryConfig represents retry configuration
./pkg/embedding/cache/config_loader.go:type RetryConfig struct {
./pkg/embedding/cache/config_loader.go-	MaxAttempts     int           `mapstructure:"max_attempts"`
./pkg/embedding/cache/config_loader.go-	InitialInterval time.Duration `mapstructure:"initial_interval"`
./pkg/embedding/cache/config_loader.go-	MaxInterval     time.Duration `mapstructure:"max_interval"`
./pkg/embedding/cache/config_loader.go-	Multiplier      float64       `mapstructure:"multiplier"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// ValidationConfig represents validation configuration
./pkg/embedding/cache/config_loader.go:type ValidationConfig struct {
./pkg/embedding/cache/config_loader.go-	MaxQueryLength int `mapstructure:"max_query_length"`
./pkg/embedding/cache/config_loader.go-	RateLimitRPS   int `mapstructure:"rate_limit_rps"`
./pkg/embedding/cache/config_loader.go-	RateLimitBurst int `mapstructure:"rate_limit_burst"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// TenantConfig represents tenant-specific configuration
./pkg/embedding/cache/config_loader.go:type TenantConfig struct {
./pkg/embedding/cache/config_loader.go-	DefaultMaxEntries int  `mapstructure:"default_max_entries"`
./pkg/embedding/cache/config_loader.go-	DefaultTTL        int  `mapstructure:"default_ttl"`
./pkg/embedding/cache/config_loader.go-	EncryptionEnabled bool `mapstructure:"encryption_enabled"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// WarmupConfig represents cache warmup configuration
./pkg/embedding/cache/config_loader.go:type WarmupConfig struct {
./pkg/embedding/cache/config_loader.go-	Enabled            bool   `mapstructure:"enabled"`
./pkg/embedding/cache/config_loader.go-	Schedule           string `mapstructure:"schedule"`
./pkg/embedding/cache/config_loader.go-	BatchSize          int    `mapstructure:"batch_size"`
./pkg/embedding/cache/config_loader.go-	ConcurrentRequests int    `mapstructure:"concurrent_requests"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// MonitoringConfig represents monitoring configuration
./pkg/embedding/cache/config_loader.go:type MonitoringConfig struct {
./pkg/embedding/cache/config_loader.go-	MetricsInterval    time.Duration `mapstructure:"metrics_interval"`
./pkg/embedding/cache/config_loader.go-	SlowQueryThreshold time.Duration `mapstructure:"slow_query_threshold"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// EvictionConfig represents eviction configuration
./pkg/embedding/cache/config_loader.go:type EvictionConfig struct {
./pkg/embedding/cache/config_loader.go-	Strategy      string        `mapstructure:"strategy"`
./pkg/embedding/cache/config_loader.go-	CheckInterval time.Duration `mapstructure:"check_interval"`
./pkg/embedding/cache/config_loader.go-	BatchSize     int           `mapstructure:"batch_size"`
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// LoadSemanticCacheConfig loads the complete semantic cache configuration
./pkg/embedding/cache/config_loader.go-func LoadSemanticCacheConfig() (*SemanticCacheConfig, error) {
./pkg/embedding/cache/config_loader.go-	var config SemanticCacheConfig
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	// Load from viper
./pkg/embedding/cache/config_loader.go-	if err := viper.UnmarshalKey("cache.semantic", &config); err != nil {
./pkg/embedding/cache/config_loader.go-		return nil, fmt.Errorf("failed to unmarshal semantic cache config: %w", err)
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	// Validate configuration
./pkg/embedding/cache/config_loader.go-	if err := validateSemanticCacheConfig(&config); err != nil {
./pkg/embedding/cache/config_loader.go-		return nil, fmt.Errorf("invalid semantic cache config: %w", err)
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	return &config, nil
./pkg/embedding/cache/config_loader.go-}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-// validateSemanticCacheConfig validates the semantic cache configuration
./pkg/embedding/cache/config_loader.go-func validateSemanticCacheConfig(config *SemanticCacheConfig) error {
./pkg/embedding/cache/config_loader.go-	if config.Mode != "legacy" && config.Mode != "tenant_aware" {
./pkg/embedding/cache/config_loader.go-		return fmt.Errorf("invalid mode: %s", config.Mode)
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	if config.Redis.MaxEntries <= 0 {
./pkg/embedding/cache/config_loader.go-		return fmt.Errorf("max_entries must be positive")
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	if config.Redis.TTL <= 0 {
./pkg/embedding/cache/config_loader.go-		return fmt.Errorf("ttl must be positive")
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	if config.CircuitBreaker.FailureThreshold <= 0 {
./pkg/embedding/cache/config_loader.go-		return fmt.Errorf("failure_threshold must be positive")
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	if config.Retry.MaxAttempts <= 0 {
./pkg/embedding/cache/config_loader.go-		return fmt.Errorf("max_attempts must be positive")
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	if config.Validation.MaxQueryLength <= 0 {
./pkg/embedding/cache/config_loader.go-		return fmt.Errorf("max_query_length must be positive")
./pkg/embedding/cache/config_loader.go-	}
./pkg/embedding/cache/config_loader.go-
./pkg/embedding/cache/config_loader.go-	return nil
./pkg/embedding/cache/config_loader.go-}
--
./pkg/embedding/cache/types.go:type Config struct {
./pkg/embedding/cache/types.go-	// SimilarityThreshold is the minimum similarity for cache hit (0.0 to 1.0)
./pkg/embedding/cache/types.go-	SimilarityThreshold float32 `json:"similarity_threshold"`
./pkg/embedding/cache/types.go-	// TTL is the default cache entry time-to-live
./pkg/embedding/cache/types.go-	TTL time.Duration `json:"ttl"`
./pkg/embedding/cache/types.go-	// MaxCandidates is the maximum number of candidates to check for similarity
./pkg/embedding/cache/types.go-	MaxCandidates int `json:"max_candidates"`
./pkg/embedding/cache/types.go-	// MaxCacheSize is the maximum number of entries to keep in cache
./pkg/embedding/cache/types.go-	MaxCacheSize int `json:"max_cache_size"`
./pkg/embedding/cache/types.go-	// Prefix is the Redis key prefix for cache entries
./pkg/embedding/cache/types.go-	Prefix string `json:"prefix"`
./pkg/embedding/cache/types.go-	// WarmupQueries are queries to pre-warm the cache with
./pkg/embedding/cache/types.go-	WarmupQueries []string `json:"warmup_queries"`
./pkg/embedding/cache/types.go-	// EnableMetrics enables metrics collection
./pkg/embedding/cache/types.go-	EnableMetrics bool `json:"enable_metrics"`
./pkg/embedding/cache/types.go-	// EnableCompression enables compression of cached results
./pkg/embedding/cache/types.go-	EnableCompression bool `json:"enable_compression"`
./pkg/embedding/cache/types.go-	// EnableAuditLogging enables audit logging for compliance
./pkg/embedding/cache/types.go-	EnableAuditLogging bool `json:"enable_audit_logging"`
./pkg/embedding/cache/types.go-	// RedisPoolConfig contains Redis connection pool settings
./pkg/embedding/cache/types.go-	RedisPoolConfig *RedisPoolConfig `json:"redis_pool_config,omitempty"`
./pkg/embedding/cache/types.go-	// PerformanceConfig contains performance tuning parameters
./pkg/embedding/cache/types.go-	PerformanceConfig *PerformanceConfig `json:"performance_config,omitempty"`
./pkg/embedding/cache/types.go-}
./pkg/embedding/cache/types.go-
./pkg/embedding/cache/types.go-// DefaultConfig returns default cache configuration with production-ready settings.
./pkg/embedding/cache/types.go-// The defaults provide a good balance between performance and resource usage:
./pkg/embedding/cache/types.go-//   - 95% similarity threshold for high-quality matches
./pkg/embedding/cache/types.go-//   - 24-hour TTL for cached entries
./pkg/embedding/cache/types.go-//   - Support for up to 10,000 cached queries
./pkg/embedding/cache/types.go-//   - Metrics enabled for observability
./pkg/embedding/cache/types.go-//
./pkg/embedding/cache/types.go-// Adjust these values based on your specific use case and requirements.
./pkg/embedding/cache/types.go-func DefaultConfig() *Config {
./pkg/embedding/cache/types.go-	config := &Config{
./pkg/embedding/cache/types.go-		SimilarityThreshold: 0.95,
./pkg/embedding/cache/types.go-		TTL:                 24 * time.Hour,
./pkg/embedding/cache/types.go-		MaxCandidates:       10,
./pkg/embedding/cache/types.go-		MaxCacheSize:        10000,
./pkg/embedding/cache/types.go-		Prefix:              "semantic_cache",
./pkg/embedding/cache/types.go-		EnableMetrics:       true,
./pkg/embedding/cache/types.go-		EnableCompression:   false,
./pkg/embedding/cache/types.go-		RedisPoolConfig:     DefaultRedisPoolConfig(),
./pkg/embedding/cache/types.go-		PerformanceConfig:   GetPerformanceProfile(ProfileBalanced),
./pkg/embedding/cache/types.go-	}
./pkg/embedding/cache/types.go-	// Apply the balanced profile settings
./pkg/embedding/cache/types.go-	config.ApplyPerformanceProfile(ProfileBalanced)
./pkg/embedding/cache/types.go-	return config
./pkg/embedding/cache/types.go-}
./pkg/embedding/cache/types.go-
./pkg/embedding/cache/types.go-// CacheStats represents cache statistics at a point in time.
--
./pkg/embedding/cache/observability.go:type DashboardConfig struct {
./pkg/embedding/cache/observability.go-	Title       string
./pkg/embedding/cache/observability.go-	Description string
./pkg/embedding/cache/observability.go-	Panels      []PanelConfig
./pkg/embedding/cache/observability.go-}
./pkg/embedding/cache/observability.go-
./pkg/embedding/cache/observability.go-// PanelConfig defines a dashboard panel
./pkg/embedding/cache/observability.go:type PanelConfig struct {
./pkg/embedding/cache/observability.go-	Title  string
./pkg/embedding/cache/observability.go-	Query  string
./pkg/embedding/cache/observability.go-	Type   string // graph, gauge, table, etc.
./pkg/embedding/cache/observability.go-	Unit   string
./pkg/embedding/cache/observability.go-	Legend []string
./pkg/embedding/cache/observability.go-}
./pkg/embedding/cache/observability.go-
./pkg/embedding/cache/observability.go-// GetDefaultDashboardConfig returns the default Grafana dashboard configuration
./pkg/embedding/cache/observability.go-func GetDefaultDashboardConfig() DashboardConfig {
./pkg/embedding/cache/observability.go-	return DashboardConfig{
./pkg/embedding/cache/observability.go-		Title:       "Semantic Cache Performance",
./pkg/embedding/cache/observability.go-		Description: "Monitor semantic cache performance, hit rates, and resource usage",
./pkg/embedding/cache/observability.go-		Panels: []PanelConfig{
./pkg/embedding/cache/observability.go-			{
./pkg/embedding/cache/observability.go-				Title:  "Cache Hit Rate",
./pkg/embedding/cache/observability.go-				Query:  `rate(devmesh_semantic_cache_hits_total[5m]) / (rate(devmesh_semantic_cache_hits_total[5m]) + rate(devmesh_semantic_cache_misses_total[5m]))`,
./pkg/embedding/cache/observability.go-				Type:   "graph",
./pkg/embedding/cache/observability.go-				Unit:   "percentunit",
./pkg/embedding/cache/observability.go-				Legend: []string{"tenant_id"},
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-			{
./pkg/embedding/cache/observability.go-				Title:  "Cache Operations/sec",
./pkg/embedding/cache/observability.go-				Query:  `sum(rate(devmesh_semantic_cache_operation_duration_seconds_count[5m])) by (operation)`,
./pkg/embedding/cache/observability.go-				Type:   "graph",
./pkg/embedding/cache/observability.go-				Unit:   "ops",
./pkg/embedding/cache/observability.go-				Legend: []string{"operation"},
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-			{
./pkg/embedding/cache/observability.go-				Title:  "P95 Latency by Operation",
./pkg/embedding/cache/observability.go-				Query:  `histogram_quantile(0.95, rate(devmesh_semantic_cache_operation_duration_seconds_bucket[5m])) by (operation)`,
./pkg/embedding/cache/observability.go-				Type:   "graph",
./pkg/embedding/cache/observability.go-				Unit:   "s",
./pkg/embedding/cache/observability.go-				Legend: []string{"operation"},
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-			{
./pkg/embedding/cache/observability.go-				Title:  "Cache Size (MB)",
./pkg/embedding/cache/observability.go-				Query:  `devmesh_semantic_cache_size_bytes / 1024 / 1024`,
./pkg/embedding/cache/observability.go-				Type:   "gauge",
./pkg/embedding/cache/observability.go-				Unit:   "decmbytes",
./pkg/embedding/cache/observability.go-				Legend: []string{"tenant_id"},
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-			{
./pkg/embedding/cache/observability.go-				Title:  "Evictions/min",
./pkg/embedding/cache/observability.go-				Query:  `sum(rate(devmesh_semantic_cache_evictions_total[1m])) by (reason)`,
./pkg/embedding/cache/observability.go-				Type:   "graph",
./pkg/embedding/cache/observability.go-				Unit:   "short",
./pkg/embedding/cache/observability.go-				Legend: []string{"reason"},
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-			{
./pkg/embedding/cache/observability.go-				Title:  "Compression Ratio",
--
./pkg/embedding/cache/observability.go:type AlertConfig struct {
./pkg/embedding/cache/observability.go-	Name        string
./pkg/embedding/cache/observability.go-	Expression  string
./pkg/embedding/cache/observability.go-	Duration    string
./pkg/embedding/cache/observability.go-	Severity    string
./pkg/embedding/cache/observability.go-	Annotations map[string]string
./pkg/embedding/cache/observability.go-}
./pkg/embedding/cache/observability.go-
./pkg/embedding/cache/observability.go-// GetDefaultAlerts returns default alerting rules
./pkg/embedding/cache/observability.go-func GetDefaultAlerts() []AlertConfig {
./pkg/embedding/cache/observability.go-	return []AlertConfig{
./pkg/embedding/cache/observability.go-		{
./pkg/embedding/cache/observability.go-			Name:       "HighCacheMissRate",
./pkg/embedding/cache/observability.go-			Expression: `rate(devmesh_semantic_cache_misses_total[5m]) / (rate(devmesh_semantic_cache_hits_total[5m]) + rate(devmesh_semantic_cache_misses_total[5m])) > 0.8`,
./pkg/embedding/cache/observability.go-			Duration:   "5m",
./pkg/embedding/cache/observability.go-			Severity:   "warning",
./pkg/embedding/cache/observability.go-			Annotations: map[string]string{
./pkg/embedding/cache/observability.go-				"summary":     "High cache miss rate detected",
./pkg/embedding/cache/observability.go-				"description": "Cache miss rate is above 80% for {{ $labels.tenant_id }}",
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-		},
./pkg/embedding/cache/observability.go-		{
./pkg/embedding/cache/observability.go-			Name:       "CacheEvictionHigh",
./pkg/embedding/cache/observability.go-			Expression: `sum(rate(devmesh_semantic_cache_evictions_total[5m])) by (tenant_id) > 10`,
./pkg/embedding/cache/observability.go-			Duration:   "5m",
./pkg/embedding/cache/observability.go-			Severity:   "warning",
./pkg/embedding/cache/observability.go-			Annotations: map[string]string{
./pkg/embedding/cache/observability.go-				"summary":     "High cache eviction rate",
./pkg/embedding/cache/observability.go-				"description": "Cache evicting more than 10 entries per second for {{ $labels.tenant_id }}",
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-		},
./pkg/embedding/cache/observability.go-		{
./pkg/embedding/cache/observability.go-			Name:       "CacheLatencyHigh",
./pkg/embedding/cache/observability.go-			Expression: `histogram_quantile(0.99, rate(devmesh_semantic_cache_operation_duration_seconds_bucket[5m])) > 1`,
./pkg/embedding/cache/observability.go-			Duration:   "5m",
./pkg/embedding/cache/observability.go-			Severity:   "critical",
./pkg/embedding/cache/observability.go-			Annotations: map[string]string{
./pkg/embedding/cache/observability.go-				"summary":     "High cache operation latency",
./pkg/embedding/cache/observability.go-				"description": "P99 cache operation latency is above 1 second",
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-		},
./pkg/embedding/cache/observability.go-		{
./pkg/embedding/cache/observability.go-			Name:       "CircuitBreakerOpen",
./pkg/embedding/cache/observability.go-			Expression: `devmesh_semantic_cache_circuit_breaker_state == 1`,
./pkg/embedding/cache/observability.go-			Duration:   "1m",
./pkg/embedding/cache/observability.go-			Severity:   "critical",
./pkg/embedding/cache/observability.go-			Annotations: map[string]string{
./pkg/embedding/cache/observability.go-				"summary":     "Circuit breaker is open",
./pkg/embedding/cache/observability.go-				"description": "Circuit breaker {{ $labels.name }} is in open state",
./pkg/embedding/cache/observability.go-			},
./pkg/embedding/cache/observability.go-		},
--
./pkg/embedding/cache/redis_config.go:type RedisPoolConfig struct {
./pkg/embedding/cache/redis_config.go-	// Connection pool settings
./pkg/embedding/cache/redis_config.go-	PoolSize      int           `json:"pool_size" yaml:"pool_size"`             // Maximum number of connections
./pkg/embedding/cache/redis_config.go-	MinIdleConns  int           `json:"min_idle_conns" yaml:"min_idle_conns"`   // Minimum idle connections
./pkg/embedding/cache/redis_config.go-	MaxRetries    int           `json:"max_retries" yaml:"max_retries"`         // Maximum retries before giving up
./pkg/embedding/cache/redis_config.go-	DialTimeout   time.Duration `json:"dial_timeout" yaml:"dial_timeout"`       // Dial timeout for establishing new connections
./pkg/embedding/cache/redis_config.go-	ReadTimeout   time.Duration `json:"read_timeout" yaml:"read_timeout"`       // Timeout for socket reads
./pkg/embedding/cache/redis_config.go-	WriteTimeout  time.Duration `json:"write_timeout" yaml:"write_timeout"`     // Timeout for socket writes
./pkg/embedding/cache/redis_config.go-	PoolTimeout   time.Duration `json:"pool_timeout" yaml:"pool_timeout"`       // Time to wait for connection from pool
./pkg/embedding/cache/redis_config.go-	IdleTimeout   time.Duration `json:"idle_timeout" yaml:"idle_timeout"`       // Time after which idle connections are closed
./pkg/embedding/cache/redis_config.go-	IdleCheckFreq time.Duration `json:"idle_check_freq" yaml:"idle_check_freq"` // Frequency of idle checks
./pkg/embedding/cache/redis_config.go-	MaxConnAge    time.Duration `json:"max_conn_age" yaml:"max_conn_age"`       // Maximum age of a connection
./pkg/embedding/cache/redis_config.go-}
./pkg/embedding/cache/redis_config.go-
./pkg/embedding/cache/redis_config.go-// DefaultRedisPoolConfig returns production-ready Redis pool configuration
./pkg/embedding/cache/redis_config.go-func DefaultRedisPoolConfig() *RedisPoolConfig {
./pkg/embedding/cache/redis_config.go-	return &RedisPoolConfig{
./pkg/embedding/cache/redis_config.go-		PoolSize:      100,              // Sufficient for most production loads
./pkg/embedding/cache/redis_config.go-		MinIdleConns:  10,               // Keep some connections ready
./pkg/embedding/cache/redis_config.go-		MaxRetries:    3,                // Retry failed commands
./pkg/embedding/cache/redis_config.go-		DialTimeout:   5 * time.Second,  // Reasonable timeout for new connections
./pkg/embedding/cache/redis_config.go-		ReadTimeout:   3 * time.Second,  // Timeout for reads
./pkg/embedding/cache/redis_config.go-		WriteTimeout:  3 * time.Second,  // Timeout for writes
./pkg/embedding/cache/redis_config.go-		PoolTimeout:   4 * time.Second,  // Wait time for connection from pool
./pkg/embedding/cache/redis_config.go-		IdleTimeout:   5 * time.Minute,  // Close idle connections after 5 minutes
./pkg/embedding/cache/redis_config.go-		IdleCheckFreq: 1 * time.Minute,  // Check for idle connections every minute
./pkg/embedding/cache/redis_config.go-		MaxConnAge:    30 * time.Minute, // Recycle connections after 30 minutes
./pkg/embedding/cache/redis_config.go-	}
./pkg/embedding/cache/redis_config.go-}
./pkg/embedding/cache/redis_config.go-
./pkg/embedding/cache/redis_config.go-// HighLoadRedisPoolConfig returns configuration optimized for high load
./pkg/embedding/cache/redis_config.go-func HighLoadRedisPoolConfig() *RedisPoolConfig {
./pkg/embedding/cache/redis_config.go-	return &RedisPoolConfig{
./pkg/embedding/cache/redis_config.go-		PoolSize:      500,             // More connections for high load
./pkg/embedding/cache/redis_config.go-		MinIdleConns:  50,              // Keep more connections ready
./pkg/embedding/cache/redis_config.go-		MaxRetries:    5,               // More retries for resilience
./pkg/embedding/cache/redis_config.go-		DialTimeout:   3 * time.Second, // Faster timeout for new connections
./pkg/embedding/cache/redis_config.go-		ReadTimeout:   2 * time.Second, // Shorter timeouts
./pkg/embedding/cache/redis_config.go-		WriteTimeout:  2 * time.Second,
./pkg/embedding/cache/redis_config.go-		PoolTimeout:   2 * time.Second,  // Don't wait too long
./pkg/embedding/cache/redis_config.go-		IdleTimeout:   3 * time.Minute,  // Close idle connections sooner
./pkg/embedding/cache/redis_config.go-		IdleCheckFreq: 30 * time.Second, // Check more frequently
./pkg/embedding/cache/redis_config.go-		MaxConnAge:    15 * time.Minute, // Recycle connections more often
./pkg/embedding/cache/redis_config.go-	}
./pkg/embedding/cache/redis_config.go-}
./pkg/embedding/cache/redis_config.go-
./pkg/embedding/cache/redis_config.go-// LowLatencyRedisPoolConfig returns configuration optimized for low latency
./pkg/embedding/cache/redis_config.go-func LowLatencyRedisPoolConfig() *RedisPoolConfig {
./pkg/embedding/cache/redis_config.go-	return &RedisPoolConfig{
./pkg/embedding/cache/redis_config.go-		PoolSize:      200,                    // Moderate pool size
./pkg/embedding/cache/redis_config.go-		MinIdleConns:  20,                     // Keep connections warm
--
./pkg/embedding/cache/eviction/lru.go:type Config struct {
./pkg/embedding/cache/eviction/lru.go-	MaxEntriesPerTenant int
./pkg/embedding/cache/eviction/lru.go-	MaxGlobalEntries    int
./pkg/embedding/cache/eviction/lru.go-	CheckInterval       time.Duration
./pkg/embedding/cache/eviction/lru.go-	BatchSize           int
./pkg/embedding/cache/eviction/lru.go-	StaleThreshold      time.Duration // Entries not accessed for this duration are candidates
./pkg/embedding/cache/eviction/lru.go-}
./pkg/embedding/cache/eviction/lru.go-
./pkg/embedding/cache/eviction/lru.go-// DefaultConfig returns default eviction configuration
./pkg/embedding/cache/eviction/lru.go-func DefaultConfig() Config {
./pkg/embedding/cache/eviction/lru.go-	return Config{
./pkg/embedding/cache/eviction/lru.go-		MaxEntriesPerTenant: 1000,
./pkg/embedding/cache/eviction/lru.go-		MaxGlobalEntries:    10000,
./pkg/embedding/cache/eviction/lru.go-		CheckInterval:       5 * time.Minute,
./pkg/embedding/cache/eviction/lru.go-		BatchSize:           100,
./pkg/embedding/cache/eviction/lru.go-		StaleThreshold:      7 * 24 * time.Hour, // 7 days
./pkg/embedding/cache/eviction/lru.go-	}
./pkg/embedding/cache/eviction/lru.go-}
./pkg/embedding/cache/eviction/lru.go-
./pkg/embedding/cache/eviction/lru.go-// NewLRUEvictor creates a new LRU evictor
./pkg/embedding/cache/eviction/lru.go-func NewLRUEvictor(
./pkg/embedding/cache/eviction/lru.go-	cache CacheInterface,
./pkg/embedding/cache/eviction/lru.go-	vectorStore VectorStore,
./pkg/embedding/cache/eviction/lru.go-	config Config,
./pkg/embedding/cache/eviction/lru.go-	logger observability.Logger,
./pkg/embedding/cache/eviction/lru.go-	metrics observability.MetricsClient,
./pkg/embedding/cache/eviction/lru.go-) *LRUEvictor {
./pkg/embedding/cache/eviction/lru.go-	if logger == nil {
./pkg/embedding/cache/eviction/lru.go-		logger = observability.NewLogger("embedding.cache.eviction.lru")
./pkg/embedding/cache/eviction/lru.go-	}
./pkg/embedding/cache/eviction/lru.go-	if metrics == nil {
./pkg/embedding/cache/eviction/lru.go-		metrics = observability.NewMetricsClient()
./pkg/embedding/cache/eviction/lru.go-	}
./pkg/embedding/cache/eviction/lru.go-
./pkg/embedding/cache/eviction/lru.go-	return &LRUEvictor{
./pkg/embedding/cache/eviction/lru.go-		cache:       cache,
./pkg/embedding/cache/eviction/lru.go-		vectorStore: vectorStore,
./pkg/embedding/cache/eviction/lru.go-		config:      config,
./pkg/embedding/cache/eviction/lru.go-		logger:      logger,
./pkg/embedding/cache/eviction/lru.go-		metrics:     metrics,
./pkg/embedding/cache/eviction/lru.go-	}
./pkg/embedding/cache/eviction/lru.go-}
./pkg/embedding/cache/eviction/lru.go-
./pkg/embedding/cache/eviction/lru.go-// EvictTenantEntries evicts LRU entries for a specific tenant
./pkg/embedding/cache/eviction/lru.go-func (e *LRUEvictor) EvictTenantEntries(ctx context.Context, tenantID uuid.UUID) error {
./pkg/embedding/cache/eviction/lru.go-	// Start span for tracing
./pkg/embedding/cache/eviction/lru.go-	ctx, span := observability.StartSpan(ctx, "lru_evictor.evict_tenant_entries")
./pkg/embedding/cache/eviction/lru.go-	defer span.End()
./pkg/embedding/cache/eviction/lru.go-
./pkg/embedding/cache/eviction/lru.go-	// Get tenant's cache stats
./pkg/embedding/cache/eviction/lru.go-	stats, err := e.vectorStore.GetTenantCacheStats(ctx, tenantID)
--
./pkg/embedding/factory.go:type EmbeddingFactoryConfig struct {
./pkg/embedding/factory.go-	// Model configuration
./pkg/embedding/factory.go-	ModelType       ModelType `json:"model_type"`
./pkg/embedding/factory.go-	ModelName       string    `json:"model_name"`
./pkg/embedding/factory.go-	ModelAPIKey     string    `json:"model_api_key,omitempty"`
./pkg/embedding/factory.go-	ModelEndpoint   string    `json:"model_endpoint,omitempty"`
./pkg/embedding/factory.go-	ModelDimensions int       `json:"model_dimensions"`
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	// Additional model parameters (used for provider-specific configurations)
./pkg/embedding/factory.go-	Parameters map[string]interface{} `json:"parameters,omitempty"`
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	// Storage configuration
./pkg/embedding/factory.go-	DatabaseConnection *sql.DB `json:"-"`
./pkg/embedding/factory.go-	DatabaseSchema     string  `json:"database_schema"`
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	// Pipeline configuration
./pkg/embedding/factory.go-	Concurrency     int  `json:"concurrency"`
./pkg/embedding/factory.go-	BatchSize       int  `json:"batch_size"`
./pkg/embedding/factory.go-	IncludeComments bool `json:"include_comments"`
./pkg/embedding/factory.go-	EnrichMetadata  bool `json:"enrich_metadata"`
./pkg/embedding/factory.go-}
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-// NewEmbeddingFactory creates a new embedding factory with the specified configuration
./pkg/embedding/factory.go-func NewEmbeddingFactory(config *EmbeddingFactoryConfig) (*EmbeddingFactory, error) {
./pkg/embedding/factory.go-	if config == nil {
./pkg/embedding/factory.go-		return nil, errors.New("configuration is required")
./pkg/embedding/factory.go-	}
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	// Validate required configuration parameters
./pkg/embedding/factory.go-	if config.ModelType == "" {
./pkg/embedding/factory.go-		return nil, errors.New("model type is required")
./pkg/embedding/factory.go-	}
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	// Check if the model type is supported
./pkg/embedding/factory.go-	if config.ModelType != ModelTypeOpenAI && config.ModelType != ModelTypeBedrock &&
./pkg/embedding/factory.go-		config.ModelType != ModelTypeHuggingFace && config.ModelType != ModelTypeAnthropic &&
./pkg/embedding/factory.go-		config.ModelType != ModelTypeCustom {
./pkg/embedding/factory.go-		return nil, fmt.Errorf("unsupported model type: %s", config.ModelType)
./pkg/embedding/factory.go-	}
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	if config.ModelName == "" {
./pkg/embedding/factory.go-		return nil, errors.New("model name is required")
./pkg/embedding/factory.go-	}
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	// Check for required API key for certain model types
./pkg/embedding/factory.go-	if config.ModelType == ModelTypeOpenAI && config.ModelAPIKey == "" {
./pkg/embedding/factory.go-		return nil, errors.New("model API key is required for OpenAI models")
./pkg/embedding/factory.go-	}
./pkg/embedding/factory.go-
./pkg/embedding/factory.go-	if config.DatabaseConnection == nil {
./pkg/embedding/factory.go-		return nil, errors.New("database connection is required")
--
./pkg/embedding/providers/provider_interface.go:type ProviderConfig struct {
./pkg/embedding/providers/provider_interface.go-	// API credentials
./pkg/embedding/providers/provider_interface.go-	APIKey          string `json:"api_key,omitempty"`
./pkg/embedding/providers/provider_interface.go-	AccessKeyID     string `json:"access_key_id,omitempty"`
./pkg/embedding/providers/provider_interface.go-	SecretAccessKey string `json:"secret_access_key,omitempty"`
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-	// Endpoints and regions
./pkg/embedding/providers/provider_interface.go-	Endpoint string `json:"endpoint,omitempty"`
./pkg/embedding/providers/provider_interface.go-	Region   string `json:"region,omitempty"`
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-	// Rate limiting
./pkg/embedding/providers/provider_interface.go-	MaxRequestsPerMinute int `json:"max_requests_per_minute,omitempty"`
./pkg/embedding/providers/provider_interface.go-	MaxTokensPerMinute   int `json:"max_tokens_per_minute,omitempty"`
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-	// Timeouts
./pkg/embedding/providers/provider_interface.go-	RequestTimeout time.Duration `json:"request_timeout,omitempty"`
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-	// Retry configuration
./pkg/embedding/providers/provider_interface.go-	MaxRetries     int           `json:"max_retries,omitempty"`
./pkg/embedding/providers/provider_interface.go-	RetryDelayBase time.Duration `json:"retry_delay_base,omitempty"`
./pkg/embedding/providers/provider_interface.go-	RetryDelayMax  time.Duration `json:"retry_delay_max,omitempty"`
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-	// Custom headers or parameters
./pkg/embedding/providers/provider_interface.go-	CustomHeaders map[string]string      `json:"custom_headers,omitempty"`
./pkg/embedding/providers/provider_interface.go-	ExtraParams   map[string]interface{} `json:"extra_params,omitempty"`
./pkg/embedding/providers/provider_interface.go-}
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-// ProviderError represents an error from a provider
./pkg/embedding/providers/provider_interface.go-type ProviderError struct {
./pkg/embedding/providers/provider_interface.go-	Provider    string         `json:"provider"`
./pkg/embedding/providers/provider_interface.go-	Code        string         `json:"code"`
./pkg/embedding/providers/provider_interface.go-	Message     string         `json:"message"`
./pkg/embedding/providers/provider_interface.go-	StatusCode  int            `json:"status_code,omitempty"`
./pkg/embedding/providers/provider_interface.go-	RetryAfter  *time.Duration `json:"retry_after,omitempty"`
./pkg/embedding/providers/provider_interface.go-	IsRetryable bool           `json:"is_retryable"`
./pkg/embedding/providers/provider_interface.go-}
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-func (e *ProviderError) Error() string {
./pkg/embedding/providers/provider_interface.go-	return fmt.Sprintf("%s provider error [%s]: %s", e.Provider, e.Code, e.Message)
./pkg/embedding/providers/provider_interface.go-}
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-// TaskType represents the type of task for embedding optimization
./pkg/embedding/providers/provider_interface.go-type TaskType string
./pkg/embedding/providers/provider_interface.go-
./pkg/embedding/providers/provider_interface.go-const (
./pkg/embedding/providers/provider_interface.go-	TaskTypeCodeAnalysis TaskType = "code_analysis"
./pkg/embedding/providers/provider_interface.go-	TaskTypeGeneralQA    TaskType = "general_qa"
./pkg/embedding/providers/provider_interface.go-	TaskTypeMultilingual TaskType = "multilingual"
./pkg/embedding/providers/provider_interface.go-	TaskTypeResearch     TaskType = "research"
./pkg/embedding/providers/provider_interface.go-	TaskTypeDefault      TaskType = "default"
./pkg/embedding/providers/provider_interface.go-)
--
./pkg/embedding/legacy_minimal_types.go:type ModelConfig struct {
./pkg/embedding/legacy_minimal_types.go-	Type       ModelType              `json:"type"`
./pkg/embedding/legacy_minimal_types.go-	Name       string                 `json:"name"`
./pkg/embedding/legacy_minimal_types.go-	APIKey     string                 `json:"api_key,omitempty"`
./pkg/embedding/legacy_minimal_types.go-	Endpoint   string                 `json:"endpoint,omitempty"`
./pkg/embedding/legacy_minimal_types.go-	Dimensions int                    `json:"dimensions"`
./pkg/embedding/legacy_minimal_types.go-	Parameters map[string]interface{} `json:"parameters,omitempty"`
./pkg/embedding/legacy_minimal_types.go-}
./pkg/embedding/legacy_minimal_types.go-
./pkg/embedding/legacy_minimal_types.go-// EmbeddingVector represents a vector embedding with metadata - TEMPORARY for legacy code cleanup
./pkg/embedding/legacy_minimal_types.go-type EmbeddingVector struct {
./pkg/embedding/legacy_minimal_types.go-	Vector      []float32              `json:"vector"`
./pkg/embedding/legacy_minimal_types.go-	Dimensions  int                    `json:"dimensions"`
./pkg/embedding/legacy_minimal_types.go-	ModelID     string                 `json:"model_id"`
./pkg/embedding/legacy_minimal_types.go-	ContentType string                 `json:"content_type"`
./pkg/embedding/legacy_minimal_types.go-	ContentID   string                 `json:"content_id"`
./pkg/embedding/legacy_minimal_types.go-	Metadata    map[string]interface{} `json:"metadata,omitempty"`
./pkg/embedding/legacy_minimal_types.go-}
./pkg/embedding/legacy_minimal_types.go-
./pkg/embedding/legacy_minimal_types.go-// EmbeddingService defines the interface for generating embeddings - TEMPORARY for legacy code cleanup
./pkg/embedding/legacy_minimal_types.go-type EmbeddingService interface {
./pkg/embedding/legacy_minimal_types.go-	GenerateEmbedding(ctx context.Context, text string, contentType string, contentID string) (*EmbeddingVector, error)
./pkg/embedding/legacy_minimal_types.go-	BatchGenerateEmbeddings(ctx context.Context, texts []string, contentType string, contentIDs []string) ([]*EmbeddingVector, error)
./pkg/embedding/legacy_minimal_types.go-	GetModelConfig() ModelConfig
./pkg/embedding/legacy_minimal_types.go-	GetModelDimensions() int
./pkg/embedding/legacy_minimal_types.go-}
./pkg/embedding/legacy_minimal_types.go-
./pkg/embedding/legacy_minimal_types.go-// EmbeddingStorage defines the interface for storing and retrieving embeddings - TEMPORARY for legacy code cleanup
./pkg/embedding/legacy_minimal_types.go-type EmbeddingStorage interface {
./pkg/embedding/legacy_minimal_types.go-	StoreEmbedding(ctx context.Context, embedding *EmbeddingVector) error
./pkg/embedding/legacy_minimal_types.go-	BatchStoreEmbeddings(ctx context.Context, embeddings []*EmbeddingVector) error
./pkg/embedding/legacy_minimal_types.go-	FindSimilarEmbeddings(ctx context.Context, embedding *EmbeddingVector, limit int, threshold float32) ([]*EmbeddingVector, error)
./pkg/embedding/legacy_minimal_types.go-	GetEmbeddingsByContentIDs(ctx context.Context, contentIDs []string) ([]*EmbeddingVector, error)
./pkg/embedding/legacy_minimal_types.go-	DeleteEmbeddingsByContentIDs(ctx context.Context, contentIDs []string) error
./pkg/embedding/legacy_minimal_types.go-}
./pkg/embedding/legacy_minimal_types.go-
./pkg/embedding/legacy_minimal_types.go-// Provider interface for embedding providers - TEMPORARY for legacy code cleanup
./pkg/embedding/legacy_minimal_types.go-type Provider interface {
./pkg/embedding/legacy_minimal_types.go-	GenerateEmbedding(ctx context.Context, content string, model string) ([]float32, error)
./pkg/embedding/legacy_minimal_types.go-	GetSupportedModels() []string
./pkg/embedding/legacy_minimal_types.go-	ValidateAPIKey() error
./pkg/embedding/legacy_minimal_types.go-}
--
./pkg/embedding/document_processor.go:type ChunkingConfig struct {
./pkg/embedding/document_processor.go-	MinChunkSize    int `json:"min_chunk_size"`
./pkg/embedding/document_processor.go-	MaxChunkSize    int `json:"max_chunk_size"`
./pkg/embedding/document_processor.go-	TargetChunkSize int `json:"target_chunk_size"`
./pkg/embedding/document_processor.go-	OverlapSize     int `json:"overlap_size"`
./pkg/embedding/document_processor.go-}
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-// ProcessDocumentWithConfig processes a document with custom chunking config
./pkg/embedding/document_processor.go-func (p *DocumentProcessor) ProcessDocumentWithConfig(ctx context.Context, doc *Document, config *ChunkingConfig) ([]*EmbeddingVector, error) {
./pkg/embedding/document_processor.go-	// Create a new chunker with custom config
./pkg/embedding/document_processor.go-	chunkerConfig := &text.Config{
./pkg/embedding/document_processor.go-		MinChunkSize:    config.MinChunkSize,
./pkg/embedding/document_processor.go-		MaxChunkSize:    config.MaxChunkSize,
./pkg/embedding/document_processor.go-		TargetChunkSize: config.TargetChunkSize,
./pkg/embedding/document_processor.go-		OverlapSize:     config.OverlapSize,
./pkg/embedding/document_processor.go-	}
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-	customChunker := text.NewSemanticChunker(p.tokenizer, chunkerConfig)
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-	// Temporarily replace the chunker
./pkg/embedding/document_processor.go-	originalChunker := p.textChunker
./pkg/embedding/document_processor.go-	p.textChunker = customChunker
./pkg/embedding/document_processor.go-	defer func() {
./pkg/embedding/document_processor.go-		p.textChunker = originalChunker
./pkg/embedding/document_processor.go-	}()
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-	return p.ProcessDocument(ctx, doc)
./pkg/embedding/document_processor.go-}
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-// BatchProcessDocuments processes multiple documents
./pkg/embedding/document_processor.go-func (p *DocumentProcessor) BatchProcessDocuments(ctx context.Context, docs []*Document) (map[string][]*EmbeddingVector, error) {
./pkg/embedding/document_processor.go-	results := make(map[string][]*EmbeddingVector)
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-	for _, doc := range docs {
./pkg/embedding/document_processor.go-		embeddings, err := p.ProcessDocument(ctx, doc)
./pkg/embedding/document_processor.go-		if err != nil {
./pkg/embedding/document_processor.go-			p.logger.Error("Failed to process document", map[string]interface{}{
./pkg/embedding/document_processor.go-				"error":       err.Error(),
./pkg/embedding/document_processor.go-				"document_id": doc.ID,
./pkg/embedding/document_processor.go-			})
./pkg/embedding/document_processor.go-			continue
./pkg/embedding/document_processor.go-		}
./pkg/embedding/document_processor.go-		results[doc.ID] = embeddings
./pkg/embedding/document_processor.go-	}
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-	return results, nil
./pkg/embedding/document_processor.go-}
./pkg/embedding/document_processor.go-
./pkg/embedding/document_processor.go-// BatchProcessDocumentsWithConfig processes multiple documents with custom config
./pkg/embedding/document_processor.go-func (p *DocumentProcessor) BatchProcessDocumentsWithConfig(ctx context.Context, docs []*Document, config *ChunkingConfig) (map[string][]*EmbeddingVector, error) {
./pkg/embedding/document_processor.go-	results := make(map[string][]*EmbeddingVector)
--
./pkg/embedding/anthropic.go:type AnthropicConfig struct {
./pkg/embedding/anthropic.go-	// Anthropic API key
./pkg/embedding/anthropic.go-	APIKey string
./pkg/embedding/anthropic.go-	// Anthropic API endpoint (optional)
./pkg/embedding/anthropic.go-	Endpoint string
./pkg/embedding/anthropic.go-	// Anthropic model name
./pkg/embedding/anthropic.go-	Model string
./pkg/embedding/anthropic.go-	// For testing environments
./pkg/embedding/anthropic.go-	UseMockEmbeddings bool
./pkg/embedding/anthropic.go-}
./pkg/embedding/anthropic.go-
./pkg/embedding/anthropic.go-// AnthropicEmbeddingService implements EmbeddingService using Anthropic
./pkg/embedding/anthropic.go-type AnthropicEmbeddingService struct {
./pkg/embedding/anthropic.go-	// HTTP client for making requests
./pkg/embedding/anthropic.go-	client *http.Client
./pkg/embedding/anthropic.go-	// Configuration for the embedding model
./pkg/embedding/anthropic.go-	config ModelConfig
./pkg/embedding/anthropic.go-	// Anthropic API key
./pkg/embedding/anthropic.go-	apiKey string
./pkg/embedding/anthropic.go-	// Anthropic API endpoint
./pkg/embedding/anthropic.go-	endpoint string
./pkg/embedding/anthropic.go-	// For testing environments when Anthropic API isn't available
./pkg/embedding/anthropic.go-	useMockEmbeddings bool
./pkg/embedding/anthropic.go-}
./pkg/embedding/anthropic.go-
./pkg/embedding/anthropic.go-// AnthropicEmbeddingRequest represents a request to the Anthropic embeddings API
./pkg/embedding/anthropic.go-type AnthropicEmbeddingRequest struct {
./pkg/embedding/anthropic.go-	Model string `json:"model"`
./pkg/embedding/anthropic.go-	Text  string `json:"text"`
./pkg/embedding/anthropic.go-}
./pkg/embedding/anthropic.go-
./pkg/embedding/anthropic.go-// AnthropicEmbeddingResponse represents a response from the Anthropic embeddings API
./pkg/embedding/anthropic.go-type AnthropicEmbeddingResponse struct {
./pkg/embedding/anthropic.go-	Object    string      `json:"object"`
./pkg/embedding/anthropic.go-	Embedding []float32   `json:"embedding"`
./pkg/embedding/anthropic.go-	Model     string      `json:"model"`
./pkg/embedding/anthropic.go-	Error     interface{} `json:"error,omitempty"`
./pkg/embedding/anthropic.go-}
./pkg/embedding/anthropic.go-
./pkg/embedding/anthropic.go-// AnthropicBatchEmbeddingRequest represents a request to the Anthropic embeddings API for batch processing
./pkg/embedding/anthropic.go-type AnthropicBatchEmbeddingRequest struct {
./pkg/embedding/anthropic.go-	Model string   `json:"model"`
./pkg/embedding/anthropic.go-	Texts []string `json:"texts"`
./pkg/embedding/anthropic.go-}
./pkg/embedding/anthropic.go-
./pkg/embedding/anthropic.go-// AnthropicBatchEmbeddingResponse represents a response from the Anthropic embeddings API for batch processing
./pkg/embedding/anthropic.go-type AnthropicBatchEmbeddingResponse struct {
./pkg/embedding/anthropic.go-	Object     string      `json:"object"`
./pkg/embedding/anthropic.go-	Embeddings [][]float32 `json:"embeddings"`
./pkg/embedding/anthropic.go-	Model      string      `json:"model"`
./pkg/embedding/anthropic.go-	Error      interface{} `json:"error,omitempty"`
--
./pkg/embedding/expansion/multi_strategy.go:type Config struct {
./pkg/embedding/expansion/multi_strategy.go-	DefaultMaxExpansions int
./pkg/embedding/expansion/multi_strategy.go-	EnabledStrategies    []ExpansionType
./pkg/embedding/expansion/multi_strategy.go-	Timeout              time.Duration
./pkg/embedding/expansion/multi_strategy.go-	CacheEnabled         bool
./pkg/embedding/expansion/multi_strategy.go-	CacheTTL             time.Duration
./pkg/embedding/expansion/multi_strategy.go-}
./pkg/embedding/expansion/multi_strategy.go-
./pkg/embedding/expansion/multi_strategy.go-// DefaultConfig returns default configuration
./pkg/embedding/expansion/multi_strategy.go-func DefaultConfig() *Config {
./pkg/embedding/expansion/multi_strategy.go-	return &Config{
./pkg/embedding/expansion/multi_strategy.go-		DefaultMaxExpansions: 10,
./pkg/embedding/expansion/multi_strategy.go-		EnabledStrategies: []ExpansionType{
./pkg/embedding/expansion/multi_strategy.go-			ExpansionTypeSynonym,
./pkg/embedding/expansion/multi_strategy.go-			ExpansionTypeHyDE,
./pkg/embedding/expansion/multi_strategy.go-			ExpansionTypeDecompose,
./pkg/embedding/expansion/multi_strategy.go-		},
./pkg/embedding/expansion/multi_strategy.go-		Timeout:      5 * time.Second,
./pkg/embedding/expansion/multi_strategy.go-		CacheEnabled: true,
./pkg/embedding/expansion/multi_strategy.go-		CacheTTL:     1 * time.Hour,
./pkg/embedding/expansion/multi_strategy.go-	}
./pkg/embedding/expansion/multi_strategy.go-}
./pkg/embedding/expansion/multi_strategy.go-
./pkg/embedding/expansion/multi_strategy.go-// NewMultiStrategyExpander creates a new multi-strategy expander
./pkg/embedding/expansion/multi_strategy.go-func NewMultiStrategyExpander(llmClient LLMClient, config *Config, logger observability.Logger) *MultiStrategyExpander {
./pkg/embedding/expansion/multi_strategy.go-	if config == nil {
./pkg/embedding/expansion/multi_strategy.go-		config = DefaultConfig()
./pkg/embedding/expansion/multi_strategy.go-	}
./pkg/embedding/expansion/multi_strategy.go-	if logger == nil {
./pkg/embedding/expansion/multi_strategy.go-		logger = observability.NewLogger("expansion.multi")
./pkg/embedding/expansion/multi_strategy.go-	}
./pkg/embedding/expansion/multi_strategy.go-
./pkg/embedding/expansion/multi_strategy.go-	expander := &MultiStrategyExpander{
./pkg/embedding/expansion/multi_strategy.go-		strategies: make(map[ExpansionType]QueryExpander),
./pkg/embedding/expansion/multi_strategy.go-		config:     config,
./pkg/embedding/expansion/multi_strategy.go-		logger:     logger,
./pkg/embedding/expansion/multi_strategy.go-		metrics:    observability.NewMetricsClient(),
./pkg/embedding/expansion/multi_strategy.go-	}
./pkg/embedding/expansion/multi_strategy.go-
./pkg/embedding/expansion/multi_strategy.go-	// Initialize strategies
./pkg/embedding/expansion/multi_strategy.go-	expander.strategies[ExpansionTypeSynonym] = NewSynonymExpander(llmClient, logger)
./pkg/embedding/expansion/multi_strategy.go-	expander.strategies[ExpansionTypeHyDE] = NewHyDEExpander(llmClient, logger)
./pkg/embedding/expansion/multi_strategy.go-	expander.strategies[ExpansionTypeDecompose] = NewDecompositionExpander(llmClient, logger)
./pkg/embedding/expansion/multi_strategy.go-
./pkg/embedding/expansion/multi_strategy.go-	return expander
./pkg/embedding/expansion/multi_strategy.go-}
./pkg/embedding/expansion/multi_strategy.go-
./pkg/embedding/expansion/multi_strategy.go-// Expand applies multiple expansion strategies
./pkg/embedding/expansion/multi_strategy.go-func (m *MultiStrategyExpander) Expand(ctx context.Context, query string, opts *ExpansionOptions) (*ExpandedQuery, error) {
./pkg/embedding/expansion/multi_strategy.go-	// Start span for tracing
./pkg/embedding/expansion/multi_strategy.go-	ctx, span := observability.StartSpan(ctx, "expansion.multi_strategy")
--
./pkg/embedding/pipeline.go:type EmbeddingPipelineConfig struct {
./pkg/embedding/pipeline.go-	// Number of goroutines to use for parallel processing
./pkg/embedding/pipeline.go-	Concurrency int
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-	// Batch size for processing
./pkg/embedding/pipeline.go-	BatchSize int
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-	// Whether to include code comments in embeddings
./pkg/embedding/pipeline.go-	IncludeComments bool
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-	// Whether to enrich embeddings with metadata
./pkg/embedding/pipeline.go-	EnrichMetadata bool
./pkg/embedding/pipeline.go-}
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-// DefaultEmbeddingPipelineConfig returns the default embedding pipeline configuration
./pkg/embedding/pipeline.go-func DefaultEmbeddingPipelineConfig() *EmbeddingPipelineConfig {
./pkg/embedding/pipeline.go-	return &EmbeddingPipelineConfig{
./pkg/embedding/pipeline.go-		Concurrency:     4,
./pkg/embedding/pipeline.go-		BatchSize:       defaultBatchSize,
./pkg/embedding/pipeline.go-		IncludeComments: true,
./pkg/embedding/pipeline.go-		EnrichMetadata:  true,
./pkg/embedding/pipeline.go-	}
./pkg/embedding/pipeline.go-}
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-// GitHubContentProvider defines the interface for accessing GitHub content
./pkg/embedding/pipeline.go-type GitHubContentProvider interface {
./pkg/embedding/pipeline.go-	// GetContent retrieves file content from GitHub
./pkg/embedding/pipeline.go-	GetContent(ctx context.Context, owner, repo, path string) ([]byte, error)
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-	// GetIssue retrieves issue details from GitHub
./pkg/embedding/pipeline.go-	GetIssue(ctx context.Context, owner, repo string, issueNumber int) (*GitHubIssueData, error)
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-	// GetIssueComments retrieves issue comments from GitHub
./pkg/embedding/pipeline.go-	GetIssueComments(ctx context.Context, owner, repo string, issueNumber int) ([]*GitHubCommentData, error)
./pkg/embedding/pipeline.go-}
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-// GitHubIssue represents a GitHub issue
./pkg/embedding/pipeline.go-type GitHubIssue struct {
./pkg/embedding/pipeline.go-	Title     string    `json:"title"`
./pkg/embedding/pipeline.go-	Body      string    `json:"body"`
./pkg/embedding/pipeline.go-	State     string    `json:"state"`
./pkg/embedding/pipeline.go-	CreatedAt time.Time `json:"created_at"`
./pkg/embedding/pipeline.go-	UpdatedAt time.Time `json:"updated_at"`
./pkg/embedding/pipeline.go-}
./pkg/embedding/pipeline.go-
./pkg/embedding/pipeline.go-// GitHubComment represents a GitHub comment
./pkg/embedding/pipeline.go-type GitHubComment struct {
./pkg/embedding/pipeline.go-	ID        int       `json:"id"`
./pkg/embedding/pipeline.go-	Body      string    `json:"body"`
./pkg/embedding/pipeline.go-	CreatedAt time.Time `json:"created_at"`
./pkg/embedding/pipeline.go-	UpdatedAt time.Time `json:"updated_at"`
--
./pkg/embedding/circuit_breaker.go:type CircuitBreakerConfig struct {
./pkg/embedding/circuit_breaker.go-	FailureThreshold    int
./pkg/embedding/circuit_breaker.go-	SuccessThreshold    int
./pkg/embedding/circuit_breaker.go-	Timeout             time.Duration
./pkg/embedding/circuit_breaker.go-	HalfOpenMaxRequests int
./pkg/embedding/circuit_breaker.go-}
./pkg/embedding/circuit_breaker.go-
./pkg/embedding/circuit_breaker.go-// CircuitBreakerStatus represents the current status
./pkg/embedding/circuit_breaker.go-type CircuitBreakerStatus struct {
./pkg/embedding/circuit_breaker.go-	State               string    `json:"state"`
./pkg/embedding/circuit_breaker.go-	FailureCount        int       `json:"failure_count"`
./pkg/embedding/circuit_breaker.go-	SuccessCount        int       `json:"success_count"`
./pkg/embedding/circuit_breaker.go-	LastFailureTime     time.Time `json:"last_failure_time,omitempty"`
./pkg/embedding/circuit_breaker.go-	LastStateChangeTime time.Time `json:"last_state_change_time"`
./pkg/embedding/circuit_breaker.go-}
./pkg/embedding/circuit_breaker.go-
./pkg/embedding/circuit_breaker.go-// NewCircuitBreaker creates a new circuit breaker
./pkg/embedding/circuit_breaker.go-func NewCircuitBreaker(config CircuitBreakerConfig) *CircuitBreaker {
./pkg/embedding/circuit_breaker.go-	return &CircuitBreaker{
./pkg/embedding/circuit_breaker.go-		config:              config,
./pkg/embedding/circuit_breaker.go-		state:               StateClosed,
./pkg/embedding/circuit_breaker.go-		lastStateChangeTime: time.Now(),
./pkg/embedding/circuit_breaker.go-	}
./pkg/embedding/circuit_breaker.go-}
./pkg/embedding/circuit_breaker.go-
./pkg/embedding/circuit_breaker.go-// CanRequest checks if a request can be made
./pkg/embedding/circuit_breaker.go-func (cb *CircuitBreaker) CanRequest() bool {
./pkg/embedding/circuit_breaker.go-	cb.mu.Lock()
./pkg/embedding/circuit_breaker.go-	defer cb.mu.Unlock()
./pkg/embedding/circuit_breaker.go-
./pkg/embedding/circuit_breaker.go-	switch cb.state {
./pkg/embedding/circuit_breaker.go-	case StateClosed:
./pkg/embedding/circuit_breaker.go-		return true
./pkg/embedding/circuit_breaker.go-	case StateOpen:
./pkg/embedding/circuit_breaker.go-		// Check if timeout has passed
./pkg/embedding/circuit_breaker.go-		if time.Since(cb.lastStateChangeTime) >= cb.config.Timeout {
./pkg/embedding/circuit_breaker.go-			cb.transitionToHalfOpen()
./pkg/embedding/circuit_breaker.go-			return true
./pkg/embedding/circuit_breaker.go-		}
./pkg/embedding/circuit_breaker.go-		return false
./pkg/embedding/circuit_breaker.go-	case StateHalfOpen:
./pkg/embedding/circuit_breaker.go-		// Allow limited requests in half-open state
./pkg/embedding/circuit_breaker.go-		if cb.halfOpenRequests < cb.config.HalfOpenMaxRequests {
./pkg/embedding/circuit_breaker.go-			cb.halfOpenRequests++
./pkg/embedding/circuit_breaker.go-			return true
./pkg/embedding/circuit_breaker.go-		}
./pkg/embedding/circuit_breaker.go-		return false
./pkg/embedding/circuit_breaker.go-	default:
./pkg/embedding/circuit_breaker.go-		return false
./pkg/embedding/circuit_breaker.go-	}
./pkg/embedding/circuit_breaker.go-}
--
./pkg/embedding/search_unified.go:type UnifiedSearchConfig struct {
./pkg/embedding/search_unified.go-	DB               *sql.DB
./pkg/embedding/search_unified.go-	Repository       *Repository
./pkg/embedding/search_unified.go-	SearchRepository repositorySearch.Repository
./pkg/embedding/search_unified.go-	EmbeddingService EmbeddingService
./pkg/embedding/search_unified.go-	DimensionAdapter *DimensionAdapter
./pkg/embedding/search_unified.go-	HybridSearch     *hybrid.HybridSearchService
./pkg/embedding/search_unified.go-	Reranker         rerank.Reranker
./pkg/embedding/search_unified.go-	QueryExpander    expansion.QueryExpander
./pkg/embedding/search_unified.go-	Logger           observability.Logger
./pkg/embedding/search_unified.go-	Metrics          observability.MetricsClient
./pkg/embedding/search_unified.go-}
./pkg/embedding/search_unified.go-
./pkg/embedding/search_unified.go-// NewUnifiedSearchService creates a new unified search service
./pkg/embedding/search_unified.go-func NewUnifiedSearchService(config *UnifiedSearchConfig) (*UnifiedSearchService, error) {
./pkg/embedding/search_unified.go-	if config.DB == nil {
./pkg/embedding/search_unified.go-		return nil, errors.New("database connection is required")
./pkg/embedding/search_unified.go-	}
./pkg/embedding/search_unified.go-	if config.EmbeddingService == nil {
./pkg/embedding/search_unified.go-		return nil, errors.New("embedding service is required")
./pkg/embedding/search_unified.go-	}
./pkg/embedding/search_unified.go-	if config.SearchRepository == nil {
./pkg/embedding/search_unified.go-		return nil, errors.New("search repository is required")
./pkg/embedding/search_unified.go-	}
./pkg/embedding/search_unified.go-
./pkg/embedding/search_unified.go-	// Create logger and metrics if not provided
./pkg/embedding/search_unified.go-	if config.Logger == nil {
./pkg/embedding/search_unified.go-		config.Logger = observability.NewLogger("embedding.search.unified")
./pkg/embedding/search_unified.go-	}
./pkg/embedding/search_unified.go-	if config.Metrics == nil {
./pkg/embedding/search_unified.go-		config.Metrics = observability.NewMetricsClient()
./pkg/embedding/search_unified.go-	}
./pkg/embedding/search_unified.go-
./pkg/embedding/search_unified.go-	// Create hybrid search service if not provided
./pkg/embedding/search_unified.go-	if config.HybridSearch == nil && config.DB != nil && config.EmbeddingService != nil {
./pkg/embedding/search_unified.go-		// Create an adapter to convert between embedding types
./pkg/embedding/search_unified.go-		adapter := &embeddingServiceAdapter{service: config.EmbeddingService}
./pkg/embedding/search_unified.go-
./pkg/embedding/search_unified.go-		hybridConfig := &hybrid.Config{
./pkg/embedding/search_unified.go-			DB:               config.DB,
./pkg/embedding/search_unified.go-			EmbeddingService: adapter,
./pkg/embedding/search_unified.go-			Logger:           config.Logger,
./pkg/embedding/search_unified.go-			Metrics:          config.Metrics,
./pkg/embedding/search_unified.go-		}
./pkg/embedding/search_unified.go-		var err error
./pkg/embedding/search_unified.go-		config.HybridSearch, err = hybrid.NewHybridSearchService(hybridConfig)
./pkg/embedding/search_unified.go-		if err != nil {
./pkg/embedding/search_unified.go-			return nil, fmt.Errorf("failed to create hybrid search service: %w", err)
./pkg/embedding/search_unified.go-		}
./pkg/embedding/search_unified.go-	}
./pkg/embedding/search_unified.go-
--
./pkg/embedding/provider_factory.go:type ProviderConfig struct {
./pkg/embedding/provider_factory.go-	// OpenAI configuration
./pkg/embedding/provider_factory.go-	OpenAIAPIKey string
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-	// AWS/Bedrock configuration
./pkg/embedding/provider_factory.go-	AWSRegion string
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-	// Google configuration
./pkg/embedding/provider_factory.go-	GoogleProjectID string
./pkg/embedding/provider_factory.go-	GoogleLocation  string
./pkg/embedding/provider_factory.go-	GoogleAPIKey    string
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-	// Voyage AI configuration
./pkg/embedding/provider_factory.go-	VoyageAPIKey string
./pkg/embedding/provider_factory.go-}
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-// NewProviderConfigFromEnv creates provider config from environment variables
./pkg/embedding/provider_factory.go-func NewProviderConfigFromEnv() *ProviderConfig {
./pkg/embedding/provider_factory.go-	return &ProviderConfig{
./pkg/embedding/provider_factory.go-		OpenAIAPIKey:    os.Getenv("OPENAI_API_KEY"),
./pkg/embedding/provider_factory.go-		AWSRegion:       getEnvOrDefault("AWS_REGION", "us-east-1"),
./pkg/embedding/provider_factory.go-		GoogleProjectID: os.Getenv("GOOGLE_PROJECT_ID"),
./pkg/embedding/provider_factory.go-		GoogleLocation:  getEnvOrDefault("GOOGLE_LOCATION", "us-central1"),
./pkg/embedding/provider_factory.go-		GoogleAPIKey:    os.Getenv("GOOGLE_API_KEY"),
./pkg/embedding/provider_factory.go-		VoyageAPIKey:    os.Getenv("VOYAGE_API_KEY"),
./pkg/embedding/provider_factory.go-	}
./pkg/embedding/provider_factory.go-}
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-// CreateProviders creates all configured providers
./pkg/embedding/provider_factory.go-func CreateProviders(config *ProviderConfig) (map[string]Provider, error) {
./pkg/embedding/provider_factory.go-	providers := make(map[string]Provider)
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-	// Create OpenAI provider if configured
./pkg/embedding/provider_factory.go-	if config.OpenAIAPIKey != "" {
./pkg/embedding/provider_factory.go-		providers[ProviderOpenAI] = NewOpenAIProvider(config.OpenAIAPIKey)
./pkg/embedding/provider_factory.go-	}
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-	// Create Bedrock provider if AWS is configured
./pkg/embedding/provider_factory.go-	if config.AWSRegion != "" {
./pkg/embedding/provider_factory.go-		bedrock, err := NewBedrockProvider(config.AWSRegion)
./pkg/embedding/provider_factory.go-		if err != nil {
./pkg/embedding/provider_factory.go-			return nil, fmt.Errorf("failed to create Bedrock provider: %w", err)
./pkg/embedding/provider_factory.go-		}
./pkg/embedding/provider_factory.go-		providers[ProviderAmazon] = bedrock
./pkg/embedding/provider_factory.go-		providers[ProviderCohere] = bedrock // Cohere models are also on Bedrock
./pkg/embedding/provider_factory.go-	}
./pkg/embedding/provider_factory.go-
./pkg/embedding/provider_factory.go-	// Create Google provider if configured
./pkg/embedding/provider_factory.go-	if config.GoogleProjectID != "" && config.GoogleAPIKey != "" {
./pkg/embedding/provider_factory.go-		providers[ProviderGoogle] = NewGoogleProvider(
./pkg/embedding/provider_factory.go-			config.GoogleProjectID,
--
./pkg/embedding/rerank/cross_encoder.go:type CrossEncoderConfig struct {
./pkg/embedding/rerank/cross_encoder.go-	Model              string
./pkg/embedding/rerank/cross_encoder.go-	BatchSize          int
./pkg/embedding/rerank/cross_encoder.go-	MaxConcurrency     int
./pkg/embedding/rerank/cross_encoder.go-	TimeoutPerBatch    time.Duration
./pkg/embedding/rerank/cross_encoder.go-	CircuitBreakerName string
./pkg/embedding/rerank/cross_encoder.go-}
./pkg/embedding/rerank/cross_encoder.go-
./pkg/embedding/rerank/cross_encoder.go-// NewCrossEncoderReranker creates a new cross-encoder reranker
./pkg/embedding/rerank/cross_encoder.go-func NewCrossEncoderReranker(
./pkg/embedding/rerank/cross_encoder.go-	provider providers.RerankProvider,
./pkg/embedding/rerank/cross_encoder.go-	config *CrossEncoderConfig,
./pkg/embedding/rerank/cross_encoder.go-	logger observability.Logger,
./pkg/embedding/rerank/cross_encoder.go-	metrics observability.MetricsClient,
./pkg/embedding/rerank/cross_encoder.go-) (*CrossEncoderReranker, error) {
./pkg/embedding/rerank/cross_encoder.go-	if provider == nil {
./pkg/embedding/rerank/cross_encoder.go-		return nil, fmt.Errorf("provider is required")
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-	if config == nil {
./pkg/embedding/rerank/cross_encoder.go-		return nil, fmt.Errorf("config is required")
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-
./pkg/embedding/rerank/cross_encoder.go-	// Set defaults
./pkg/embedding/rerank/cross_encoder.go-	if config.BatchSize <= 0 {
./pkg/embedding/rerank/cross_encoder.go-		config.BatchSize = 10
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-	if config.MaxConcurrency <= 0 {
./pkg/embedding/rerank/cross_encoder.go-		config.MaxConcurrency = 3
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-	if config.TimeoutPerBatch == 0 {
./pkg/embedding/rerank/cross_encoder.go-		config.TimeoutPerBatch = 5 * time.Second
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-	if config.CircuitBreakerName == "" {
./pkg/embedding/rerank/cross_encoder.go-		config.CircuitBreakerName = fmt.Sprintf("reranker_%s", config.Model)
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-	if logger == nil {
./pkg/embedding/rerank/cross_encoder.go-		logger = observability.NewLogger("rerank.cross_encoder")
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-	if metrics == nil {
./pkg/embedding/rerank/cross_encoder.go-		metrics = observability.NewMetricsClient()
./pkg/embedding/rerank/cross_encoder.go-	}
./pkg/embedding/rerank/cross_encoder.go-
./pkg/embedding/rerank/cross_encoder.go-	// Create circuit breaker
./pkg/embedding/rerank/cross_encoder.go-	breaker := resilience.NewCircuitBreaker(config.CircuitBreakerName, resilience.CircuitBreakerConfig{
./pkg/embedding/rerank/cross_encoder.go-		FailureThreshold:    5,
./pkg/embedding/rerank/cross_encoder.go-		FailureRatio:        0.5,
./pkg/embedding/rerank/cross_encoder.go-		ResetTimeout:        30 * time.Second,
./pkg/embedding/rerank/cross_encoder.go-		SuccessThreshold:    2,
./pkg/embedding/rerank/cross_encoder.go-		MaxRequestsHalfOpen: 10,
./pkg/embedding/rerank/cross_encoder.go-		TimeoutThreshold:    10 * time.Second,
./pkg/embedding/rerank/cross_encoder.go-	}, logger, metrics)
--
./pkg/embedding/bedrock.go:type BedrockConfig struct {
./pkg/embedding/bedrock.go-	// AWS Region
./pkg/embedding/bedrock.go-	Region string
./pkg/embedding/bedrock.go-	// AWS credentials
./pkg/embedding/bedrock.go-	AccessKeyID     string
./pkg/embedding/bedrock.go-	SecretAccessKey string
./pkg/embedding/bedrock.go-	SessionToken    string
./pkg/embedding/bedrock.go-	// Model ID
./pkg/embedding/bedrock.go-	ModelID string
./pkg/embedding/bedrock.go-	// For testing environments when AWS credentials aren't available
./pkg/embedding/bedrock.go-	UseMockEmbeddings bool
./pkg/embedding/bedrock.go-}
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-// NewBedrockEmbeddingService creates a new AWS Bedrock embedding service
./pkg/embedding/bedrock.go-func NewBedrockEmbeddingService(config *BedrockConfig) (*BedrockEmbeddingService, error) {
./pkg/embedding/bedrock.go-	if config == nil {
./pkg/embedding/bedrock.go-		return nil, errors.New("config is required for Bedrock embeddings")
./pkg/embedding/bedrock.go-	}
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-	// Validate required fields
./pkg/embedding/bedrock.go-	if config.Region == "" {
./pkg/embedding/bedrock.go-		return nil, errors.New("AWS region is required")
./pkg/embedding/bedrock.go-	}
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-	// Use default model if not specified
./pkg/embedding/bedrock.go-	if config.ModelID == "" {
./pkg/embedding/bedrock.go-		config.ModelID = defaultBedrockModel
./pkg/embedding/bedrock.go-	}
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-	// Validate model
./pkg/embedding/bedrock.go-	err := ValidateEmbeddingModel(ModelTypeBedrock, config.ModelID)
./pkg/embedding/bedrock.go-	if err != nil {
./pkg/embedding/bedrock.go-		return nil, err
./pkg/embedding/bedrock.go-	}
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-	// Get dimensions for the model
./pkg/embedding/bedrock.go-	dimensions, err := GetEmbeddingModelDimensions(ModelTypeBedrock, config.ModelID)
./pkg/embedding/bedrock.go-	if err != nil {
./pkg/embedding/bedrock.go-		return nil, err
./pkg/embedding/bedrock.go-	}
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-	// Create AWS SDK configuration
./pkg/embedding/bedrock.go-	var awsConfig aws.Config
./pkg/embedding/bedrock.go-	var optFns []func(*awsconfig.LoadOptions) error
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-	// Configure the region
./pkg/embedding/bedrock.go-	optFns = append(optFns, awsconfig.WithRegion(config.Region))
./pkg/embedding/bedrock.go-
./pkg/embedding/bedrock.go-	// If credentials are provided explicitly, use them
./pkg/embedding/bedrock.go-	if config.AccessKeyID != "" && config.SecretAccessKey != "" {
./pkg/embedding/bedrock.go-		optFns = append(optFns, awsconfig.WithCredentialsProvider(
--
./pkg/embedding/service_v2.go:type ServiceV2Config struct {
./pkg/embedding/service_v2.go-	Providers     map[string]providers.Provider
./pkg/embedding/service_v2.go-	AgentService  AgentService
./pkg/embedding/service_v2.go-	Repository    *Repository
./pkg/embedding/service_v2.go-	MetricsRepo   MetricsRepository
./pkg/embedding/service_v2.go-	Cache         EmbeddingCache
./pkg/embedding/service_v2.go-	ModelSelector ModelSelector
./pkg/embedding/service_v2.go-	RouterConfig  *RouterConfig
./pkg/embedding/service_v2.go-}
./pkg/embedding/service_v2.go-
./pkg/embedding/service_v2.go-// EmbeddingCache defines the interface for caching embeddings
./pkg/embedding/service_v2.go-type EmbeddingCache interface {
./pkg/embedding/service_v2.go-	Get(ctx context.Context, key string) (*CachedEmbedding, error)
./pkg/embedding/service_v2.go-	Set(ctx context.Context, key string, embedding *CachedEmbedding, ttl time.Duration) error
./pkg/embedding/service_v2.go-	Delete(ctx context.Context, key string) error
./pkg/embedding/service_v2.go-}
./pkg/embedding/service_v2.go-
./pkg/embedding/service_v2.go-// CachedEmbedding represents a cached embedding
./pkg/embedding/service_v2.go-type CachedEmbedding struct {
./pkg/embedding/service_v2.go-	Embedding  []float32              `json:"embedding"`
./pkg/embedding/service_v2.go-	Model      string                 `json:"model"`
./pkg/embedding/service_v2.go-	Provider   string                 `json:"provider"`
./pkg/embedding/service_v2.go-	Dimensions int                    `json:"dimensions"`
./pkg/embedding/service_v2.go-	Metadata   map[string]interface{} `json:"metadata"`
./pkg/embedding/service_v2.go-	CachedAt   time.Time              `json:"cached_at"`
./pkg/embedding/service_v2.go-}
./pkg/embedding/service_v2.go-
./pkg/embedding/service_v2.go-// MetricsRepository stores embedding metrics
./pkg/embedding/service_v2.go-type MetricsRepository interface {
./pkg/embedding/service_v2.go-	RecordMetric(ctx context.Context, metric *EmbeddingMetric) error
./pkg/embedding/service_v2.go-	GetMetrics(ctx context.Context, filter MetricsFilter) ([]*EmbeddingMetric, error)
./pkg/embedding/service_v2.go-	GetAgentCosts(ctx context.Context, agentID string, period time.Duration) (*CostSummary, error)
./pkg/embedding/service_v2.go-}
./pkg/embedding/service_v2.go-
./pkg/embedding/service_v2.go-// EmbeddingMetric represents a single metric entry
./pkg/embedding/service_v2.go-type EmbeddingMetric struct {
./pkg/embedding/service_v2.go-	ID                     uuid.UUID `json:"id" db:"id"`
./pkg/embedding/service_v2.go-	AgentID                string    `json:"agent_id" db:"agent_id"`
./pkg/embedding/service_v2.go-	ModelProvider          string    `json:"model_provider" db:"model_provider"`
./pkg/embedding/service_v2.go-	ModelName              string    `json:"model_name" db:"model_name"`
./pkg/embedding/service_v2.go-	ModelDimensions        int       `json:"model_dimensions" db:"model_dimensions"`
./pkg/embedding/service_v2.go-	RequestID              uuid.UUID `json:"request_id" db:"request_id"`
./pkg/embedding/service_v2.go-	TokenCount             int       `json:"token_count" db:"token_count"`
./pkg/embedding/service_v2.go-	TotalLatencyMs         int       `json:"total_latency_ms" db:"total_latency_ms"`
./pkg/embedding/service_v2.go-	ProviderLatencyMs      int       `json:"provider_latency_ms" db:"provider_latency_ms"`
./pkg/embedding/service_v2.go-	NormalizationLatencyMs int       `json:"normalization_latency_ms" db:"normalization_latency_ms"`
./pkg/embedding/service_v2.go-	CostUSD                float64   `json:"cost_usd" db:"cost_usd"`
./pkg/embedding/service_v2.go-	Status                 string    `json:"status" db:"status"`
./pkg/embedding/service_v2.go-	ErrorMessage           string    `json:"error_message" db:"error_message"`
./pkg/embedding/service_v2.go-	RetryCount             int       `json:"retry_count" db:"retry_count"`
./pkg/embedding/service_v2.go-	FinalProvider          string    `json:"final_provider" db:"final_provider"`
--
./pkg/embedding/router.go:type RouterConfig struct {
./pkg/embedding/router.go-	CircuitBreakerConfig CircuitBreakerConfig
./pkg/embedding/router.go-	LoadBalancerConfig   LoadBalancerConfig
./pkg/embedding/router.go-	CostOptimizerConfig  CostOptimizerConfig
./pkg/embedding/router.go-	QualityConfig        QualityConfig
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-// DefaultRouterConfig returns default router configuration
./pkg/embedding/router.go-func DefaultRouterConfig() *RouterConfig {
./pkg/embedding/router.go-	return &RouterConfig{
./pkg/embedding/router.go-		CircuitBreakerConfig: CircuitBreakerConfig{
./pkg/embedding/router.go-			FailureThreshold:    5,
./pkg/embedding/router.go-			SuccessThreshold:    2,
./pkg/embedding/router.go-			Timeout:             30 * time.Second,
./pkg/embedding/router.go-			HalfOpenMaxRequests: 3,
./pkg/embedding/router.go-		},
./pkg/embedding/router.go-		LoadBalancerConfig: LoadBalancerConfig{
./pkg/embedding/router.go-			Strategy: "weighted_round_robin",
./pkg/embedding/router.go-		},
./pkg/embedding/router.go-		CostOptimizerConfig: CostOptimizerConfig{
./pkg/embedding/router.go-			MaxCostPerRequest: 0.01,
./pkg/embedding/router.go-		},
./pkg/embedding/router.go-		QualityConfig: QualityConfig{
./pkg/embedding/router.go-			MinQualityScore: 0.8,
./pkg/embedding/router.go-		},
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-// RoutingRequest represents a request for routing decision
./pkg/embedding/router.go-type RoutingRequest struct {
./pkg/embedding/router.go-	AgentConfig *agents.AgentConfig
./pkg/embedding/router.go-	TaskType    agents.TaskType
./pkg/embedding/router.go-	RequestID   string
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-// RoutingDecision represents the routing decision
./pkg/embedding/router.go-type RoutingDecision struct {
./pkg/embedding/router.go-	Candidates []ProviderCandidate
./pkg/embedding/router.go-	Strategy   string
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-// ProviderCandidate represents a provider/model candidate
./pkg/embedding/router.go-type ProviderCandidate struct {
./pkg/embedding/router.go-	Provider string
./pkg/embedding/router.go-	Model    string
./pkg/embedding/router.go-	Score    float64
./pkg/embedding/router.go-	Reasons  []string
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-// NewSmartRouter creates a new smart router
./pkg/embedding/router.go-func NewSmartRouter(config *RouterConfig, providers map[string]providers.Provider) *SmartRouter {
--
./pkg/embedding/router.go:type LoadBalancerConfig struct {
./pkg/embedding/router.go-	Strategy string
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-type ProviderLoad struct {
./pkg/embedding/router.go-	CurrentRequests int
./pkg/embedding/router.go-	AvgLatency      time.Duration
./pkg/embedding/router.go-	LastUpdated     time.Time
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func NewLoadBalancer(config LoadBalancerConfig) *LoadBalancer {
./pkg/embedding/router.go-	return &LoadBalancer{
./pkg/embedding/router.go-		config: config,
./pkg/embedding/router.go-		loads:  make(map[string]*ProviderLoad),
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func (lb *LoadBalancer) GetLoad(provider string) float64 {
./pkg/embedding/router.go-	lb.mu.RLock()
./pkg/embedding/router.go-	defer lb.mu.RUnlock()
./pkg/embedding/router.go-
./pkg/embedding/router.go-	if load, ok := lb.loads[provider]; ok {
./pkg/embedding/router.go-		// Simple load calculation based on current requests and latency
./pkg/embedding/router.go-		return float64(load.CurrentRequests) * float64(load.AvgLatency.Milliseconds()) / 1000.0
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-	return 0
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func (lb *LoadBalancer) RecordLatency(provider string, latency time.Duration) {
./pkg/embedding/router.go-	lb.mu.Lock()
./pkg/embedding/router.go-	defer lb.mu.Unlock()
./pkg/embedding/router.go-
./pkg/embedding/router.go-	if load, ok := lb.loads[provider]; ok {
./pkg/embedding/router.go-		// Simple moving average
./pkg/embedding/router.go-		load.AvgLatency = (load.AvgLatency + latency) / 2
./pkg/embedding/router.go-		load.LastUpdated = time.Now()
./pkg/embedding/router.go-	} else {
./pkg/embedding/router.go-		lb.loads[provider] = &ProviderLoad{
./pkg/embedding/router.go-			AvgLatency:  latency,
./pkg/embedding/router.go-			LastUpdated: time.Now(),
./pkg/embedding/router.go-		}
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-// CostOptimizer tracks and optimizes costs
./pkg/embedding/router.go-type CostOptimizer struct {
./pkg/embedding/router.go-	config CostOptimizerConfig
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go:type CostOptimizerConfig struct {
./pkg/embedding/router.go-	MaxCostPerRequest float64
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func NewCostOptimizer(config CostOptimizerConfig) *CostOptimizer {
./pkg/embedding/router.go-	return &CostOptimizer{
./pkg/embedding/router.go-		config: config,
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-// QualityTracker tracks provider quality
./pkg/embedding/router.go-type QualityTracker struct {
./pkg/embedding/router.go-	config QualityConfig
./pkg/embedding/router.go-	scores map[string]*QualityScore
./pkg/embedding/router.go-	mu     sync.RWMutex
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go:type QualityConfig struct {
./pkg/embedding/router.go-	MinQualityScore float64
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-type QualityScore struct {
./pkg/embedding/router.go-	SuccessCount int
./pkg/embedding/router.go-	FailureCount int
./pkg/embedding/router.go-	LastUpdated  time.Time
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func NewQualityTracker(config QualityConfig) *QualityTracker {
./pkg/embedding/router.go-	return &QualityTracker{
./pkg/embedding/router.go-		config: config,
./pkg/embedding/router.go-		scores: make(map[string]*QualityScore),
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func (qt *QualityTracker) GetScore(provider, model string) float64 {
./pkg/embedding/router.go-	qt.mu.RLock()
./pkg/embedding/router.go-	defer qt.mu.RUnlock()
./pkg/embedding/router.go-
./pkg/embedding/router.go-	key := fmt.Sprintf("%s:%s", provider, model)
./pkg/embedding/router.go-	if score, ok := qt.scores[key]; ok {
./pkg/embedding/router.go-		total := score.SuccessCount + score.FailureCount
./pkg/embedding/router.go-		if total == 0 {
./pkg/embedding/router.go-			return 1.0 // Default to perfect score
./pkg/embedding/router.go-		}
./pkg/embedding/router.go-		return float64(score.SuccessCount) / float64(total)
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-	return 1.0 // Default to perfect score for new providers
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func (qt *QualityTracker) RecordSuccess(provider string) {
./pkg/embedding/router.go-	qt.mu.Lock()
./pkg/embedding/router.go-	defer qt.mu.Unlock()
./pkg/embedding/router.go-
./pkg/embedding/router.go-	if score, ok := qt.scores[provider]; ok {
./pkg/embedding/router.go-		score.SuccessCount++
./pkg/embedding/router.go-		score.LastUpdated = time.Now()
./pkg/embedding/router.go-	} else {
./pkg/embedding/router.go-		qt.scores[provider] = &QualityScore{
./pkg/embedding/router.go-			SuccessCount: 1,
./pkg/embedding/router.go-			LastUpdated:  time.Now(),
./pkg/embedding/router.go-		}
./pkg/embedding/router.go-	}
./pkg/embedding/router.go-}
./pkg/embedding/router.go-
./pkg/embedding/router.go-func (qt *QualityTracker) RecordFailure(provider string) {
./pkg/embedding/router.go-	qt.mu.Lock()
./pkg/embedding/router.go-	defer qt.mu.Unlock()
./pkg/embedding/router.go-
--
./pkg/embedding/hybrid/service.go:type Config struct {
./pkg/embedding/hybrid/service.go-	DB                 *sql.DB
./pkg/embedding/hybrid/service.go-	EmbeddingService   EmbeddingService
./pkg/embedding/hybrid/service.go-	Logger             observability.Logger
./pkg/embedding/hybrid/service.go-	Metrics            observability.MetricsClient
./pkg/embedding/hybrid/service.go-	MaxConcurrency     int64
./pkg/embedding/hybrid/service.go-	CircuitBreakerName string
./pkg/embedding/hybrid/service.go-}
./pkg/embedding/hybrid/service.go-
./pkg/embedding/hybrid/service.go-// SearchOptions contains options for hybrid search
./pkg/embedding/hybrid/service.go-type SearchOptions struct {
./pkg/embedding/hybrid/service.go-	Query             string                 // Search query text
./pkg/embedding/hybrid/service.go-	Limit             int                    // Maximum results to return
./pkg/embedding/hybrid/service.go-	Offset            int                    // Pagination offset
./pkg/embedding/hybrid/service.go-	VectorWeight      float32                // Weight for vector search (0-1)
./pkg/embedding/hybrid/service.go-	KeywordWeight     float32                // Weight for keyword search (0-1)
./pkg/embedding/hybrid/service.go-	MinSimilarity     float32                // Minimum similarity threshold
./pkg/embedding/hybrid/service.go-	Filters           map[string]interface{} // Metadata filters
./pkg/embedding/hybrid/service.go-	UseReranking      bool                   // Whether to use reranking
./pkg/embedding/hybrid/service.go-	IncludeContent    bool                   // Include full content in results
./pkg/embedding/hybrid/service.go-	HighlightKeywords bool                   // Highlight matched keywords
./pkg/embedding/hybrid/service.go-	ExpandQuery       bool                   // Use query expansion
./pkg/embedding/hybrid/service.go-	SearchModels      []string               // Specific models to search
./pkg/embedding/hybrid/service.go-	ExcludeModels     []string               // Models to exclude
./pkg/embedding/hybrid/service.go-	AgentID           *uuid.UUID             // Filter by agent ID
./pkg/embedding/hybrid/service.go-	ContentTypes      []string               // Filter by content types
./pkg/embedding/hybrid/service.go-	DateFrom          *time.Time             // Filter by date range
./pkg/embedding/hybrid/service.go-	DateTo            *time.Time             // Filter by date range
./pkg/embedding/hybrid/service.go-	FusionK           int                    // K parameter for RRF (default 60)
./pkg/embedding/hybrid/service.go-}
./pkg/embedding/hybrid/service.go-
./pkg/embedding/hybrid/service.go-// SearchResult represents a single search result
./pkg/embedding/hybrid/service.go-type SearchResult struct {
./pkg/embedding/hybrid/service.go-	ID              uuid.UUID              `json:"id"`
./pkg/embedding/hybrid/service.go-	ContentID       string                 `json:"content_id"`
./pkg/embedding/hybrid/service.go-	Content         string                 `json:"content"`
./pkg/embedding/hybrid/service.go-	ContentType     string                 `json:"content_type"`
./pkg/embedding/hybrid/service.go-	VectorScore     float32                `json:"vector_score"`
./pkg/embedding/hybrid/service.go-	KeywordScore    float32                `json:"keyword_score"`
./pkg/embedding/hybrid/service.go-	HybridScore     float32                `json:"hybrid_score"`
./pkg/embedding/hybrid/service.go-	HighlightedText string                 `json:"highlighted_text,omitempty"`
./pkg/embedding/hybrid/service.go-	Metadata        map[string]interface{} `json:"metadata"`
./pkg/embedding/hybrid/service.go-	ModelName       string                 `json:"model_name"`
./pkg/embedding/hybrid/service.go-	CreatedAt       time.Time              `json:"created_at"`
./pkg/embedding/hybrid/service.go-}
./pkg/embedding/hybrid/service.go-
./pkg/embedding/hybrid/service.go-// SearchResults contains the search results and metadata
./pkg/embedding/hybrid/service.go-type SearchResults struct {
./pkg/embedding/hybrid/service.go-	Results       []*SearchResult `json:"results"`
./pkg/embedding/hybrid/service.go-	TotalResults  int             `json:"total_results"`
./pkg/embedding/hybrid/service.go-	SearchTime    float64         `json:"search_time_ms"`
--
./pkg/agents/config.go:type AgentConfig struct {
./pkg/agents/config.go-	ID                uuid.UUID              `json:"id" db:"id"`
./pkg/agents/config.go-	AgentID           string                 `json:"agent_id" db:"agent_id" validate:"required,min=3,max=255"`
./pkg/agents/config.go-	Version           int                    `json:"version" db:"version"`
./pkg/agents/config.go-	EmbeddingStrategy EmbeddingStrategy      `json:"embedding_strategy" db:"embedding_strategy" validate:"required,oneof=balanced quality speed cost"`
./pkg/agents/config.go-	ModelPreferences  []ModelPreference      `json:"model_preferences" db:"model_preferences" validate:"required,dive"`
./pkg/agents/config.go-	Constraints       AgentConstraints       `json:"constraints" db:"constraints" validate:"required"`
./pkg/agents/config.go-	FallbackBehavior  FallbackConfig         `json:"fallback_behavior" db:"fallback_behavior"`
./pkg/agents/config.go-	Metadata          map[string]interface{} `json:"metadata" db:"metadata"`
./pkg/agents/config.go-	IsActive          bool                   `json:"is_active" db:"is_active"`
./pkg/agents/config.go-	CreatedAt         time.Time              `json:"created_at" db:"created_at"`
./pkg/agents/config.go-	UpdatedAt         time.Time              `json:"updated_at" db:"updated_at"`
./pkg/agents/config.go-	CreatedBy         string                 `json:"created_by" db:"created_by"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// ModelPreference defines which models an agent prefers for specific tasks
./pkg/agents/config.go-type ModelPreference struct {
./pkg/agents/config.go-	TaskType       TaskType `json:"task_type" validate:"required,oneof=code_analysis general_qa multilingual research"`
./pkg/agents/config.go-	PrimaryModels  []string `json:"primary_models" validate:"required,min=1"`
./pkg/agents/config.go-	FallbackModels []string `json:"fallback_models"`
./pkg/agents/config.go-	Weight         float64  `json:"weight" validate:"min=0,max=1"` // For weighted selection
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// AgentConstraints defines operational constraints for an agent
./pkg/agents/config.go-type AgentConstraints struct {
./pkg/agents/config.go-	MaxCostPerMonthUSD float64         `json:"max_cost_per_month_usd" validate:"min=0"`
./pkg/agents/config.go-	MaxLatencyP99Ms    int             `json:"max_latency_p99_ms" validate:"min=0"`
./pkg/agents/config.go-	MinAvailabilitySLA float64         `json:"min_availability_sla" validate:"min=0,max=1"`
./pkg/agents/config.go-	RateLimits         RateLimitConfig `json:"rate_limits"`
./pkg/agents/config.go-	QualityThresholds  QualityConfig   `json:"quality_thresholds"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// RateLimitConfig defines rate limiting constraints
./pkg/agents/config.go:type RateLimitConfig struct {
./pkg/agents/config.go-	RequestsPerMinute  int `json:"requests_per_minute" validate:"min=0"`
./pkg/agents/config.go-	TokensPerHour      int `json:"tokens_per_hour" validate:"min=0"`
./pkg/agents/config.go-	ConcurrentRequests int `json:"concurrent_requests" validate:"min=0"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// QualityConfig defines quality thresholds
./pkg/agents/config.go:type QualityConfig struct {
./pkg/agents/config.go-	MinCosineSimilarity   float64 `json:"min_cosine_similarity" validate:"min=0,max=1"`
./pkg/agents/config.go-	MinEmbeddingMagnitude float64 `json:"min_embedding_magnitude" validate:"min=0"`
./pkg/agents/config.go-	AcceptableErrorRate   float64 `json:"acceptable_error_rate" validate:"min=0,max=1"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// FallbackConfig defines behavior when primary models fail
./pkg/agents/config.go:type FallbackConfig struct {
./pkg/agents/config.go-	MaxRetries      int           `json:"max_retries" validate:"min=0,max=10"`
./pkg/agents/config.go-	InitialDelayMs  int           `json:"initial_delay_ms" validate:"min=0"`
./pkg/agents/config.go-	MaxDelayMs      int           `json:"max_delay_ms" validate:"min=0"`
./pkg/agents/config.go-	ExponentialBase float64       `json:"exponential_base" validate:"min=1,max=10"`
./pkg/agents/config.go-	QueueOnFailure  bool          `json:"queue_on_failure"`
./pkg/agents/config.go-	QueueTimeoutMs  int           `json:"queue_timeout_ms" validate:"min=0"`
./pkg/agents/config.go-	CircuitBreaker  CircuitConfig `json:"circuit_breaker"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// CircuitConfig defines circuit breaker settings
./pkg/agents/config.go:type CircuitConfig struct {
./pkg/agents/config.go-	Enabled          bool `json:"enabled"`
./pkg/agents/config.go-	FailureThreshold int  `json:"failure_threshold" validate:"min=1"`
./pkg/agents/config.go-	SuccessThreshold int  `json:"success_threshold" validate:"min=1"`
./pkg/agents/config.go-	TimeoutSeconds   int  `json:"timeout_seconds" validate:"min=1"`
./pkg/agents/config.go-	HalfOpenRequests int  `json:"half_open_requests" validate:"min=1"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// ConfigFilter for querying agent configurations
./pkg/agents/config.go-type ConfigFilter struct {
./pkg/agents/config.go-	AgentID   *string            `json:"agent_id,omitempty"`
./pkg/agents/config.go-	IsActive  *bool              `json:"is_active,omitempty"`
./pkg/agents/config.go-	Strategy  *EmbeddingStrategy `json:"strategy,omitempty"`
./pkg/agents/config.go-	CreatedBy *string            `json:"created_by,omitempty"`
./pkg/agents/config.go-	Limit     int                `json:"limit,omitempty"`
./pkg/agents/config.go-	Offset    int                `json:"offset,omitempty"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// ConfigUpdateRequest represents a request to update agent configuration
./pkg/agents/config.go-type ConfigUpdateRequest struct {
./pkg/agents/config.go-	EmbeddingStrategy *EmbeddingStrategy     `json:"embedding_strategy,omitempty"`
./pkg/agents/config.go-	ModelPreferences  []ModelPreference      `json:"model_preferences,omitempty"`
./pkg/agents/config.go-	Constraints       *AgentConstraints      `json:"constraints,omitempty"`
./pkg/agents/config.go-	FallbackBehavior  *FallbackConfig        `json:"fallback_behavior,omitempty"`
./pkg/agents/config.go-	Metadata          map[string]interface{} `json:"metadata,omitempty"`
./pkg/agents/config.go-	UpdatedBy         string                 `json:"updated_by" validate:"required"`
./pkg/agents/config.go-}
./pkg/agents/config.go-
./pkg/agents/config.go-// Validate validates the agent configuration
./pkg/agents/config.go-func (c *AgentConfig) Validate() error {
./pkg/agents/config.go-	if c.AgentID == "" {
./pkg/agents/config.go-		return fmt.Errorf("agent_id is required")
./pkg/agents/config.go-	}
./pkg/agents/config.go-
./pkg/agents/config.go-	if len(c.ModelPreferences) == 0 {
./pkg/agents/config.go-		return fmt.Errorf("at least one model preference is required")
./pkg/agents/config.go-	}
./pkg/agents/config.go-
./pkg/agents/config.go-	// Validate each model preference
./pkg/agents/config.go-	taskTypes := make(map[TaskType]bool)
./pkg/agents/config.go-	for _, pref := range c.ModelPreferences {
./pkg/agents/config.go-		if taskTypes[pref.TaskType] {
./pkg/agents/config.go-			return fmt.Errorf("duplicate task type: %s", pref.TaskType)
./pkg/agents/config.go-		}
./pkg/agents/config.go-		taskTypes[pref.TaskType] = true
./pkg/agents/config.go-
./pkg/agents/config.go-		if len(pref.PrimaryModels) == 0 {
./pkg/agents/config.go-			return fmt.Errorf("at least one primary model is required for task type: %s", pref.TaskType)
./pkg/agents/config.go-		}
./pkg/agents/config.go-	}
./pkg/agents/config.go-
--
./pkg/models/task_extended.go:type AggregationConfig struct {
./pkg/models/task_extended.go-	Method     string `json:"method"`       // combine_results, first_complete, majority_vote
./pkg/models/task_extended.go-	WaitForAll bool   `json:"wait_for_all"` // Whether to wait for all subtasks
./pkg/models/task_extended.go-	Timeout    int    `json:"timeout"`      // Timeout in seconds
./pkg/models/task_extended.go-}
./pkg/models/task_extended.go-
./pkg/models/task_extended.go-// TaskStats represents task statistics
./pkg/models/task_extended.go-type TaskStats struct {
./pkg/models/task_extended.go-	TotalTasks      int64                  `json:"total_tasks"`
./pkg/models/task_extended.go-	TasksByStatus   map[TaskStatus]int64   `json:"tasks_by_status"`
./pkg/models/task_extended.go-	TasksByPriority map[TaskPriority]int64 `json:"tasks_by_priority"`
./pkg/models/task_extended.go-	TasksByType     map[string]int64       `json:"tasks_by_type"`
./pkg/models/task_extended.go-	AverageTime     float64                `json:"average_time_seconds"`
./pkg/models/task_extended.go-	SuccessRate     float64                `json:"success_rate"`
./pkg/models/task_extended.go-}
./pkg/models/task_extended.go-
./pkg/models/task_extended.go-// AgentPerformance represents agent performance metrics
./pkg/models/task_extended.go-type AgentPerformance struct {
./pkg/models/task_extended.go-	AgentID               string                 `json:"agent_id"`
./pkg/models/task_extended.go-	TasksCompleted        int64                  `json:"tasks_completed"`
./pkg/models/task_extended.go-	TasksFailed           int64                  `json:"tasks_failed"`
./pkg/models/task_extended.go-	AverageCompletionTime float64                `json:"average_completion_time"`
./pkg/models/task_extended.go-	SuccessRate           float64                `json:"success_rate"`
./pkg/models/task_extended.go-	LoadFactor            float64                `json:"load_factor"`
./pkg/models/task_extended.go-	SpeedScore            float64                `json:"speed_score"`
./pkg/models/task_extended.go-	TaskTypeMetrics       map[string]TaskMetrics `json:"task_type_metrics"`
./pkg/models/task_extended.go-}
./pkg/models/task_extended.go-
./pkg/models/task_extended.go-// TaskMetrics represents metrics for a specific task type
./pkg/models/task_extended.go-type TaskMetrics struct {
./pkg/models/task_extended.go-	Count       int64   `json:"count"`
./pkg/models/task_extended.go-	SuccessRate float64 `json:"success_rate"`
./pkg/models/task_extended.go-	AverageTime float64 `json:"average_time"`
./pkg/models/task_extended.go-	MedianTime  float64 `json:"median_time"`
./pkg/models/task_extended.go-	P95Time     float64 `json:"p95_time"`
./pkg/models/task_extended.go-}
./pkg/models/task_extended.go-
./pkg/models/task_extended.go-// TaskCreatedEvent represents a task creation event
./pkg/models/task_extended.go-type TaskCreatedEvent struct {
./pkg/models/task_extended.go-	Task *Task `json:"task"`
./pkg/models/task_extended.go-}
./pkg/models/task_extended.go-
./pkg/models/task_extended.go-// SubtaskCreatedEvent represents a subtask creation event
./pkg/models/task_extended.go-type SubtaskCreatedEvent struct {
./pkg/models/task_extended.go-	ParentTask *Task `json:"parent_task"`
./pkg/models/task_extended.go-	Subtask    *Task `json:"subtask"`
./pkg/models/task_extended.go-}
./pkg/models/task_extended.go-
./pkg/models/task_extended.go-// TaskDelegatedEvent represents a task delegation event
./pkg/models/task_extended.go-type TaskDelegatedEvent struct {
./pkg/models/task_extended.go-	Task          *Task           `json:"task"`
--
./pkg/models/tenant_config.go:type TenantConfig struct {
./pkg/models/tenant_config.go-	ID              string                 `json:"id" db:"id"`
./pkg/models/tenant_config.go-	TenantID        string                 `json:"tenant_id" db:"tenant_id"`
./pkg/models/tenant_config.go-	RateLimitConfig RateLimitConfig        `json:"rate_limit_config" db:"rate_limit_config"`
./pkg/models/tenant_config.go-	ServiceTokens   map[string]string      `json:"-" db:"-"`              // Decrypted in memory only
./pkg/models/tenant_config.go-	EncryptedTokens json.RawMessage        `json:"-" db:"service_tokens"` // Encrypted in database
./pkg/models/tenant_config.go-	AllowedOrigins  pq.StringArray         `json:"allowed_origins" db:"allowed_origins"`
./pkg/models/tenant_config.go-	Features        map[string]interface{} `json:"features" db:"-"` // Parsed from JSONB
./pkg/models/tenant_config.go-	FeaturesJSON    json.RawMessage        `json:"-" db:"features"` // Raw JSONB from database
./pkg/models/tenant_config.go-	CreatedAt       time.Time              `json:"created_at" db:"created_at"`
./pkg/models/tenant_config.go-	UpdatedAt       time.Time              `json:"updated_at" db:"updated_at"`
./pkg/models/tenant_config.go-}
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-// RateLimitConfig represents rate limiting configuration
./pkg/models/tenant_config.go:type RateLimitConfig struct {
./pkg/models/tenant_config.go-	// Default rate limits
./pkg/models/tenant_config.go-	DefaultRequestsPerMinute int `json:"default_requests_per_minute"`
./pkg/models/tenant_config.go-	DefaultRequestsPerHour   int `json:"default_requests_per_hour"`
./pkg/models/tenant_config.go-	DefaultRequestsPerDay    int `json:"default_requests_per_day"`
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-	// Key type specific overrides
./pkg/models/tenant_config.go-	KeyTypeOverrides map[string]KeyTypeRateLimit `json:"key_type_overrides,omitempty"`
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-	// Endpoint specific overrides
./pkg/models/tenant_config.go-	EndpointOverrides map[string]EndpointRateLimit `json:"endpoint_overrides,omitempty"`
./pkg/models/tenant_config.go-}
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-// KeyTypeRateLimit represents rate limits for a specific key type
./pkg/models/tenant_config.go-type KeyTypeRateLimit struct {
./pkg/models/tenant_config.go-	RequestsPerMinute int `json:"requests_per_minute"`
./pkg/models/tenant_config.go-	RequestsPerHour   int `json:"requests_per_hour"`
./pkg/models/tenant_config.go-	RequestsPerDay    int `json:"requests_per_day"`
./pkg/models/tenant_config.go-}
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-// EndpointRateLimit represents rate limits for a specific endpoint
./pkg/models/tenant_config.go-type EndpointRateLimit struct {
./pkg/models/tenant_config.go-	RequestsPerMinute int `json:"requests_per_minute"`
./pkg/models/tenant_config.go-	BurstSize         int `json:"burst_size"`
./pkg/models/tenant_config.go-}
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-// Scan implements sql.Scanner for RateLimitConfig
./pkg/models/tenant_config.go-func (r *RateLimitConfig) Scan(value interface{}) error {
./pkg/models/tenant_config.go-	if value == nil {
./pkg/models/tenant_config.go-		*r = RateLimitConfig{}
./pkg/models/tenant_config.go-		return nil
./pkg/models/tenant_config.go-	}
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-	switch v := value.(type) {
./pkg/models/tenant_config.go-	case []byte:
./pkg/models/tenant_config.go-		return json.Unmarshal(v, r)
./pkg/models/tenant_config.go-	case string:
./pkg/models/tenant_config.go-		return json.Unmarshal([]byte(v), r)
./pkg/models/tenant_config.go-	default:
./pkg/models/tenant_config.go-		return json.Unmarshal([]byte("{}"), r)
./pkg/models/tenant_config.go-	}
./pkg/models/tenant_config.go-}
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-// Value implements driver.Valuer for RateLimitConfig
./pkg/models/tenant_config.go-func (r RateLimitConfig) Value() (driver.Value, error) {
./pkg/models/tenant_config.go-	return json.Marshal(r)
./pkg/models/tenant_config.go-}
./pkg/models/tenant_config.go-
./pkg/models/tenant_config.go-// DefaultTenantConfig returns a default configuration for a tenant
./pkg/models/tenant_config.go-func DefaultTenantConfig(tenantID string) *TenantConfig {
./pkg/models/tenant_config.go-	return &TenantConfig{
--
./pkg/models/webhook_config.go:type WebhookConfig struct {
./pkg/models/webhook_config.go-	ID               uuid.UUID      `json:"id" db:"id"`
./pkg/models/webhook_config.go-	OrganizationName string         `json:"organization_name" db:"organization_name"`
./pkg/models/webhook_config.go-	WebhookSecret    string         `json:"-" db:"webhook_secret"` // Never expose in JSON
./pkg/models/webhook_config.go-	Enabled          bool           `json:"enabled" db:"enabled"`
./pkg/models/webhook_config.go-	AllowedEvents    pq.StringArray `json:"allowed_events" db:"allowed_events"`
./pkg/models/webhook_config.go-	Metadata         JSONMap        `json:"metadata" db:"metadata"`
./pkg/models/webhook_config.go-	CreatedAt        time.Time      `json:"created_at" db:"created_at"`
./pkg/models/webhook_config.go-	UpdatedAt        time.Time      `json:"updated_at" db:"updated_at"`
./pkg/models/webhook_config.go-}
./pkg/models/webhook_config.go-
./pkg/models/webhook_config.go-// WebhookConfigCreate represents the data needed to create a new webhook configuration
./pkg/models/webhook_config.go-type WebhookConfigCreate struct {
./pkg/models/webhook_config.go-	OrganizationName string         `json:"organization_name" validate:"required,min=1,max=255"`
./pkg/models/webhook_config.go-	WebhookSecret    string         `json:"webhook_secret" validate:"required,min=32"` // Require strong secrets
./pkg/models/webhook_config.go-	AllowedEvents    []string       `json:"allowed_events,omitempty"`
./pkg/models/webhook_config.go-	Metadata         map[string]any `json:"metadata,omitempty"`
./pkg/models/webhook_config.go-}
./pkg/models/webhook_config.go-
./pkg/models/webhook_config.go-// WebhookConfigUpdate represents the data needed to update a webhook configuration
./pkg/models/webhook_config.go-type WebhookConfigUpdate struct {
./pkg/models/webhook_config.go-	Enabled       *bool          `json:"enabled,omitempty"`
./pkg/models/webhook_config.go-	WebhookSecret *string        `json:"webhook_secret,omitempty" validate:"omitempty,min=32"`
./pkg/models/webhook_config.go-	AllowedEvents []string       `json:"allowed_events,omitempty"`
./pkg/models/webhook_config.go-	Metadata      map[string]any `json:"metadata,omitempty"`
./pkg/models/webhook_config.go-}
./pkg/models/webhook_config.go-
./pkg/models/webhook_config.go-// WebhookConfigList represents a list of webhook configurations
./pkg/models/webhook_config.go-type WebhookConfigList struct {
./pkg/models/webhook_config.go-	Items      []*WebhookConfig `json:"items"`
./pkg/models/webhook_config.go-	TotalCount int              `json:"total_count"`
./pkg/models/webhook_config.go-}
./pkg/models/webhook_config.go-
./pkg/models/webhook_config.go-// Validate checks if the webhook configuration is valid
./pkg/models/webhook_config.go-func (w *WebhookConfig) Validate() error {
./pkg/models/webhook_config.go-	if w.OrganizationName == "" {
./pkg/models/webhook_config.go-		return fmt.Errorf("organization_name is required")
./pkg/models/webhook_config.go-	}
./pkg/models/webhook_config.go-	if w.WebhookSecret == "" {
./pkg/models/webhook_config.go-		return fmt.Errorf("webhook_secret is required")
./pkg/models/webhook_config.go-	}
./pkg/models/webhook_config.go-	if len(w.AllowedEvents) == 0 {
./pkg/models/webhook_config.go-		return fmt.Errorf("at least one allowed event is required")
./pkg/models/webhook_config.go-	}
./pkg/models/webhook_config.go-	return nil
./pkg/models/webhook_config.go-}
./pkg/models/webhook_config.go-
./pkg/models/webhook_config.go-// IsEventAllowed checks if a given event type is allowed for this organization
./pkg/models/webhook_config.go-func (w *WebhookConfig) IsEventAllowed(eventType string) bool {
./pkg/models/webhook_config.go-	for _, allowed := range w.AllowedEvents {
./pkg/models/webhook_config.go-		if allowed == eventType {
--
./pkg/models/dynamic_tools.go:type PassthroughConfig struct {
./pkg/models/dynamic_tools.go-	Mode              string `json:"mode"`                // optional, required, disabled
./pkg/models/dynamic_tools.go-	FallbackToService bool   `json:"fallback_to_service"` // Allow fallback to service account
./pkg/models/dynamic_tools.go-}
./pkg/models/dynamic_tools.go-
./pkg/models/dynamic_tools.go-// DiscoveryResult contains the results of API discovery
./pkg/models/dynamic_tools.go-type DiscoveryResult struct {
./pkg/models/dynamic_tools.go-	Status           string                 `json:"status"`
./pkg/models/dynamic_tools.go-	OpenAPISpec      interface{}            `json:"openapi_spec,omitempty"`
./pkg/models/dynamic_tools.go-	SpecURL          string                 `json:"spec_url,omitempty"`
./pkg/models/dynamic_tools.go-	DiscoveredURLs   []string               `json:"discovered_urls"`
./pkg/models/dynamic_tools.go-	RequiresManual   bool                   `json:"requires_manual"`
./pkg/models/dynamic_tools.go-	SuggestedActions []string               `json:"suggested_actions,omitempty"`
./pkg/models/dynamic_tools.go-	Capabilities     []string               `json:"capabilities,omitempty"`
./pkg/models/dynamic_tools.go-	Metadata         map[string]interface{} `json:"metadata,omitempty"`
./pkg/models/dynamic_tools.go-}
./pkg/models/dynamic_tools.go-
./pkg/models/dynamic_tools.go-// ToolWebhookConfig defines webhook configuration for a dynamic tool
./pkg/models/dynamic_tools.go:type ToolWebhookConfig struct {
./pkg/models/dynamic_tools.go-	Enabled               bool                   `json:"enabled"`
./pkg/models/dynamic_tools.go-	EndpointPath          string                 `json:"endpoint_path,omitempty"`           // e.g., /api/webhooks/tools/{toolId}
./pkg/models/dynamic_tools.go-	AuthType              string                 `json:"auth_type"`                         // hmac, bearer, basic, signature, none
./pkg/models/dynamic_tools.go-	AuthConfig            map[string]interface{} `json:"auth_config,omitempty"`             // Auth-specific config (e.g., secret, header names)
./pkg/models/dynamic_tools.go-	Events                []WebhookEventConfig   `json:"events,omitempty"`                  // Supported events
./pkg/models/dynamic_tools.go-	Headers               map[string]string      `json:"headers,omitempty"`                 // Expected headers
./pkg/models/dynamic_tools.go-	PayloadFormat         string                 `json:"payload_format,omitempty"`          // json, form, xml
./pkg/models/dynamic_tools.go-	SignatureHeader       string                 `json:"signature_header,omitempty"`        // Header containing signature
./pkg/models/dynamic_tools.go-	SignatureAlgorithm    string                 `json:"signature_algorithm,omitempty"`     // hmac-sha256, hmac-sha1, etc.
./pkg/models/dynamic_tools.go-	IPWhitelist           []string               `json:"ip_whitelist,omitempty"`            // Allowed source IPs
./pkg/models/dynamic_tools.go-	DefaultProcessingMode string                 `json:"default_processing_mode,omitempty"` // Default processing mode for events
./pkg/models/dynamic_tools.go-}
./pkg/models/dynamic_tools.go-
./pkg/models/dynamic_tools.go-// WebhookEventConfig defines configuration for a specific webhook event type
./pkg/models/dynamic_tools.go:type WebhookEventConfig struct {
./pkg/models/dynamic_tools.go-	EventType      string                 `json:"event_type"`   // e.g., "push", "pull_request", "issue"
./pkg/models/dynamic_tools.go-	PayloadPath    string                 `json:"payload_path"` // JSON path to event type in payload
./pkg/models/dynamic_tools.go-	SchemaURL      string                 `json:"schema_url,omitempty"`
./pkg/models/dynamic_tools.go-	TransformRules map[string]interface{} `json:"transform_rules,omitempty"` // Rules to transform payload
./pkg/models/dynamic_tools.go-	RequiredFields []string               `json:"required_fields,omitempty"` // Required fields in payload
./pkg/models/dynamic_tools.go-	ProcessingMode string                 `json:"processing_mode,omitempty"` // Processing mode for this event type
./pkg/models/dynamic_tools.go-}
./pkg/models/dynamic_tools.go-
./pkg/models/dynamic_tools.go-// WebhookEvent represents a received webhook event
./pkg/models/dynamic_tools.go-type WebhookEvent struct {
./pkg/models/dynamic_tools.go-	ID          string                 `json:"id" db:"id"`
./pkg/models/dynamic_tools.go-	ToolID      string                 `json:"tool_id" db:"tool_id"`
./pkg/models/dynamic_tools.go-	TenantID    string                 `json:"tenant_id" db:"tenant_id"`
./pkg/models/dynamic_tools.go-	EventType   string                 `json:"event_type" db:"event_type"`
./pkg/models/dynamic_tools.go-	Payload     json.RawMessage        `json:"payload" db:"payload"`
./pkg/models/dynamic_tools.go-	Headers     map[string][]string    `json:"headers" db:"headers"`
./pkg/models/dynamic_tools.go-	SourceIP    string                 `json:"source_ip" db:"source_ip"`
./pkg/models/dynamic_tools.go-	ReceivedAt  time.Time              `json:"received_at" db:"received_at"`
./pkg/models/dynamic_tools.go-	ProcessedAt *time.Time             `json:"processed_at,omitempty" db:"processed_at"`
./pkg/models/dynamic_tools.go-	Status      string                 `json:"status" db:"status"` // pending, processed, failed
./pkg/models/dynamic_tools.go-	Error       string                 `json:"error,omitempty" db:"error"`
./pkg/models/dynamic_tools.go-	Metadata    map[string]interface{} `json:"metadata,omitempty" db:"metadata"`
./pkg/models/dynamic_tools.go-}
--
./pkg/models/passthrough_auth.go:type EnhancedPassthroughConfig struct {
./pkg/models/passthrough_auth.go-	Mode               string                       `json:"mode"` // required, optional, disabled, hybrid
./pkg/models/passthrough_auth.go-	FallbackToService  bool                         `json:"fallback_to_service"`
./pkg/models/passthrough_auth.go-	SupportedAuthTypes []string                     `json:"supported_auth_types"`
./pkg/models/passthrough_auth.go-	Rules              []PassthroughRule            `json:"rules"`
./pkg/models/passthrough_auth.go-	AuthMapping        map[string]AuthMappingConfig `json:"auth_mapping"`
./pkg/models/passthrough_auth.go-	SecurityPolicy     *PassthroughSecurityPolicy   `json:"security_policy"`
./pkg/models/passthrough_auth.go-}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-// PassthroughRule defines when passthrough auth is allowed
./pkg/models/passthrough_auth.go-type PassthroughRule struct {
./pkg/models/passthrough_auth.go-	RuleID        string   `json:"rule_id"`
./pkg/models/passthrough_auth.go-	AgentTypes    []string `json:"agent_types"`
./pkg/models/passthrough_auth.go-	Actions       []string `json:"actions"` // Specific actions that allow passthrough
./pkg/models/passthrough_auth.go-	Environments  []string `json:"environments"`
./pkg/models/passthrough_auth.go-	AuthRequired  bool     `json:"auth_required"`
./pkg/models/passthrough_auth.go-	AllowFallback bool     `json:"allow_fallback"`
./pkg/models/passthrough_auth.go-	Priority      int      `json:"priority"` // Higher priority rules are evaluated first
./pkg/models/passthrough_auth.go-}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-// AuthMappingConfig defines how to map incoming auth to tool-specific auth
./pkg/models/passthrough_auth.go:type AuthMappingConfig struct {
./pkg/models/passthrough_auth.go-	SourceType string            `json:"source_type"` // What we receive
./pkg/models/passthrough_auth.go-	TargetType string            `json:"target_type"` // What tool expects
./pkg/models/passthrough_auth.go-	HeaderName string            `json:"header_name,omitempty"`
./pkg/models/passthrough_auth.go-	QueryParam string            `json:"query_param,omitempty"`
./pkg/models/passthrough_auth.go-	Transform  string            `json:"transform,omitempty"` // base64, hex, url_encode, etc.
./pkg/models/passthrough_auth.go-	Prefix     string            `json:"prefix,omitempty"`    // e.g., "Bearer ", "token "
./pkg/models/passthrough_auth.go-	Properties map[string]string `json:"properties,omitempty"`
./pkg/models/passthrough_auth.go-}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-// PassthroughSecurityPolicy defines security requirements for passthrough auth
./pkg/models/passthrough_auth.go-type PassthroughSecurityPolicy struct {
./pkg/models/passthrough_auth.go-	RequireEncryption   bool     `json:"require_encryption"`
./pkg/models/passthrough_auth.go-	AllowedDomains      []string `json:"allowed_domains"`
./pkg/models/passthrough_auth.go-	BlockedDomains      []string `json:"blocked_domains"`
./pkg/models/passthrough_auth.go-	MaxTokenAge         int      `json:"max_token_age_seconds"`
./pkg/models/passthrough_auth.go-	RequireUserContext  bool     `json:"require_user_context"`
./pkg/models/passthrough_auth.go-	RequireAgentContext bool     `json:"require_agent_context"`
./pkg/models/passthrough_auth.go-	AuditLevel          string   `json:"audit_level"` // none, basic, detailed, verbose
./pkg/models/passthrough_auth.go-	ValidateTokenFormat bool     `json:"validate_token_format"`
./pkg/models/passthrough_auth.go-}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-// Validate performs validation on the PassthroughAuthBundle
./pkg/models/passthrough_auth.go-func (p *PassthroughAuthBundle) Validate() error {
./pkg/models/passthrough_auth.go-	// Basic validation logic
./pkg/models/passthrough_auth.go-	if p == nil {
./pkg/models/passthrough_auth.go-		return nil // Passthrough is optional
./pkg/models/passthrough_auth.go-	}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-	// Validate OAuth tokens expiry
./pkg/models/passthrough_auth.go-	for name, token := range p.OAuthTokens {
./pkg/models/passthrough_auth.go-		if token.AccessToken == "" {
./pkg/models/passthrough_auth.go-			return &ValidationError{
./pkg/models/passthrough_auth.go-				Field:   "oauth_tokens." + name + ".access_token",
./pkg/models/passthrough_auth.go-				Message: "access token cannot be empty",
./pkg/models/passthrough_auth.go-			}
./pkg/models/passthrough_auth.go-		}
./pkg/models/passthrough_auth.go-	}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-	return nil
./pkg/models/passthrough_auth.go-}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-// GetCredentialForTool returns the most appropriate credential for a tool
./pkg/models/passthrough_auth.go-func (p *PassthroughAuthBundle) GetCredentialForTool(toolName string) *PassthroughCredential {
./pkg/models/passthrough_auth.go-	if p == nil || p.Credentials == nil {
./pkg/models/passthrough_auth.go-		return nil
./pkg/models/passthrough_auth.go-	}
./pkg/models/passthrough_auth.go-
./pkg/models/passthrough_auth.go-	// First, try exact match
./pkg/models/passthrough_auth.go-	if cred, ok := p.Credentials[toolName]; ok {
./pkg/models/passthrough_auth.go-		return cred
--
./pkg/observability/interfaces.go:type Config struct {
./pkg/observability/interfaces.go-	Tracing TracingConfig `json:"tracing,omitempty"`
./pkg/observability/interfaces.go-	Metrics MetricsConfig `json:"metrics,omitempty"`
./pkg/observability/interfaces.go-	Logging LoggingConfig `json:"logging,omitempty"`
./pkg/observability/interfaces.go-}
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-// TracingConfig holds the configuration for tracing
./pkg/observability/interfaces.go:type TracingConfig struct {
./pkg/observability/interfaces.go-	// Enabled indicates whether tracing is enabled
./pkg/observability/interfaces.go-	Enabled     bool   `json:"enabled"`
./pkg/observability/interfaces.go-	ServiceName string `json:"service_name,omitempty"`
./pkg/observability/interfaces.go-	Environment string `json:"environment,omitempty"`
./pkg/observability/interfaces.go-	Endpoint    string `json:"endpoint,omitempty"`
./pkg/observability/interfaces.go-}
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-// MetricsConfig holds the configuration for metrics
./pkg/observability/interfaces.go:type MetricsConfig struct {
./pkg/observability/interfaces.go-	// Enabled indicates whether metrics collection is enabled
./pkg/observability/interfaces.go-	Enabled      bool          `json:"enabled" mapstructure:"enabled"`
./pkg/observability/interfaces.go-	Type         string        `json:"type,omitempty" mapstructure:"type"`
./pkg/observability/interfaces.go-	Endpoint     string        `json:"endpoint,omitempty" mapstructure:"endpoint"`
./pkg/observability/interfaces.go-	Namespace    string        `json:"namespace,omitempty" mapstructure:"namespace"`
./pkg/observability/interfaces.go-	PushGateway  string        `json:"push_gateway,omitempty" mapstructure:"push_gateway"`
./pkg/observability/interfaces.go-	PushInterval time.Duration `json:"push_interval,omitempty" mapstructure:"push_interval"`
./pkg/observability/interfaces.go-}
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-// LoggingConfig holds the configuration for logging
./pkg/observability/interfaces.go:type LoggingConfig struct {
./pkg/observability/interfaces.go-	// Level is the minimum log level to emit
./pkg/observability/interfaces.go-	Level  string `json:"level,omitempty"`
./pkg/observability/interfaces.go-	Format string `json:"format,omitempty"`
./pkg/observability/interfaces.go-	// Output is the output destination (stdout, file)
./pkg/observability/interfaces.go-	Output string `json:"output,omitempty"`
./pkg/observability/interfaces.go-	// FilePath is the path to the log file if Output is "file"
./pkg/observability/interfaces.go-	FilePath string `json:"file_path,omitempty"`
./pkg/observability/interfaces.go-}
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-// LogLevel defines log message severity
./pkg/observability/interfaces.go-type LogLevel string
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-// Log levels
./pkg/observability/interfaces.go-const (
./pkg/observability/interfaces.go-	LogLevelDebug LogLevel = "DEBUG"
./pkg/observability/interfaces.go-	LogLevelInfo  LogLevel = "INFO"
./pkg/observability/interfaces.go-	LogLevelWarn  LogLevel = "WARN"
./pkg/observability/interfaces.go-	LogLevelError LogLevel = "ERROR"
./pkg/observability/interfaces.go-	LogLevelFatal LogLevel = "FATAL"
./pkg/observability/interfaces.go-)
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-// Logger defines the interface for logging
./pkg/observability/interfaces.go-type Logger interface {
./pkg/observability/interfaces.go-	// Core logging methods with fields
./pkg/observability/interfaces.go-	Debug(msg string, fields map[string]interface{})
./pkg/observability/interfaces.go-	Info(msg string, fields map[string]interface{})
./pkg/observability/interfaces.go-	Warn(msg string, fields map[string]interface{})
./pkg/observability/interfaces.go-	Error(msg string, fields map[string]interface{})
./pkg/observability/interfaces.go-	Fatal(msg string, fields map[string]interface{})
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-	// Formatted logging methods
./pkg/observability/interfaces.go-	Debugf(format string, args ...interface{})
./pkg/observability/interfaces.go-	Infof(format string, args ...interface{})
./pkg/observability/interfaces.go-	Warnf(format string, args ...interface{})
./pkg/observability/interfaces.go-	Errorf(format string, args ...interface{})
./pkg/observability/interfaces.go-	Fatalf(format string, args ...interface{})
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-	// Context methods
./pkg/observability/interfaces.go-	WithPrefix(prefix string) Logger
./pkg/observability/interfaces.go-	With(fields map[string]interface{}) Logger
./pkg/observability/interfaces.go-}
./pkg/observability/interfaces.go-
./pkg/observability/interfaces.go-// MetricsClient defines the interface for metrics collection
./pkg/observability/interfaces.go-type MetricsClient interface {
./pkg/observability/interfaces.go-	// Core metrics recording methods
./pkg/observability/interfaces.go-	RecordEvent(source, eventType string)
./pkg/observability/interfaces.go-	RecordLatency(operation string, duration time.Duration)
./pkg/observability/interfaces.go-	RecordCounter(name string, value float64, labels map[string]string)
./pkg/observability/interfaces.go-	RecordGauge(name string, value float64, labels map[string]string)
./pkg/observability/interfaces.go-	RecordHistogram(name string, value float64, labels map[string]string)
--
./pkg/storage/s3.go:type AWSConfig struct {
./pkg/storage/s3.go-	UseIAMAuth bool   `mapstructure:"use_iam_auth"`
./pkg/storage/s3.go-	Region     string `mapstructure:"region"`
./pkg/storage/s3.go-	Endpoint   string `mapstructure:"endpoint"`
./pkg/storage/s3.go-	AssumeRole string `mapstructure:"assume_role"`
./pkg/storage/s3.go-}
./pkg/storage/s3.go-
./pkg/storage/s3.go-// S3Config holds configuration for the S3 client
./pkg/storage/s3.go:type S3Config struct {
./pkg/storage/s3.go-	Region           string        `mapstructure:"region"`
./pkg/storage/s3.go-	Bucket           string        `mapstructure:"bucket"`
./pkg/storage/s3.go-	Endpoint         string        `mapstructure:"endpoint"`
./pkg/storage/s3.go-	ForcePathStyle   bool          `mapstructure:"force_path_style"`
./pkg/storage/s3.go-	UploadPartSize   int64         `mapstructure:"upload_part_size"`
./pkg/storage/s3.go-	DownloadPartSize int64         `mapstructure:"download_part_size"`
./pkg/storage/s3.go-	Concurrency      int           `mapstructure:"concurrency"`
./pkg/storage/s3.go-	RequestTimeout   time.Duration `mapstructure:"request_timeout"`
./pkg/storage/s3.go-	AWSConfig        AWSConfig     `mapstructure:"aws_config"`
./pkg/storage/s3.go-}
./pkg/storage/s3.go-
./pkg/storage/s3.go-// NewS3Client creates a new S3 client with IRSA support
./pkg/storage/s3.go-func NewS3Client(ctx context.Context, cfg S3Config) (*S3Client, error) {
./pkg/storage/s3.go-	// Create config options
./pkg/storage/s3.go-	var options []func(*config.LoadOptions) error
./pkg/storage/s3.go-
./pkg/storage/s3.go-	// Use region from AWS config if specified, otherwise use the S3 config region
./pkg/storage/s3.go-	region := cfg.Region
./pkg/storage/s3.go-	if cfg.AWSConfig.Region != "" {
./pkg/storage/s3.go-		region = cfg.AWSConfig.Region
./pkg/storage/s3.go-	}
./pkg/storage/s3.go-	options = append(options, config.WithRegion(region))
./pkg/storage/s3.go-
./pkg/storage/s3.go-	// Add custom endpoint if specified (for LocalStack or other S3 compatible services)
./pkg/storage/s3.go-	endpoint := cfg.Endpoint
./pkg/storage/s3.go-	if cfg.AWSConfig.Endpoint != "" {
./pkg/storage/s3.go-		endpoint = cfg.AWSConfig.Endpoint
./pkg/storage/s3.go-	}
./pkg/storage/s3.go-
./pkg/storage/s3.go-	// Load AWS configuration - IRSA will be automatically detected if AWS_WEB_IDENTITY_TOKEN_FILE
./pkg/storage/s3.go-	// and AWS_ROLE_ARN environment variables are set by the EKS Pod Identity Agent
./pkg/storage/s3.go-	awsCfg, err := config.LoadDefaultConfig(ctx, options...)
./pkg/storage/s3.go-	if err != nil {
./pkg/storage/s3.go-		return nil, fmt.Errorf("failed to load AWS config: %w", err)
./pkg/storage/s3.go-	}
./pkg/storage/s3.go-
./pkg/storage/s3.go-	// Log IRSA detection if enabled
./pkg/storage/s3.go-	if cfg.AWSConfig.UseIAMAuth {
./pkg/storage/s3.go-		// Check if IRSA environment variables are set
./pkg/storage/s3.go-		_, hasWebIdentityTokenFile := os.LookupEnv("AWS_WEB_IDENTITY_TOKEN_FILE")
./pkg/storage/s3.go-		_, hasRoleArn := os.LookupEnv("AWS_ROLE_ARN")
./pkg/storage/s3.go-
./pkg/storage/s3.go-		if hasWebIdentityTokenFile && hasRoleArn {
./pkg/storage/s3.go-			fmt.Println("Using IRSA (IAM Roles for Service Accounts) authentication for S3")
./pkg/storage/s3.go-		} else {
./pkg/storage/s3.go-			fmt.Println("Warning: IAM authentication is enabled but IRSA environment variables are not set")
./pkg/storage/s3.go-		}
./pkg/storage/s3.go-	}
./pkg/storage/s3.go-
./pkg/storage/s3.go-	// Create S3 client options
--
./pkg/chunking/text/recursive_splitter.go:type RecursiveCharacterSplitterConfig struct {
./pkg/chunking/text/recursive_splitter.go-	Separators     []string
./pkg/chunking/text/recursive_splitter.go-	ChunkSize      int
./pkg/chunking/text/recursive_splitter.go-	ChunkOverlap   int
./pkg/chunking/text/recursive_splitter.go-	LengthFunction func(string) int
./pkg/chunking/text/recursive_splitter.go-	KeepSeparator  bool
./pkg/chunking/text/recursive_splitter.go-}
./pkg/chunking/text/recursive_splitter.go-
./pkg/chunking/text/recursive_splitter.go-// DefaultSeparators returns the default separators for splitting
./pkg/chunking/text/recursive_splitter.go-func DefaultSeparators() []string {
./pkg/chunking/text/recursive_splitter.go-	return []string{
./pkg/chunking/text/recursive_splitter.go-		"\n\n\n", // Triple newline (major sections)
./pkg/chunking/text/recursive_splitter.go-		"\n\n",   // Double newline (paragraphs)
./pkg/chunking/text/recursive_splitter.go-		"\n",     // Single newline
./pkg/chunking/text/recursive_splitter.go-		". ",     // Sentence ending
./pkg/chunking/text/recursive_splitter.go-		"! ",     // Exclamation
./pkg/chunking/text/recursive_splitter.go-		"? ",     // Question
./pkg/chunking/text/recursive_splitter.go-		"; ",     // Semicolon
./pkg/chunking/text/recursive_splitter.go-		": ",     // Colon
./pkg/chunking/text/recursive_splitter.go-		", ",     // Comma
./pkg/chunking/text/recursive_splitter.go-		" ",      // Space
./pkg/chunking/text/recursive_splitter.go-		"",       // Character-level fallback
./pkg/chunking/text/recursive_splitter.go-	}
./pkg/chunking/text/recursive_splitter.go-}
./pkg/chunking/text/recursive_splitter.go-
./pkg/chunking/text/recursive_splitter.go-// NewRecursiveCharacterSplitter creates a new recursive character splitter
./pkg/chunking/text/recursive_splitter.go-func NewRecursiveCharacterSplitter(config *RecursiveCharacterSplitterConfig) *RecursiveCharacterSplitter {
./pkg/chunking/text/recursive_splitter.go-	if config == nil {
./pkg/chunking/text/recursive_splitter.go-		config = &RecursiveCharacterSplitterConfig{}
./pkg/chunking/text/recursive_splitter.go-	}
./pkg/chunking/text/recursive_splitter.go-
./pkg/chunking/text/recursive_splitter.go-	if len(config.Separators) == 0 {
./pkg/chunking/text/recursive_splitter.go-		config.Separators = DefaultSeparators()
./pkg/chunking/text/recursive_splitter.go-	}
./pkg/chunking/text/recursive_splitter.go-
./pkg/chunking/text/recursive_splitter.go-	if config.ChunkSize <= 0 {
./pkg/chunking/text/recursive_splitter.go-		config.ChunkSize = 1000
./pkg/chunking/text/recursive_splitter.go-	}
./pkg/chunking/text/recursive_splitter.go-
./pkg/chunking/text/recursive_splitter.go-	if config.ChunkOverlap < 0 {
./pkg/chunking/text/recursive_splitter.go-		config.ChunkOverlap = 200
./pkg/chunking/text/recursive_splitter.go-	}
./pkg/chunking/text/recursive_splitter.go-
./pkg/chunking/text/recursive_splitter.go-	if config.LengthFunction == nil {
./pkg/chunking/text/recursive_splitter.go-		config.LengthFunction = func(s string) int { return len(s) }
./pkg/chunking/text/recursive_splitter.go-	}
./pkg/chunking/text/recursive_splitter.go-
./pkg/chunking/text/recursive_splitter.go-	return &RecursiveCharacterSplitter{
./pkg/chunking/text/recursive_splitter.go-		separators:     config.Separators,
./pkg/chunking/text/recursive_splitter.go-		chunkSize:      config.ChunkSize,
./pkg/chunking/text/recursive_splitter.go-		chunkOverlap:   config.ChunkOverlap,
--
./pkg/chunking/text/semantic_chunker.go:type Config struct {
./pkg/chunking/text/semantic_chunker.go-	MinChunkSize        int     // Minimum tokens per chunk
./pkg/chunking/text/semantic_chunker.go-	MaxChunkSize        int     // Maximum tokens per chunk
./pkg/chunking/text/semantic_chunker.go-	TargetChunkSize     int     // Target size for chunks
./pkg/chunking/text/semantic_chunker.go-	OverlapSize         int     // Token overlap between chunks
./pkg/chunking/text/semantic_chunker.go-	SimilarityThreshold float32 // For semantic boundaries
./pkg/chunking/text/semantic_chunker.go-}
./pkg/chunking/text/semantic_chunker.go-
./pkg/chunking/text/semantic_chunker.go-// DefaultConfig returns default configuration
./pkg/chunking/text/semantic_chunker.go-func DefaultConfig() *Config {
./pkg/chunking/text/semantic_chunker.go-	return &Config{
./pkg/chunking/text/semantic_chunker.go-		MinChunkSize:        100,
./pkg/chunking/text/semantic_chunker.go-		MaxChunkSize:        1024,
./pkg/chunking/text/semantic_chunker.go-		TargetChunkSize:     512,
./pkg/chunking/text/semantic_chunker.go-		OverlapSize:         50,
./pkg/chunking/text/semantic_chunker.go-		SimilarityThreshold: 0.5,
./pkg/chunking/text/semantic_chunker.go-	}
./pkg/chunking/text/semantic_chunker.go-}
./pkg/chunking/text/semantic_chunker.go-
./pkg/chunking/text/semantic_chunker.go-// NewSemanticChunker creates a new semantic chunker
./pkg/chunking/text/semantic_chunker.go-func NewSemanticChunker(tokenizer tokenizer.Tokenizer, config *Config) *SemanticChunker {
./pkg/chunking/text/semantic_chunker.go-	if config == nil {
./pkg/chunking/text/semantic_chunker.go-		config = DefaultConfig()
./pkg/chunking/text/semantic_chunker.go-	}
./pkg/chunking/text/semantic_chunker.go-
./pkg/chunking/text/semantic_chunker.go-	// Validate and set defaults
./pkg/chunking/text/semantic_chunker.go-	if config.TargetChunkSize == 0 {
./pkg/chunking/text/semantic_chunker.go-		config.TargetChunkSize = 512
./pkg/chunking/text/semantic_chunker.go-	}
./pkg/chunking/text/semantic_chunker.go-	if config.MinChunkSize == 0 {
./pkg/chunking/text/semantic_chunker.go-		config.MinChunkSize = 100
./pkg/chunking/text/semantic_chunker.go-	}
./pkg/chunking/text/semantic_chunker.go-	if config.MaxChunkSize == 0 {
./pkg/chunking/text/semantic_chunker.go-		config.MaxChunkSize = 1024
./pkg/chunking/text/semantic_chunker.go-	}
./pkg/chunking/text/semantic_chunker.go-
./pkg/chunking/text/semantic_chunker.go-	return &SemanticChunker{
./pkg/chunking/text/semantic_chunker.go-		tokenizer:        tokenizer,
./pkg/chunking/text/semantic_chunker.go-		sentenceSplitter: NewSentenceSplitter(),
./pkg/chunking/text/semantic_chunker.go-		config:           config,
./pkg/chunking/text/semantic_chunker.go-	}
./pkg/chunking/text/semantic_chunker.go-}
./pkg/chunking/text/semantic_chunker.go-
./pkg/chunking/text/semantic_chunker.go-// Chunk splits text into semantic chunks
./pkg/chunking/text/semantic_chunker.go-func (s *SemanticChunker) Chunk(ctx context.Context, text string, metadata map[string]interface{}) ([]*chunking.TextChunk, error) {
./pkg/chunking/text/semantic_chunker.go-	// First split by paragraphs (double newline)
./pkg/chunking/text/semantic_chunker.go-	paragraphs := strings.Split(text, "\n\n")
./pkg/chunking/text/semantic_chunker.go-
./pkg/chunking/text/semantic_chunker.go-	// Then split each paragraph into sentences
./pkg/chunking/text/semantic_chunker.go-	var allSentences []string
./pkg/chunking/text/semantic_chunker.go-	paragraphBoundaries := make(map[int]bool)
--
./pkg/adapters/interfaces.go:type Config struct {
./pkg/adapters/interfaces.go-	// Common fields
./pkg/adapters/interfaces.go-	Timeout    time.Duration
./pkg/adapters/interfaces.go-	MaxRetries int
./pkg/adapters/interfaces.go-	RateLimit  int
./pkg/adapters/interfaces.go-
./pkg/adapters/interfaces.go-	// Provider-specific config stored as map
./pkg/adapters/interfaces.go-	ProviderConfig map[string]any
./pkg/adapters/interfaces.go-}
--
./pkg/adapters/github/webhook/processor.go:type ProcessorConfig struct {
./pkg/adapters/github/webhook/processor.go-	QueueSize   int
./pkg/adapters/github/webhook/processor.go-	WorkerCount int
./pkg/adapters/github/webhook/processor.go-	Logger      observability.Logger
./pkg/adapters/github/webhook/processor.go-	Metrics     observability.MetricsClient
./pkg/adapters/github/webhook/processor.go-}
./pkg/adapters/github/webhook/processor.go-
./pkg/adapters/github/webhook/processor.go-// NewProcessor creates a new webhook processor
./pkg/adapters/github/webhook/processor.go-func NewProcessor(config *ProcessorConfig) *Processor {
./pkg/adapters/github/webhook/processor.go-	// Set defaults if not provided
./pkg/adapters/github/webhook/processor.go-	queueSize := config.QueueSize
./pkg/adapters/github/webhook/processor.go-	if queueSize <= 0 {
./pkg/adapters/github/webhook/processor.go-		queueSize = 100
./pkg/adapters/github/webhook/processor.go-	}
./pkg/adapters/github/webhook/processor.go-
./pkg/adapters/github/webhook/processor.go-	workerCount := config.WorkerCount
./pkg/adapters/github/webhook/processor.go-	if workerCount <= 0 {
./pkg/adapters/github/webhook/processor.go-		workerCount = 5
./pkg/adapters/github/webhook/processor.go-	}
./pkg/adapters/github/webhook/processor.go-
./pkg/adapters/github/webhook/processor.go-	ctx, cancel := context.WithCancel(context.Background())
./pkg/adapters/github/webhook/processor.go-
./pkg/adapters/github/webhook/processor.go-	return &Processor{
./pkg/adapters/github/webhook/processor.go-		handlers:    make(map[string][]WebhookHandler),
./pkg/adapters/github/webhook/processor.go-		queue:       make(chan *WebhookEvent, queueSize),
./pkg/adapters/github/webhook/processor.go-		workerCount: workerCount,
./pkg/adapters/github/webhook/processor.go-		ctx:         ctx,
./pkg/adapters/github/webhook/processor.go-		cancel:      cancel,
./pkg/adapters/github/webhook/processor.go-		logger:      config.Logger,
./pkg/adapters/github/webhook/processor.go-		metrics:     config.Metrics,
./pkg/adapters/github/webhook/processor.go-	}
./pkg/adapters/github/webhook/processor.go-}
./pkg/adapters/github/webhook/processor.go-
./pkg/adapters/github/webhook/processor.go-// Start starts the webhook processor
./pkg/adapters/github/webhook/processor.go-func (p *Processor) Start() {
./pkg/adapters/github/webhook/processor.go-	p.logger.Info("Starting webhook processor", map[string]any{
./pkg/adapters/github/webhook/processor.go-		"workers": p.workerCount,
./pkg/adapters/github/webhook/processor.go-	})
./pkg/adapters/github/webhook/processor.go-
./pkg/adapters/github/webhook/processor.go-	for i := 0; i < p.workerCount; i++ {
./pkg/adapters/github/webhook/processor.go-		p.wg.Add(1)
./pkg/adapters/github/webhook/processor.go-		go p.worker(i)
./pkg/adapters/github/webhook/processor.go-	}
./pkg/adapters/github/webhook/processor.go-}
./pkg/adapters/github/webhook/processor.go-
./pkg/adapters/github/webhook/processor.go-// Stop stops the webhook processor
./pkg/adapters/github/webhook/processor.go-func (p *Processor) Stop() {
./pkg/adapters/github/webhook/processor.go-	p.logger.Info("Stopping webhook processor", map[string]any{})
./pkg/adapters/github/webhook/processor.go-	p.cancel()
./pkg/adapters/github/webhook/processor.go-	close(p.queue)
./pkg/adapters/github/webhook/processor.go-	p.wg.Wait()
--
./pkg/adapters/github/webhook/retry.go:type RetryConfig struct {
./pkg/adapters/github/webhook/retry.go-	// MaxRetries is the maximum number of retries
./pkg/adapters/github/webhook/retry.go-	MaxRetries int
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// InitialBackoff is the initial backoff duration
./pkg/adapters/github/webhook/retry.go-	InitialBackoff time.Duration
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// MaxBackoff is the maximum backoff duration
./pkg/adapters/github/webhook/retry.go-	MaxBackoff time.Duration
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// BackoffFactor is the factor to multiply backoff on each retry
./pkg/adapters/github/webhook/retry.go-	BackoffFactor float64
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// Jitter is the jitter factor to randomize backoff
./pkg/adapters/github/webhook/retry.go-	Jitter float64
./pkg/adapters/github/webhook/retry.go-}
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-// DefaultRetryConfig returns a default retry configuration
./pkg/adapters/github/webhook/retry.go-func DefaultRetryConfig() *RetryConfig {
./pkg/adapters/github/webhook/retry.go-	return &RetryConfig{
./pkg/adapters/github/webhook/retry.go-		MaxRetries:     5,
./pkg/adapters/github/webhook/retry.go-		InitialBackoff: 1 * time.Second,
./pkg/adapters/github/webhook/retry.go-		MaxBackoff:     1 * time.Hour,
./pkg/adapters/github/webhook/retry.go-		BackoffFactor:  2.0,
./pkg/adapters/github/webhook/retry.go-		Jitter:         0.2,
./pkg/adapters/github/webhook/retry.go-	}
./pkg/adapters/github/webhook/retry.go-}
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-// RetryStatus represents the status of a retried event
./pkg/adapters/github/webhook/retry.go-type RetryStatus string
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-const (
./pkg/adapters/github/webhook/retry.go-	// RetryStatusPending indicates the event is pending retry
./pkg/adapters/github/webhook/retry.go-	RetryStatusPending RetryStatus = "pending"
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// RetryStatusInProgress indicates the event is being retried
./pkg/adapters/github/webhook/retry.go-	RetryStatusInProgress RetryStatus = "in_progress"
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// RetryStatusSuccess indicates the event was successfully processed
./pkg/adapters/github/webhook/retry.go-	RetryStatusSuccess RetryStatus = "success"
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// RetryStatusFailed indicates the event processing failed after all retries
./pkg/adapters/github/webhook/retry.go-	RetryStatusFailed RetryStatus = "failed"
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-	// RetryStatusCancelled indicates the event retry was cancelled
./pkg/adapters/github/webhook/retry.go-	RetryStatusCancelled RetryStatus = "cancelled"
./pkg/adapters/github/webhook/retry.go-)
./pkg/adapters/github/webhook/retry.go-
./pkg/adapters/github/webhook/retry.go-// RetryStorage defines the interface for storing retry information
./pkg/adapters/github/webhook/retry.go-type RetryStorage interface {
./pkg/adapters/github/webhook/retry.go-	// Store stores retry information for an event
--
./pkg/adapters/github/config.go:type Config struct {
./pkg/adapters/github/config.go-	// Authentication settings
./pkg/adapters/github/config.go-	Auth AuthConfig `yaml:"auth" json:"auth"`
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-	// Connection settings
./pkg/adapters/github/config.go-	BaseURL             string        `yaml:"base_url" json:"base_url"`
./pkg/adapters/github/config.go-	UploadURL           string        `yaml:"upload_url" json:"upload_url"`
./pkg/adapters/github/config.go-	GraphQLURL          string        `yaml:"graphql_url" json:"graphql_url"`
./pkg/adapters/github/config.go-	RequestTimeout      time.Duration `yaml:"request_timeout" json:"request_timeout"`
./pkg/adapters/github/config.go-	MaxIdleConns        int           `yaml:"max_idle_conns" json:"max_idle_conns"`
./pkg/adapters/github/config.go-	MaxConnsPerHost     int           `yaml:"max_conns_per_host" json:"max_conns_per_host"`
./pkg/adapters/github/config.go-	MaxIdleConnsPerHost int           `yaml:"max_idle_conns_per_host" json:"max_idle_conns_per_host"`
./pkg/adapters/github/config.go-	IdleConnTimeout     time.Duration `yaml:"idle_conn_timeout" json:"idle_conn_timeout"`
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-	// Rate limiting settings
./pkg/adapters/github/config.go-	RateLimit      float64       `yaml:"rate_limit" json:"rate_limit"`
./pkg/adapters/github/config.go-	RateLimitBurst int           `yaml:"rate_limit_burst" json:"rate_limit_burst"`
./pkg/adapters/github/config.go-	RateLimitWait  time.Duration `yaml:"rate_limit_wait" json:"rate_limit_wait"`
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-	// Webhook settings
./pkg/adapters/github/config.go-	WebhooksEnabled         bool          `yaml:"webhooks_enabled" json:"webhooks_enabled"`
./pkg/adapters/github/config.go-	WebhookSecret           string        `yaml:"webhook_secret" json:"webhook_secret"`
./pkg/adapters/github/config.go-	WebhookWorkers          int           `yaml:"webhook_workers" json:"webhook_workers"`
./pkg/adapters/github/config.go-	WebhookQueueSize        int           `yaml:"webhook_queue_size" json:"webhook_queue_size"`
./pkg/adapters/github/config.go-	WebhookRetryEnabled     bool          `yaml:"webhook_retry_enabled" json:"webhook_retry_enabled"`
./pkg/adapters/github/config.go-	WebhookRetryMaxAttempts int           `yaml:"webhook_retry_max_attempts" json:"webhook_retry_max_attempts"`
./pkg/adapters/github/config.go-	WebhookRetryDelay       time.Duration `yaml:"webhook_retry_delay" json:"webhook_retry_delay"`
./pkg/adapters/github/config.go-	// ForceTerminateWorkersOnTimeout is used in testing to prevent goroutine leaks
./pkg/adapters/github/config.go-	ForceTerminateWorkersOnTimeout bool `yaml:"force_terminate_workers_on_timeout" json:"force_terminate_workers_on_timeout"`
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-	// Pagination settings
./pkg/adapters/github/config.go-	DefaultPageSize int `yaml:"default_page_size" json:"default_page_size"`
./pkg/adapters/github/config.go-	MaxPageSize     int `yaml:"max_page_size" json:"max_page_size"`
./pkg/adapters/github/config.go-}
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-// AuthConfig holds authentication configuration for GitHub
./pkg/adapters/github/config.go:type AuthConfig struct {
./pkg/adapters/github/config.go-	Type           string `yaml:"type" json:"type"`
./pkg/adapters/github/config.go-	Token          string `yaml:"token" json:"token"`
./pkg/adapters/github/config.go-	AppID          int64  `yaml:"app_id" json:"app_id"`
./pkg/adapters/github/config.go-	InstallationID int64  `yaml:"installation_id" json:"installation_id"`
./pkg/adapters/github/config.go-	PrivateKey     string `yaml:"private_key" json:"private_key"`
./pkg/adapters/github/config.go-}
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-// DefaultConfig returns a default configuration for the GitHub adapter
./pkg/adapters/github/config.go-func DefaultConfig() *Config {
./pkg/adapters/github/config.go-	return &Config{
./pkg/adapters/github/config.go-		Auth: AuthConfig{
./pkg/adapters/github/config.go-			Type: "token",
./pkg/adapters/github/config.go-		},
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-		// Default to GitHub.com
./pkg/adapters/github/config.go-		BaseURL:    "https://api.github.com/",
./pkg/adapters/github/config.go-		UploadURL:  "https://uploads.github.com/",
./pkg/adapters/github/config.go-		GraphQLURL: "https://api.github.com/graphql",
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-		// Default connection settings
./pkg/adapters/github/config.go-		RequestTimeout:      30 * time.Second,
./pkg/adapters/github/config.go-		MaxIdleConns:        10,
./pkg/adapters/github/config.go-		MaxConnsPerHost:     10,
./pkg/adapters/github/config.go-		MaxIdleConnsPerHost: 10,
./pkg/adapters/github/config.go-		IdleConnTimeout:     90 * time.Second,
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-		// Default rate limiting
./pkg/adapters/github/config.go-		RateLimit:      5000 / 3600, // Default GitHub API rate limit per second
./pkg/adapters/github/config.go-		RateLimitBurst: 100,
./pkg/adapters/github/config.go-		RateLimitWait:  5 * time.Second,
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-		// Default webhook settings
./pkg/adapters/github/config.go-		WebhooksEnabled:                true,
./pkg/adapters/github/config.go-		WebhookWorkers:                 5,
./pkg/adapters/github/config.go-		WebhookQueueSize:               100,
./pkg/adapters/github/config.go-		WebhookRetryEnabled:            true,
./pkg/adapters/github/config.go-		WebhookRetryMaxAttempts:        3,
./pkg/adapters/github/config.go-		WebhookRetryDelay:              5 * time.Second,
./pkg/adapters/github/config.go-		ForceTerminateWorkersOnTimeout: true, // Default to true to prevent goroutine leaks in tests
./pkg/adapters/github/config.go-
./pkg/adapters/github/config.go-		// Default pagination settings
./pkg/adapters/github/config.go-		DefaultPageSize: 100,
./pkg/adapters/github/config.go-		MaxPageSize:     100,
./pkg/adapters/github/config.go-	}
./pkg/adapters/github/config.go-}
--
./pkg/adapters/github/auth/provider.go:type Config struct {
./pkg/adapters/github/auth/provider.go-	// Personal Access Token
./pkg/adapters/github/auth/provider.go-	Token string
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-	// GitHub App
./pkg/adapters/github/auth/provider.go-	AppID             string
./pkg/adapters/github/auth/provider.go-	AppPrivateKey     string
./pkg/adapters/github/auth/provider.go-	AppInstallationID string
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-	// OAuth
./pkg/adapters/github/auth/provider.go-	OAuthToken        string
./pkg/adapters/github/auth/provider.go-	OAuthClientID     string
./pkg/adapters/github/auth/provider.go-	OAuthClientSecret string
./pkg/adapters/github/auth/provider.go-}
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-// NoAuthProvider provides no authentication
./pkg/adapters/github/auth/provider.go-type NoAuthProvider struct {
./pkg/adapters/github/auth/provider.go-	BaseAuthProvider
./pkg/adapters/github/auth/provider.go-}
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-// NewNoAuthProvider creates a new provider with no authentication
./pkg/adapters/github/auth/provider.go-func NewNoAuthProvider(logger observability.Logger) *NoAuthProvider {
./pkg/adapters/github/auth/provider.go-	return &NoAuthProvider{
./pkg/adapters/github/auth/provider.go-		BaseAuthProvider: BaseAuthProvider{
./pkg/adapters/github/auth/provider.go-			authType: AuthTypeNone,
./pkg/adapters/github/auth/provider.go-			logger:   logger,
./pkg/adapters/github/auth/provider.go-		},
./pkg/adapters/github/auth/provider.go-	}
./pkg/adapters/github/auth/provider.go-}
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-// GetToken returns an empty token
./pkg/adapters/github/auth/provider.go-func (p *NoAuthProvider) GetToken(ctx context.Context) (string, error) {
./pkg/adapters/github/auth/provider.go-	return "", nil
./pkg/adapters/github/auth/provider.go-}
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-// SetAuthHeaders does nothing for no authentication
./pkg/adapters/github/auth/provider.go-func (p *NoAuthProvider) SetAuthHeaders(req *http.Request) error {
./pkg/adapters/github/auth/provider.go-	// No authentication headers to set
./pkg/adapters/github/auth/provider.go-	return nil
./pkg/adapters/github/auth/provider.go-}
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-// AuthenticateRequest does nothing for no authentication
./pkg/adapters/github/auth/provider.go-func (p *NoAuthProvider) AuthenticateRequest(req *http.Request) error {
./pkg/adapters/github/auth/provider.go-	// No authentication needed
./pkg/adapters/github/auth/provider.go-	return nil
./pkg/adapters/github/auth/provider.go-}
./pkg/adapters/github/auth/provider.go-
./pkg/adapters/github/auth/provider.go-// RefreshToken does nothing for no authentication
./pkg/adapters/github/auth/provider.go-func (p *NoAuthProvider) RefreshToken(ctx context.Context) error {
./pkg/adapters/github/auth/provider.go-	return nil
./pkg/adapters/github/auth/provider.go-}
--
./pkg/adapters/github/api/graphql.go:type Config struct {
./pkg/adapters/github/api/graphql.go-	URL            string
./pkg/adapters/github/api/graphql.go-	Token          string
./pkg/adapters/github/api/graphql.go-	AppID          string
./pkg/adapters/github/api/graphql.go-	AppPrivateKey  string
./pkg/adapters/github/api/graphql.go-	UseApp         bool
./pkg/adapters/github/api/graphql.go-	RequestTimeout time.Duration
./pkg/adapters/github/api/graphql.go-}
./pkg/adapters/github/api/graphql.go-
./pkg/adapters/github/api/graphql.go-// NewGraphQLClient creates a new GitHub GraphQL client
./pkg/adapters/github/api/graphql.go-func NewGraphQLClient(config *Config, client *http.Client, rateLimiter resilience.RateLimiter, logger observability.Logger, metricsClient observability.MetricsClient) *GraphQLClient {
./pkg/adapters/github/api/graphql.go-	// Set default URL if not provided
./pkg/adapters/github/api/graphql.go-	if config.URL == "" {
./pkg/adapters/github/api/graphql.go-		config.URL = "https://api.github.com/graphql"
./pkg/adapters/github/api/graphql.go-	}
./pkg/adapters/github/api/graphql.go-
./pkg/adapters/github/api/graphql.go-	// Set default request timeout if not provided
./pkg/adapters/github/api/graphql.go-	if config.RequestTimeout == 0 {
./pkg/adapters/github/api/graphql.go-		config.RequestTimeout = 30 * time.Second
./pkg/adapters/github/api/graphql.go-	}
./pkg/adapters/github/api/graphql.go-
./pkg/adapters/github/api/graphql.go-	return &GraphQLClient{
./pkg/adapters/github/api/graphql.go-		config:        config,
./pkg/adapters/github/api/graphql.go-		client:        client,
./pkg/adapters/github/api/graphql.go-		rateLimiter:   rateLimiter,
./pkg/adapters/github/api/graphql.go-		logger:        logger,
./pkg/adapters/github/api/graphql.go-		metricsClient: metricsClient,
./pkg/adapters/github/api/graphql.go-		queryCache:    make(map[string]map[string]any),
./pkg/adapters/github/api/graphql.go-	}
./pkg/adapters/github/api/graphql.go-}
./pkg/adapters/github/api/graphql.go-
./pkg/adapters/github/api/graphql.go-// GraphQLPaginationOptions defines options for paginated GraphQL queries
./pkg/adapters/github/api/graphql.go-type GraphQLPaginationOptions struct {
./pkg/adapters/github/api/graphql.go-	// PerPage is the number of items per page
./pkg/adapters/github/api/graphql.go-	PerPage int
./pkg/adapters/github/api/graphql.go-	// MaxPages is the maximum number of pages to fetch
./pkg/adapters/github/api/graphql.go-	MaxPages int
./pkg/adapters/github/api/graphql.go-	// PageInfo specifies the GraphQL fields to query for pagination info
./pkg/adapters/github/api/graphql.go-	PageInfo string
./pkg/adapters/github/api/graphql.go-	// ItemsField is the field in the response containing the paginated items
./pkg/adapters/github/api/graphql.go-	ItemsField string
./pkg/adapters/github/api/graphql.go-	// ResultHandler is called for each page of results
./pkg/adapters/github/api/graphql.go-	ResultHandler func(page int, data map[string]any) error
./pkg/adapters/github/api/graphql.go-}
./pkg/adapters/github/api/graphql.go-
./pkg/adapters/github/api/graphql.go-// DefaultGraphQLPaginationOptions returns default pagination options
./pkg/adapters/github/api/graphql.go-func DefaultGraphQLPaginationOptions() *GraphQLPaginationOptions {
./pkg/adapters/github/api/graphql.go-	return &GraphQLPaginationOptions{
./pkg/adapters/github/api/graphql.go-		PerPage:  100,
./pkg/adapters/github/api/graphql.go-		MaxPages: 10,
./pkg/adapters/github/api/graphql.go-		PageInfo: `pageInfo {
--
./pkg/adapters/resilience/timeout.go:type TimeoutConfig struct {
./pkg/adapters/resilience/timeout.go-	Timeout     time.Duration
./pkg/adapters/resilience/timeout.go-	GracePeriod time.Duration // Additional time for cleanup
./pkg/adapters/resilience/timeout.go-}
./pkg/adapters/resilience/timeout.go-
./pkg/adapters/resilience/timeout.go-// ExecuteWithTimeout executes a function with a timeout
./pkg/adapters/resilience/timeout.go-func ExecuteWithTimeout[T any](ctx context.Context, config TimeoutConfig, operation func(context.Context) (T, error)) (T, error) {
./pkg/adapters/resilience/timeout.go-	var result T
./pkg/adapters/resilience/timeout.go-
./pkg/adapters/resilience/timeout.go-	// Create a context with timeout
./pkg/adapters/resilience/timeout.go-	timeoutCtx, cancel := context.WithTimeout(ctx, config.Timeout)
./pkg/adapters/resilience/timeout.go-	defer cancel()
./pkg/adapters/resilience/timeout.go-
./pkg/adapters/resilience/timeout.go-	// Create a channel for the result
./pkg/adapters/resilience/timeout.go-	resultCh := make(chan struct {
./pkg/adapters/resilience/timeout.go-		value T
./pkg/adapters/resilience/timeout.go-		err   error
./pkg/adapters/resilience/timeout.go-	}, 1)
./pkg/adapters/resilience/timeout.go-
./pkg/adapters/resilience/timeout.go-	// Execute the operation in a goroutine
./pkg/adapters/resilience/timeout.go-	go func() {
./pkg/adapters/resilience/timeout.go-		value, err := operation(timeoutCtx)
./pkg/adapters/resilience/timeout.go-		resultCh <- struct {
./pkg/adapters/resilience/timeout.go-			value T
./pkg/adapters/resilience/timeout.go-			err   error
./pkg/adapters/resilience/timeout.go-		}{value, err}
./pkg/adapters/resilience/timeout.go-	}()
./pkg/adapters/resilience/timeout.go-
./pkg/adapters/resilience/timeout.go-	// Wait for result or timeout
./pkg/adapters/resilience/timeout.go-	select {
./pkg/adapters/resilience/timeout.go-	case res := <-resultCh:
./pkg/adapters/resilience/timeout.go-		return res.value, res.err
./pkg/adapters/resilience/timeout.go-	case <-timeoutCtx.Done():
./pkg/adapters/resilience/timeout.go-		// If we have a grace period, wait a bit longer for the operation to complete
./pkg/adapters/resilience/timeout.go-		if config.GracePeriod > 0 {
./pkg/adapters/resilience/timeout.go-			graceCh := time.After(config.GracePeriod)
./pkg/adapters/resilience/timeout.go-			select {
./pkg/adapters/resilience/timeout.go-			case res := <-resultCh:
./pkg/adapters/resilience/timeout.go-				return res.value, res.err
./pkg/adapters/resilience/timeout.go-			case <-graceCh:
./pkg/adapters/resilience/timeout.go-				// Grace period expired, return timeout error
./pkg/adapters/resilience/timeout.go-				return result, fmt.Errorf("operation timed out after %v (plus %v grace period): %w",
./pkg/adapters/resilience/timeout.go-					config.Timeout, config.GracePeriod, context.DeadlineExceeded)
./pkg/adapters/resilience/timeout.go-			}
./pkg/adapters/resilience/timeout.go-		}
./pkg/adapters/resilience/timeout.go-
./pkg/adapters/resilience/timeout.go-		return result, fmt.Errorf("operation timed out after %v: %w",
./pkg/adapters/resilience/timeout.go-			config.Timeout, context.DeadlineExceeded)
./pkg/adapters/resilience/timeout.go-	}
./pkg/adapters/resilience/timeout.go-}
./pkg/adapters/resilience/timeout.go-
--
./pkg/adapters/resilience/circuitbreaker.go:type CircuitBreakerConfig struct {
./pkg/adapters/resilience/circuitbreaker.go-	Name          string
./pkg/adapters/resilience/circuitbreaker.go-	MaxRequests   uint32
./pkg/adapters/resilience/circuitbreaker.go-	Interval      time.Duration
./pkg/adapters/resilience/circuitbreaker.go-	Timeout       time.Duration
./pkg/adapters/resilience/circuitbreaker.go-	ReadyToTrip   func(counts gobreaker.Counts) bool
./pkg/adapters/resilience/circuitbreaker.go-	OnStateChange func(name string, from gobreaker.State, to gobreaker.State)
./pkg/adapters/resilience/circuitbreaker.go-	IsSuccessful  func(err error) bool
./pkg/adapters/resilience/circuitbreaker.go-}
./pkg/adapters/resilience/circuitbreaker.go-
./pkg/adapters/resilience/circuitbreaker.go-// DefaultCircuitBreaker is the default implementation of CircuitBreaker
./pkg/adapters/resilience/circuitbreaker.go-type DefaultCircuitBreaker struct {
./pkg/adapters/resilience/circuitbreaker.go-	breaker *gobreaker.CircuitBreaker
./pkg/adapters/resilience/circuitbreaker.go-	config  CircuitBreakerConfig
./pkg/adapters/resilience/circuitbreaker.go-}
./pkg/adapters/resilience/circuitbreaker.go-
./pkg/adapters/resilience/circuitbreaker.go-// NewCircuitBreaker creates a new circuit breaker
./pkg/adapters/resilience/circuitbreaker.go-func NewCircuitBreaker(config CircuitBreakerConfig) CircuitBreaker {
./pkg/adapters/resilience/circuitbreaker.go-	// Set default values if not provided
./pkg/adapters/resilience/circuitbreaker.go-	if config.Interval == 0 {
./pkg/adapters/resilience/circuitbreaker.go-		config.Interval = 30 * time.Second
./pkg/adapters/resilience/circuitbreaker.go-	}
./pkg/adapters/resilience/circuitbreaker.go-	if config.Timeout == 0 {
./pkg/adapters/resilience/circuitbreaker.go-		config.Timeout = 60 * time.Second
./pkg/adapters/resilience/circuitbreaker.go-	}
./pkg/adapters/resilience/circuitbreaker.go-	if config.MaxRequests == 0 {
./pkg/adapters/resilience/circuitbreaker.go-		config.MaxRequests = 1
./pkg/adapters/resilience/circuitbreaker.go-	}
./pkg/adapters/resilience/circuitbreaker.go-	if config.ReadyToTrip == nil {
./pkg/adapters/resilience/circuitbreaker.go-		config.ReadyToTrip = func(counts gobreaker.Counts) bool {
./pkg/adapters/resilience/circuitbreaker.go-			failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
./pkg/adapters/resilience/circuitbreaker.go-			return counts.Requests >= 5 && failureRatio >= 0.5
./pkg/adapters/resilience/circuitbreaker.go-		}
./pkg/adapters/resilience/circuitbreaker.go-	}
./pkg/adapters/resilience/circuitbreaker.go-
./pkg/adapters/resilience/circuitbreaker.go-	// Create circuit breaker settings
./pkg/adapters/resilience/circuitbreaker.go-	settings := gobreaker.Settings{
./pkg/adapters/resilience/circuitbreaker.go-		Name:          config.Name,
./pkg/adapters/resilience/circuitbreaker.go-		MaxRequests:   config.MaxRequests,
./pkg/adapters/resilience/circuitbreaker.go-		Interval:      config.Interval,
./pkg/adapters/resilience/circuitbreaker.go-		Timeout:       config.Timeout,
./pkg/adapters/resilience/circuitbreaker.go-		ReadyToTrip:   config.ReadyToTrip,
./pkg/adapters/resilience/circuitbreaker.go-		OnStateChange: config.OnStateChange,
./pkg/adapters/resilience/circuitbreaker.go-		IsSuccessful:  config.IsSuccessful,
./pkg/adapters/resilience/circuitbreaker.go-	}
./pkg/adapters/resilience/circuitbreaker.go-
./pkg/adapters/resilience/circuitbreaker.go-	return &DefaultCircuitBreaker{
./pkg/adapters/resilience/circuitbreaker.go-		breaker: gobreaker.NewCircuitBreaker(settings),
./pkg/adapters/resilience/circuitbreaker.go-		config:  config,
./pkg/adapters/resilience/circuitbreaker.go-	}
./pkg/adapters/resilience/circuitbreaker.go-}
--
./pkg/adapters/resilience/bulkhead.go:type BulkheadConfig struct {
./pkg/adapters/resilience/bulkhead.go-	Name           string
./pkg/adapters/resilience/bulkhead.go-	MaxConcurrent  int
./pkg/adapters/resilience/bulkhead.go-	MaxWaitingTime time.Duration
./pkg/adapters/resilience/bulkhead.go-}
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-// Bulkhead defines the interface for a bulkhead
./pkg/adapters/resilience/bulkhead.go-type Bulkhead interface {
./pkg/adapters/resilience/bulkhead.go-	// Execute executes a function with bulkhead protection
./pkg/adapters/resilience/bulkhead.go-	Execute(ctx context.Context, fn func() (any, error)) (any, error)
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-	// Name returns the bulkhead name
./pkg/adapters/resilience/bulkhead.go-	Name() string
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-	// CurrentExecutions returns the number of current executions
./pkg/adapters/resilience/bulkhead.go-	CurrentExecutions() int
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-	// RemainingExecutions returns the number of remaining executions
./pkg/adapters/resilience/bulkhead.go-	RemainingExecutions() int
./pkg/adapters/resilience/bulkhead.go-}
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-// DefaultBulkhead is the default implementation of Bulkhead
./pkg/adapters/resilience/bulkhead.go-type DefaultBulkhead struct {
./pkg/adapters/resilience/bulkhead.go-	config       BulkheadConfig
./pkg/adapters/resilience/bulkhead.go-	semaphore    chan struct{}
./pkg/adapters/resilience/bulkhead.go-	currentCount int
./pkg/adapters/resilience/bulkhead.go-	mu           sync.Mutex
./pkg/adapters/resilience/bulkhead.go-}
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-// NewBulkhead creates a new bulkhead
./pkg/adapters/resilience/bulkhead.go-func NewBulkhead(config BulkheadConfig) Bulkhead {
./pkg/adapters/resilience/bulkhead.go-	// Set default values if not provided
./pkg/adapters/resilience/bulkhead.go-	if config.MaxConcurrent <= 0 {
./pkg/adapters/resilience/bulkhead.go-		config.MaxConcurrent = 10
./pkg/adapters/resilience/bulkhead.go-	}
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-	return &DefaultBulkhead{
./pkg/adapters/resilience/bulkhead.go-		config:       config,
./pkg/adapters/resilience/bulkhead.go-		semaphore:    make(chan struct{}, config.MaxConcurrent),
./pkg/adapters/resilience/bulkhead.go-		currentCount: 0,
./pkg/adapters/resilience/bulkhead.go-	}
./pkg/adapters/resilience/bulkhead.go-}
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-// Execute executes a function with bulkhead protection
./pkg/adapters/resilience/bulkhead.go-func (b *DefaultBulkhead) Execute(ctx context.Context, fn func() (any, error)) (any, error) {
./pkg/adapters/resilience/bulkhead.go-	// Create a context with timeout if MaxWaitingTime is set
./pkg/adapters/resilience/bulkhead.go-	var ctxToUse context.Context
./pkg/adapters/resilience/bulkhead.go-	var cancel context.CancelFunc
./pkg/adapters/resilience/bulkhead.go-
./pkg/adapters/resilience/bulkhead.go-	if b.config.MaxWaitingTime > 0 {
./pkg/adapters/resilience/bulkhead.go-		ctxToUse, cancel = context.WithTimeout(ctx, b.config.MaxWaitingTime)
--
./pkg/adapters/resilience/retry.go:type RetryConfig struct {
./pkg/adapters/resilience/retry.go-	MaxRetries      int
./pkg/adapters/resilience/retry.go-	InitialInterval time.Duration
./pkg/adapters/resilience/retry.go-	MaxInterval     time.Duration
./pkg/adapters/resilience/retry.go-	Multiplier      float64
./pkg/adapters/resilience/retry.go-	MaxElapsedTime  time.Duration
./pkg/adapters/resilience/retry.go-	RetryIfFn       func(error) bool
./pkg/adapters/resilience/retry.go-}
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-// Retry retries a function with exponential backoff
./pkg/adapters/resilience/retry.go-func Retry(ctx context.Context, config RetryConfig, operation func() error) error {
./pkg/adapters/resilience/retry.go-	// Create exponential backoff
./pkg/adapters/resilience/retry.go-	b := backoff.NewExponentialBackOff()
./pkg/adapters/resilience/retry.go-	b.InitialInterval = config.InitialInterval
./pkg/adapters/resilience/retry.go-	b.MaxInterval = config.MaxInterval
./pkg/adapters/resilience/retry.go-	b.Multiplier = config.Multiplier
./pkg/adapters/resilience/retry.go-	b.MaxElapsedTime = config.MaxElapsedTime
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-	// If MaxRetries is set, limit the number of retries
./pkg/adapters/resilience/retry.go-	var backoffWithRetries backoff.BackOff = b
./pkg/adapters/resilience/retry.go-	if config.MaxRetries > 0 {
./pkg/adapters/resilience/retry.go-		backoffWithRetries = backoff.WithMaxRetries(b, uint64(config.MaxRetries))
./pkg/adapters/resilience/retry.go-	}
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-	// Create context-aware backoff
./pkg/adapters/resilience/retry.go-	ctxBackoff := backoff.WithContext(backoffWithRetries, ctx)
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-	// Define operation to retry
./pkg/adapters/resilience/retry.go-	return backoff.Retry(func() error {
./pkg/adapters/resilience/retry.go-		err := operation()
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-		// Check if we should retry this error
./pkg/adapters/resilience/retry.go-		if err != nil && config.RetryIfFn != nil && !config.RetryIfFn(err) {
./pkg/adapters/resilience/retry.go-			// Return a special error to stop retries
./pkg/adapters/resilience/retry.go-			return backoff.Permanent(err)
./pkg/adapters/resilience/retry.go-		}
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-		return err
./pkg/adapters/resilience/retry.go-	}, ctxBackoff)
./pkg/adapters/resilience/retry.go-}
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-// RetryWithResult retries a function with exponential backoff and returns a result
./pkg/adapters/resilience/retry.go-func RetryWithResult[T any](ctx context.Context, config RetryConfig, operation func() (T, error)) (T, error) {
./pkg/adapters/resilience/retry.go-	var result T
./pkg/adapters/resilience/retry.go-	var resultErr error
./pkg/adapters/resilience/retry.go-
./pkg/adapters/resilience/retry.go-	// Wrap the operation to use with Retry
./pkg/adapters/resilience/retry.go-	operationWrapper := func() error {
./pkg/adapters/resilience/retry.go-		var err error
./pkg/adapters/resilience/retry.go-		result, err = operation()
./pkg/adapters/resilience/retry.go-		if err != nil {
--
./pkg/adapters/resilience/ratelimiter.go:type RateLimiterConfig struct {
./pkg/adapters/resilience/ratelimiter.go-	Name      string
./pkg/adapters/resilience/ratelimiter.go-	Rate      float64 // Rate per second
./pkg/adapters/resilience/ratelimiter.go-	Burst     int
./pkg/adapters/resilience/ratelimiter.go-	WaitLimit time.Duration
./pkg/adapters/resilience/ratelimiter.go-}
./pkg/adapters/resilience/ratelimiter.go-
./pkg/adapters/resilience/ratelimiter.go-// DefaultRateLimiter is the default implementation of RateLimiter
./pkg/adapters/resilience/ratelimiter.go-type DefaultRateLimiter struct {
./pkg/adapters/resilience/ratelimiter.go-	limiter *rate.Limiter
./pkg/adapters/resilience/ratelimiter.go-	config  RateLimiterConfig
./pkg/adapters/resilience/ratelimiter.go-	// Reset time based on GitHub API headers
./pkg/adapters/resilience/ratelimiter.go-	resetTime     time.Time
./pkg/adapters/resilience/ratelimiter.go-	resetLock     sync.RWMutex
./pkg/adapters/resilience/ratelimiter.go-	dynamicFactor float64 // Dynamic adjustment factor based on rate limit usage
./pkg/adapters/resilience/ratelimiter.go-}
./pkg/adapters/resilience/ratelimiter.go-
./pkg/adapters/resilience/ratelimiter.go-// NewRateLimiter creates a new rate limiter
./pkg/adapters/resilience/ratelimiter.go-func NewRateLimiter(config RateLimiterConfig) RateLimiter {
./pkg/adapters/resilience/ratelimiter.go-	// Set default values if not provided
./pkg/adapters/resilience/ratelimiter.go-	if config.Rate <= 0 {
./pkg/adapters/resilience/ratelimiter.go-		config.Rate = 100 // Default to 100 requests per second
./pkg/adapters/resilience/ratelimiter.go-	}
./pkg/adapters/resilience/ratelimiter.go-	if config.Burst <= 0 {
./pkg/adapters/resilience/ratelimiter.go-		config.Burst = 10
./pkg/adapters/resilience/ratelimiter.go-	}
./pkg/adapters/resilience/ratelimiter.go-	if config.WaitLimit <= 0 {
./pkg/adapters/resilience/ratelimiter.go-		config.WaitLimit = 5 * time.Second
./pkg/adapters/resilience/ratelimiter.go-	}
./pkg/adapters/resilience/ratelimiter.go-
./pkg/adapters/resilience/ratelimiter.go-	return &DefaultRateLimiter{
./pkg/adapters/resilience/ratelimiter.go-		limiter:       rate.NewLimiter(rate.Limit(config.Rate), config.Burst),
./pkg/adapters/resilience/ratelimiter.go-		config:        config,
./pkg/adapters/resilience/ratelimiter.go-		dynamicFactor: 1.0, // Start with no adjustment
./pkg/adapters/resilience/ratelimiter.go-	}
./pkg/adapters/resilience/ratelimiter.go-}
./pkg/adapters/resilience/ratelimiter.go-
./pkg/adapters/resilience/ratelimiter.go-// Wait blocks until rate limit allows an event or context is done
./pkg/adapters/resilience/ratelimiter.go-func (rl *DefaultRateLimiter) Wait(ctx context.Context) error {
./pkg/adapters/resilience/ratelimiter.go-	// Check if we're approaching a GitHub API reset time
./pkg/adapters/resilience/ratelimiter.go-	rl.resetLock.RLock()
./pkg/adapters/resilience/ratelimiter.go-	resetTime := rl.resetTime
./pkg/adapters/resilience/ratelimiter.go-	rl.resetLock.RUnlock()
./pkg/adapters/resilience/ratelimiter.go-
./pkg/adapters/resilience/ratelimiter.go-	if !resetTime.IsZero() {
./pkg/adapters/resilience/ratelimiter.go-		timeUntilReset := time.Until(resetTime)
./pkg/adapters/resilience/ratelimiter.go-
./pkg/adapters/resilience/ratelimiter.go-		// If we're very close to the reset time (within 5 seconds)
./pkg/adapters/resilience/ratelimiter.go-		// and we know our rate limit is almost exhausted,
./pkg/adapters/resilience/ratelimiter.go-		// it might be better to wait for the reset
./pkg/adapters/resilience/ratelimiter.go-		if timeUntilReset > 0 && timeUntilReset < 5*time.Second && rl.dynamicFactor < 0.3 {
--
./pkg/adapters/manager.go:type AdapterConfig struct {
./pkg/adapters/manager.go-	Adapters map[string]any
./pkg/adapters/manager.go-}
./pkg/adapters/manager.go-
./pkg/adapters/manager.go-// AdapterManager manages the lifecycle of adapters
./pkg/adapters/manager.go-type AdapterManager struct {
./pkg/adapters/manager.go-	adapters      map[string]Adapter
./pkg/adapters/manager.go-	factory       *Factory
./pkg/adapters/manager.go-	logger        observability.Logger
./pkg/adapters/manager.go-	MetricsClient observability.MetricsClient
./pkg/adapters/manager.go-	mu            sync.RWMutex
./pkg/adapters/manager.go-}
./pkg/adapters/manager.go-
./pkg/adapters/manager.go-// NewAdapterManager creates a new adapter manager
./pkg/adapters/manager.go-func NewAdapterManager(
./pkg/adapters/manager.go-	cfg *AdapterConfig,
./pkg/adapters/manager.go-	_ any, // Formerly contextManager, kept for backward compatibility
./pkg/adapters/manager.go-	systemEventBus system.EventBus,
./pkg/adapters/manager.go-	logger observability.Logger,
./pkg/adapters/manager.go-	metricsClient observability.MetricsClient,
./pkg/adapters/manager.go-) *AdapterManager {
./pkg/adapters/manager.go-	if logger == nil {
./pkg/adapters/manager.go-		logger = observability.NewLogger("adapter_manager")
./pkg/adapters/manager.go-	}
./pkg/adapters/manager.go-
./pkg/adapters/manager.go-	manager := &AdapterManager{
./pkg/adapters/manager.go-		adapters:      make(map[string]Adapter),
./pkg/adapters/manager.go-		factory:       NewFactory(logger),
./pkg/adapters/manager.go-		logger:        logger,
./pkg/adapters/manager.go-		MetricsClient: metricsClient,
./pkg/adapters/manager.go-	}
./pkg/adapters/manager.go-
./pkg/adapters/manager.go-	return manager
./pkg/adapters/manager.go-}
./pkg/adapters/manager.go-
./pkg/adapters/manager.go-// Initialize initializes all required adapters
./pkg/adapters/manager.go-func (m *AdapterManager) Initialize(ctx context.Context) error {
./pkg/adapters/manager.go-	m.logger.Info("Initializing adapter manager", nil)
./pkg/adapters/manager.go-	// Adapters are initialized on-demand
./pkg/adapters/manager.go-	return nil
./pkg/adapters/manager.go-}
./pkg/adapters/manager.go-
./pkg/adapters/manager.go-// GetAdapter gets an adapter by type
./pkg/adapters/manager.go-func (m *AdapterManager) GetAdapter(adapterType string) (any, error) {
./pkg/adapters/manager.go-	ctx := context.Background()
./pkg/adapters/manager.go-	m.mu.RLock()
./pkg/adapters/manager.go-	adapter, exists := m.adapters[adapterType]
./pkg/adapters/manager.go-	m.mu.RUnlock()
./pkg/adapters/manager.go-
./pkg/adapters/manager.go-	if exists {
./pkg/adapters/manager.go-		return adapter, nil
--
./pkg/common/metrics/client.go:type Config struct {
./pkg/common/metrics/client.go-	Enabled      bool          `mapstructure:"enabled"`
./pkg/common/metrics/client.go-	Type         string        `mapstructure:"type"`
./pkg/common/metrics/client.go-	Endpoint     string        `mapstructure:"endpoint"`
./pkg/common/metrics/client.go-	PushGateway  string        `mapstructure:"push_gateway"`
./pkg/common/metrics/client.go-	PushInterval time.Duration `mapstructure:"push_interval"`
./pkg/common/metrics/client.go-}
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-// Client is the interface for metrics collection
./pkg/common/metrics/client.go-type Client interface {
./pkg/common/metrics/client.go-	// RecordEvent records an event metric
./pkg/common/metrics/client.go-	RecordEvent(source, eventType string)
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-	// RecordLatency records a latency metric
./pkg/common/metrics/client.go-	RecordLatency(operation string, duration time.Duration)
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-	// RecordCounter increments a counter metric
./pkg/common/metrics/client.go-	RecordCounter(name string, value float64, labels map[string]string)
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-	// RecordGauge sets a gauge metric
./pkg/common/metrics/client.go-	RecordGauge(name string, value float64, labels map[string]string)
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-	// Close closes the metrics client
./pkg/common/metrics/client.go-	Close() error
./pkg/common/metrics/client.go-}
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-// PrometheusClient implements the metrics client using Prometheus
./pkg/common/metrics/client.go-type PrometheusClient struct {
./pkg/common/metrics/client.go-	config  Config
./pkg/common/metrics/client.go-	metrics map[string]any
./pkg/common/metrics/client.go-	mu      sync.RWMutex
./pkg/common/metrics/client.go-}
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-// NewClient creates a new metrics client
./pkg/common/metrics/client.go-func NewClient(cfg Config) Client {
./pkg/common/metrics/client.go-	if !cfg.Enabled {
./pkg/common/metrics/client.go-		return &NoopClient{}
./pkg/common/metrics/client.go-	}
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-	switch cfg.Type {
./pkg/common/metrics/client.go-	case "prometheus":
./pkg/common/metrics/client.go-		return NewPrometheusClient(cfg)
./pkg/common/metrics/client.go-	default:
./pkg/common/metrics/client.go-		// Default to noop client
./pkg/common/metrics/client.go-		return &NoopClient{}
./pkg/common/metrics/client.go-	}
./pkg/common/metrics/client.go-}
./pkg/common/metrics/client.go-
./pkg/common/metrics/client.go-// NewPrometheusClient creates a new Prometheus metrics client
./pkg/common/metrics/client.go-func NewPrometheusClient(cfg Config) *PrometheusClient {
./pkg/common/metrics/client.go-	client := &PrometheusClient{
--
./pkg/common/cache/multilevel_cache.go:type MultiLevelCacheConfig struct {
./pkg/common/cache/multilevel_cache.go-	L1MaxSize         int           `mapstructure:"l1_max_size"`
./pkg/common/cache/multilevel_cache.go-	DefaultTTL        time.Duration `mapstructure:"default_ttl"`
./pkg/common/cache/multilevel_cache.go-	PrefetchWorkers   int           `mapstructure:"prefetch_workers"`
./pkg/common/cache/multilevel_cache.go-	PrefetchQueueSize int           `mapstructure:"prefetch_queue_size"`
./pkg/common/cache/multilevel_cache.go-}
./pkg/common/cache/multilevel_cache.go-
./pkg/common/cache/multilevel_cache.go-// NewMultiLevelCache creates a new multi-level cache
./pkg/common/cache/multilevel_cache.go-func NewMultiLevelCache(l2Cache Cache, config MultiLevelCacheConfig) (*MultiLevelCache, error) {
./pkg/common/cache/multilevel_cache.go-	// Apply defaults
./pkg/common/cache/multilevel_cache.go-	if config.L1MaxSize <= 0 {
./pkg/common/cache/multilevel_cache.go-		config.L1MaxSize = 1000 // Default to 1000 entries
./pkg/common/cache/multilevel_cache.go-	}
./pkg/common/cache/multilevel_cache.go-	if config.DefaultTTL <= 0 {
./pkg/common/cache/multilevel_cache.go-		config.DefaultTTL = 15 * time.Minute // Default to 15 minutes
./pkg/common/cache/multilevel_cache.go-	}
./pkg/common/cache/multilevel_cache.go-	if config.PrefetchWorkers <= 0 {
./pkg/common/cache/multilevel_cache.go-		config.PrefetchWorkers = 2 // Default to 2 workers
./pkg/common/cache/multilevel_cache.go-	}
./pkg/common/cache/multilevel_cache.go-	if config.PrefetchQueueSize <= 0 {
./pkg/common/cache/multilevel_cache.go-		config.PrefetchQueueSize = 100 // Default to 100 entries
./pkg/common/cache/multilevel_cache.go-	}
./pkg/common/cache/multilevel_cache.go-
./pkg/common/cache/multilevel_cache.go-	// Create L1 cache
./pkg/common/cache/multilevel_cache.go-	l1Cache, err := lru.New[string, []byte](config.L1MaxSize)
./pkg/common/cache/multilevel_cache.go-	if err != nil {
./pkg/common/cache/multilevel_cache.go-		return nil, fmt.Errorf("failed to create L1 cache: %w", err)
./pkg/common/cache/multilevel_cache.go-	}
./pkg/common/cache/multilevel_cache.go-
./pkg/common/cache/multilevel_cache.go-	// Create multi-level cache
./pkg/common/cache/multilevel_cache.go-	mlc := &MultiLevelCache{
./pkg/common/cache/multilevel_cache.go-		l1Cache:         l1Cache,
./pkg/common/cache/multilevel_cache.go-		l2Cache:         l2Cache,
./pkg/common/cache/multilevel_cache.go-		ttl:             config.DefaultTTL,
./pkg/common/cache/multilevel_cache.go-		metricsClient:   observability.NewMetricsClient(),
./pkg/common/cache/multilevel_cache.go-		prefetchQueue:   make(chan prefetchRequest, config.PrefetchQueueSize),
./pkg/common/cache/multilevel_cache.go-		prefetchWorkers: config.PrefetchWorkers,
./pkg/common/cache/multilevel_cache.go-	}
./pkg/common/cache/multilevel_cache.go-
./pkg/common/cache/multilevel_cache.go-	// Start prefetch workers
./pkg/common/cache/multilevel_cache.go-	for i := 0; i < config.PrefetchWorkers; i++ {
./pkg/common/cache/multilevel_cache.go-		go mlc.prefetchWorker()
./pkg/common/cache/multilevel_cache.go-	}
./pkg/common/cache/multilevel_cache.go-
./pkg/common/cache/multilevel_cache.go-	return mlc, nil
./pkg/common/cache/multilevel_cache.go-}
./pkg/common/cache/multilevel_cache.go-
./pkg/common/cache/multilevel_cache.go-// prefetchWorker processes prefetch requests
./pkg/common/cache/multilevel_cache.go-func (c *MultiLevelCache) prefetchWorker() {
./pkg/common/cache/multilevel_cache.go-	for req := range c.prefetchQueue {
./pkg/common/cache/multilevel_cache.go-		// Skip if already in L1 cache to avoid unnecessary work
--
./pkg/common/cache/init_test.go:		type UnsupportedConfig struct {
./pkg/common/cache/init_test.go-			Type string
./pkg/common/cache/init_test.go-		}
./pkg/common/cache/init_test.go-		unsupportedConfig := UnsupportedConfig{
./pkg/common/cache/init_test.go-			Type: "unsupported",
./pkg/common/cache/init_test.go-		}
./pkg/common/cache/init_test.go-
./pkg/common/cache/init_test.go-		ctx := context.Background()
./pkg/common/cache/init_test.go-		cache, err := NewCache(ctx, unsupportedConfig)
./pkg/common/cache/init_test.go-		assert.Error(t, err)
./pkg/common/cache/init_test.go-		assert.Nil(t, cache)
./pkg/common/cache/init_test.go-		assert.Contains(t, err.Error(), "unsupported cache type")
./pkg/common/cache/init_test.go-	})
./pkg/common/cache/init_test.go-}
--
./pkg/common/cache/redis_cluster.go:type RedisClusterConfig struct {
./pkg/common/cache/redis_cluster.go-	Addrs          []string
./pkg/common/cache/redis_cluster.go-	Username       string
./pkg/common/cache/redis_cluster.go-	Password       string
./pkg/common/cache/redis_cluster.go-	MaxRetries     int
./pkg/common/cache/redis_cluster.go-	MinIdleConns   int
./pkg/common/cache/redis_cluster.go-	PoolSize       int
./pkg/common/cache/redis_cluster.go-	DialTimeout    time.Duration
./pkg/common/cache/redis_cluster.go-	ReadTimeout    time.Duration
./pkg/common/cache/redis_cluster.go-	WriteTimeout   time.Duration
./pkg/common/cache/redis_cluster.go-	PoolTimeout    time.Duration
./pkg/common/cache/redis_cluster.go-	UseTLS         bool
./pkg/common/cache/redis_cluster.go-	TLSConfig      *tls.Config
./pkg/common/cache/redis_cluster.go-	RouteRandomly  bool
./pkg/common/cache/redis_cluster.go-	RouteByLatency bool
./pkg/common/cache/redis_cluster.go-}
./pkg/common/cache/redis_cluster.go-
./pkg/common/cache/redis_cluster.go-// NewRedisClusterCache creates a new Redis cluster cache
./pkg/common/cache/redis_cluster.go-func NewRedisClusterCache(cfg RedisClusterConfig) (*RedisClusterCache, error) {
./pkg/common/cache/redis_cluster.go-	// Create Redis cluster options
./pkg/common/cache/redis_cluster.go-	options := &redis.ClusterOptions{
./pkg/common/cache/redis_cluster.go-		Addrs:          cfg.Addrs,
./pkg/common/cache/redis_cluster.go-		MaxRetries:     cfg.MaxRetries,
./pkg/common/cache/redis_cluster.go-		MinIdleConns:   cfg.MinIdleConns,
./pkg/common/cache/redis_cluster.go-		PoolSize:       cfg.PoolSize,
./pkg/common/cache/redis_cluster.go-		DialTimeout:    cfg.DialTimeout,
./pkg/common/cache/redis_cluster.go-		ReadTimeout:    cfg.ReadTimeout,
./pkg/common/cache/redis_cluster.go-		WriteTimeout:   cfg.WriteTimeout,
./pkg/common/cache/redis_cluster.go-		PoolTimeout:    cfg.PoolTimeout,
./pkg/common/cache/redis_cluster.go-		RouteRandomly:  cfg.RouteRandomly,
./pkg/common/cache/redis_cluster.go-		RouteByLatency: cfg.RouteByLatency,
./pkg/common/cache/redis_cluster.go-	}
./pkg/common/cache/redis_cluster.go-
./pkg/common/cache/redis_cluster.go-	// Add authentication if provided
./pkg/common/cache/redis_cluster.go-	if cfg.Username != "" {
./pkg/common/cache/redis_cluster.go-		options.Username = cfg.Username
./pkg/common/cache/redis_cluster.go-	}
./pkg/common/cache/redis_cluster.go-
./pkg/common/cache/redis_cluster.go-	if cfg.Password != "" {
./pkg/common/cache/redis_cluster.go-		options.Password = cfg.Password
./pkg/common/cache/redis_cluster.go-	}
./pkg/common/cache/redis_cluster.go-
./pkg/common/cache/redis_cluster.go-	// Add TLS if enabled
./pkg/common/cache/redis_cluster.go-	if cfg.UseTLS {
./pkg/common/cache/redis_cluster.go-		options.TLSConfig = cfg.TLSConfig
./pkg/common/cache/redis_cluster.go-	}
./pkg/common/cache/redis_cluster.go-
./pkg/common/cache/redis_cluster.go-	// Create Redis cluster client
./pkg/common/cache/redis_cluster.go-	client := redis.NewClusterClient(options)
./pkg/common/cache/redis_cluster.go-
./pkg/common/cache/redis_cluster.go-	// Test connection
--
./pkg/common/cache/init.go:type RedisConfig struct {
./pkg/common/cache/init.go-	Type         string        `mapstructure:"type"`           // "redis" or "redis_cluster"
./pkg/common/cache/init.go-	Address      string        `mapstructure:"address"`        // Redis address (single instance)
./pkg/common/cache/init.go-	Addresses    []string      `mapstructure:"addresses"`      // Redis addresses (cluster mode)
./pkg/common/cache/init.go-	Username     string        `mapstructure:"username"`       // Redis username
./pkg/common/cache/init.go-	Password     string        `mapstructure:"password"`       // Redis password
./pkg/common/cache/init.go-	Database     int           `mapstructure:"database"`       // Redis database number (single mode only)
./pkg/common/cache/init.go-	MaxRetries   int           `mapstructure:"max_retries"`    // Max retries on failure
./pkg/common/cache/init.go-	DialTimeout  time.Duration `mapstructure:"dial_timeout"`   // Dial timeout
./pkg/common/cache/init.go-	ReadTimeout  time.Duration `mapstructure:"read_timeout"`   // Read timeout
./pkg/common/cache/init.go-	WriteTimeout time.Duration `mapstructure:"write_timeout"`  // Write timeout
./pkg/common/cache/init.go-	PoolSize     int           `mapstructure:"pool_size"`      // Connection pool size
./pkg/common/cache/init.go-	MinIdleConns int           `mapstructure:"min_idle_conns"` // Min idle connections
./pkg/common/cache/init.go-	PoolTimeout  int           `mapstructure:"pool_timeout"`   // Pool timeout in seconds
./pkg/common/cache/init.go-	UseIAMAuth   bool          `mapstructure:"use_iam_auth"`   // Use IAM authentication for Redis
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-	// AWS ElastiCache specific configuration
./pkg/common/cache/init.go-	UseAWS            bool                   `mapstructure:"use_aws"`      // Use AWS ElastiCache
./pkg/common/cache/init.go-	ClusterMode       bool                   `mapstructure:"cluster_mode"` // Use ElastiCache in cluster mode
./pkg/common/cache/init.go-	ElastiCacheConfig *aws.ElastiCacheConfig `mapstructure:"elasticache"`  // ElastiCache configuration
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-	// TLS configuration
./pkg/common/cache/init.go-	TLS *TLSConfig `mapstructure:"tls"` // TLS configuration
./pkg/common/cache/init.go-}
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-// TLSConfig holds TLS configuration
./pkg/common/cache/init.go:type TLSConfig struct {
./pkg/common/cache/init.go-	securitytls.Config `mapstructure:",squash"` // Embed secure TLS configuration
./pkg/common/cache/init.go-}
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-// NewCache creates a new cache based on the configuration
./pkg/common/cache/init.go-func NewCache(ctx context.Context, cfg interface{}) (Cache, error) {
./pkg/common/cache/init.go-	switch config := cfg.(type) {
./pkg/common/cache/init.go-	case RedisConfig:
./pkg/common/cache/init.go-		// Default to AWS ElastiCache with IAM auth in production environments
./pkg/common/cache/init.go-		isLocalEnv := os.Getenv("MCP_ENV") == "local" || os.Getenv("MCP_ENVIRONMENT") == "local"
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-		// Determine if we should use AWS ElastiCache
./pkg/common/cache/init.go-		useAWS := config.UseAWS
./pkg/common/cache/init.go-		if !isLocalEnv && config.ElastiCacheConfig != nil {
./pkg/common/cache/init.go-			// In non-local environments, prefer AWS ElastiCache unless explicitly disabled
./pkg/common/cache/init.go-			useAWS = true
./pkg/common/cache/init.go-		}
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-		// If we should use AWS ElastiCache
./pkg/common/cache/init.go-		if useAWS && config.ElastiCacheConfig != nil {
./pkg/common/cache/init.go-			return newAWSElastiCacheClient(ctx, config)
./pkg/common/cache/init.go-		}
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-		// Check if we should use cluster mode
./pkg/common/cache/init.go-		if config.Type == "redis_cluster" || len(config.Addresses) > 0 {
./pkg/common/cache/init.go-			return newRedisClusterClient(config)
./pkg/common/cache/init.go-		}
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-		// Standard Redis client
./pkg/common/cache/init.go-		return NewRedisCache(RedisConfig{
./pkg/common/cache/init.go-			Address:      config.Address,
./pkg/common/cache/init.go-			Username:     config.Username,
./pkg/common/cache/init.go-			Password:     config.Password,
./pkg/common/cache/init.go-			Database:     config.Database,
./pkg/common/cache/init.go-			MaxRetries:   config.MaxRetries,
./pkg/common/cache/init.go-			DialTimeout:  config.DialTimeout,
./pkg/common/cache/init.go-			ReadTimeout:  config.ReadTimeout,
./pkg/common/cache/init.go-			WriteTimeout: config.WriteTimeout,
./pkg/common/cache/init.go-			PoolSize:     config.PoolSize,
./pkg/common/cache/init.go-			MinIdleConns: config.MinIdleConns,
./pkg/common/cache/init.go-			PoolTimeout:  config.PoolTimeout,
./pkg/common/cache/init.go-			TLS:          config.TLS,
./pkg/common/cache/init.go-		})
./pkg/common/cache/init.go-	default:
./pkg/common/cache/init.go-		return nil, fmt.Errorf("unsupported cache type: %T", cfg)
./pkg/common/cache/init.go-	}
./pkg/common/cache/init.go-}
./pkg/common/cache/init.go-
./pkg/common/cache/init.go-// newRedisClusterClient creates a new Redis cluster client
./pkg/common/cache/init.go-func newRedisClusterClient(config RedisConfig) (Cache, error) {
./pkg/common/cache/init.go-	// Create cluster configuration
--
./pkg/common/config/database_config.go:type DatabaseConfig struct {
./pkg/common/config/database_config.go-	Driver          string               `yaml:"driver" mapstructure:"driver"`
./pkg/common/config/database_config.go-	DSN             string               `yaml:"dsn" mapstructure:"dsn"`
./pkg/common/config/database_config.go-	Host            string               `yaml:"host" mapstructure:"host"`
./pkg/common/config/database_config.go-	Port            int                  `yaml:"port" mapstructure:"port"`
./pkg/common/config/database_config.go-	Username        string               `yaml:"username" mapstructure:"username"`
./pkg/common/config/database_config.go-	Password        string               `yaml:"password" mapstructure:"password"`
./pkg/common/config/database_config.go-	Database        string               `yaml:"database" mapstructure:"database"`
./pkg/common/config/database_config.go-	SearchPath      string               `yaml:"search_path" mapstructure:"search_path"`
./pkg/common/config/database_config.go-	SSLMode         string               `yaml:"ssl_mode" mapstructure:"ssl_mode"`
./pkg/common/config/database_config.go-	MaxOpenConns    int                  `yaml:"max_open_conns" mapstructure:"max_open_conns"`
./pkg/common/config/database_config.go-	MaxIdleConns    int                  `yaml:"max_idle_conns" mapstructure:"max_idle_conns"`
./pkg/common/config/database_config.go-	ConnMaxLifetime time.Duration        `yaml:"conn_max_lifetime" mapstructure:"conn_max_lifetime"`
./pkg/common/config/database_config.go-	ConnMaxIdleTime time.Duration        `yaml:"conn_max_idle_time" mapstructure:"conn_max_idle_time"`
./pkg/common/config/database_config.go-	UseIAMAuth      bool                 `yaml:"use_iam_auth" mapstructure:"use_iam_auth"`
./pkg/common/config/database_config.go-	TokenExpiration int                  `yaml:"token_expiration" mapstructure:"token_expiration"`
./pkg/common/config/database_config.go-	Vector          DatabaseVectorConfig `yaml:"vector" mapstructure:"vector"`
./pkg/common/config/database_config.go-	AuthConfig      struct {
./pkg/common/config/database_config.go-		Region     string `yaml:"region" mapstructure:"region"`
./pkg/common/config/database_config.go-		Endpoint   string `yaml:"endpoint" mapstructure:"endpoint"`
./pkg/common/config/database_config.go-		AssumeRole string `yaml:"assume_role" mapstructure:"assume_role"`
./pkg/common/config/database_config.go-	} `yaml:"auth" mapstructure:"auth"`
./pkg/common/config/database_config.go-}
./pkg/common/config/database_config.go-
./pkg/common/config/database_config.go-// DatabaseVectorConfig holds configuration for vector database operations
./pkg/common/config/database_config.go:type DatabaseVectorConfig struct {
./pkg/common/config/database_config.go-	Enabled          bool                     `yaml:"enabled"`
./pkg/common/config/database_config.go-	IndexType        string                   `yaml:"index_type"`
./pkg/common/config/database_config.go-	Lists            int                      `yaml:"lists"`
./pkg/common/config/database_config.go-	Probes           int                      `yaml:"probes"`
./pkg/common/config/database_config.go-	Dimensions       int                      `yaml:"dimensions"`
./pkg/common/config/database_config.go-	SimilarityMetric string                   `yaml:"similarity_metric"`
./pkg/common/config/database_config.go-	Pool             DatabaseVectorPoolConfig `yaml:"pool"`
./pkg/common/config/database_config.go-}
./pkg/common/config/database_config.go-
./pkg/common/config/database_config.go-// DatabaseVectorPoolConfig holds configuration for the vector database connection pool
./pkg/common/config/database_config.go:type DatabaseVectorPoolConfig struct {
./pkg/common/config/database_config.go-	Enabled         bool          `yaml:"enabled"`
./pkg/common/config/database_config.go-	MaxOpenConns    int           `yaml:"max_open_conns"`
./pkg/common/config/database_config.go-	MaxIdleConns    int           `yaml:"max_idle_conns"`
./pkg/common/config/database_config.go-	ConnMaxLifetime time.Duration `yaml:"conn_max_lifetime"`
./pkg/common/config/database_config.go-}
./pkg/common/config/database_config.go-
./pkg/common/config/database_config.go-// GetDefaultDatabaseConfig returns default database configuration
./pkg/common/config/database_config.go-func GetDefaultDatabaseConfig() DatabaseConfig {
./pkg/common/config/database_config.go-	return DatabaseConfig{
./pkg/common/config/database_config.go-		Driver:          "postgres",
./pkg/common/config/database_config.go-		Host:            "localhost",
./pkg/common/config/database_config.go-		Port:            5432,
./pkg/common/config/database_config.go-		Database:        "mcp",
./pkg/common/config/database_config.go-		Username:        "postgres",
./pkg/common/config/database_config.go-		Password:        "",
./pkg/common/config/database_config.go-		SSLMode:         "disable",
./pkg/common/config/database_config.go-		MaxOpenConns:    25,
./pkg/common/config/database_config.go-		MaxIdleConns:    5,
./pkg/common/config/database_config.go-		ConnMaxLifetime: 5 * time.Minute,
./pkg/common/config/database_config.go-		ConnMaxIdleTime: 2 * time.Minute,
./pkg/common/config/database_config.go-		UseIAMAuth:      false,
./pkg/common/config/database_config.go-		TokenExpiration: 900,
./pkg/common/config/database_config.go-		AuthConfig: struct {
./pkg/common/config/database_config.go-			Region     string `yaml:"region" mapstructure:"region"`
./pkg/common/config/database_config.go-			Endpoint   string `yaml:"endpoint" mapstructure:"endpoint"`
./pkg/common/config/database_config.go-			AssumeRole string `yaml:"assume_role" mapstructure:"assume_role"`
./pkg/common/config/database_config.go-		}{
./pkg/common/config/database_config.go-			Region:   "us-west-2",
./pkg/common/config/database_config.go-			Endpoint: "",
./pkg/common/config/database_config.go-		},
./pkg/common/config/database_config.go-		Vector: DatabaseVectorConfig{
./pkg/common/config/database_config.go-			Enabled:   true,
./pkg/common/config/database_config.go-			IndexType: "ivfflat",
./pkg/common/config/database_config.go-			Lists:     100,
./pkg/common/config/database_config.go-			Probes:    10,
./pkg/common/config/database_config.go-			Pool: DatabaseVectorPoolConfig{
./pkg/common/config/database_config.go-				Enabled:         false,
./pkg/common/config/database_config.go-				MaxOpenConns:    25,
./pkg/common/config/database_config.go-				MaxIdleConns:    5,
./pkg/common/config/database_config.go-				ConnMaxLifetime: 10 * time.Minute,
./pkg/common/config/database_config.go-			},
./pkg/common/config/database_config.go-		},
./pkg/common/config/database_config.go-	}
./pkg/common/config/database_config.go-}
--
./pkg/common/config/config.go:type APIConfig struct {
./pkg/common/config/config.go-	ListenAddress  string         `mapstructure:"listen_address"`
./pkg/common/config/config.go-	BaseURL        string         `mapstructure:"base_url"`
./pkg/common/config/config.go-	TLSCertFile    string         `mapstructure:"tls_cert_file"`
./pkg/common/config/config.go-	TLSKeyFile     string         `mapstructure:"tls_key_file"`
./pkg/common/config/config.go-	CORSAllowed    string         `mapstructure:"cors_allowed"`
./pkg/common/config/config.go-	RateLimit      map[string]any `mapstructure:"rate_limit"`
./pkg/common/config/config.go-	RequestTimeout int            `mapstructure:"request_timeout"`
./pkg/common/config/config.go-	ReadTimeout    time.Duration  `mapstructure:"read_timeout"`
./pkg/common/config/config.go-	WriteTimeout   time.Duration  `mapstructure:"write_timeout"`
./pkg/common/config/config.go-	IdleTimeout    time.Duration  `mapstructure:"idle_timeout"`
./pkg/common/config/config.go-	EnableCORS     bool           `mapstructure:"enable_cors"`
./pkg/common/config/config.go-	EnableSwagger  bool           `mapstructure:"enable_swagger"`
./pkg/common/config/config.go-	Auth           map[string]any `mapstructure:"auth"`
./pkg/common/config/config.go-	Webhook        map[string]any `mapstructure:"webhook"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// CoreConfig defines the engine core configuration
./pkg/common/config/config.go:type CoreConfig struct {
./pkg/common/config/config.go-	EventBufferSize  int           `mapstructure:"event_buffer_size"`
./pkg/common/config/config.go-	ConcurrencyLimit int           `mapstructure:"concurrency_limit"`
./pkg/common/config/config.go-	EventTimeout     time.Duration `mapstructure:"event_timeout"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// Config holds the complete application configuration
./pkg/common/config/config.go:type Config struct {
./pkg/common/config/config.go-	API         APIConfig         `mapstructure:"api"`
./pkg/common/config/config.go-	Cache       cache.RedisConfig `mapstructure:"cache"`
./pkg/common/config/config.go-	Database    DatabaseConfig    `mapstructure:"database"`
./pkg/common/config/config.go-	Engine      CoreConfig        `mapstructure:"engine"`
./pkg/common/config/config.go-	Metrics     metrics.Config    `mapstructure:"metrics"`
./pkg/common/config/config.go-	AWS         AWSConfig         `mapstructure:"aws"`
./pkg/common/config/config.go-	Environment string            `mapstructure:"environment"`
./pkg/common/config/config.go-	Adapters    map[string]any    `mapstructure:"adapters"`
./pkg/common/config/config.go-	WebSocket   *WebSocketConfig  `mapstructure:"websocket"`
./pkg/common/config/config.go-	MCPServer   *MCPServerConfig  `mapstructure:"mcp_server"`
./pkg/common/config/config.go-	Embedding   EmbeddingConfig   `mapstructure:"embedding"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// RestAPIConfig holds configuration for connecting to REST API service
./pkg/common/config/config.go:type RestAPIConfig struct {
./pkg/common/config/config.go-	Enabled    bool          `mapstructure:"enabled"`
./pkg/common/config/config.go-	BaseURL    string        `mapstructure:"base_url"`
./pkg/common/config/config.go-	APIKey     string        `mapstructure:"api_key"`
./pkg/common/config/config.go-	Timeout    time.Duration `mapstructure:"timeout"`
./pkg/common/config/config.go-	RetryCount int           `mapstructure:"retry_count"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// MCPServerConfig holds MCP-specific configuration overrides
./pkg/common/config/config.go:type MCPServerConfig struct {
./pkg/common/config/config.go-	ListenAddress string        `mapstructure:"listen_address"`
./pkg/common/config/config.go-	RestAPI       RestAPIConfig `mapstructure:"rest_api"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// WebSocketConfig holds WebSocket server configuration
./pkg/common/config/config.go:type WebSocketConfig struct {
./pkg/common/config/config.go-	Enabled         bool                      `mapstructure:"enabled"`
./pkg/common/config/config.go-	MaxConnections  int                       `mapstructure:"max_connections"`
./pkg/common/config/config.go-	ReadBufferSize  int                       `mapstructure:"read_buffer_size"`
./pkg/common/config/config.go-	WriteBufferSize int                       `mapstructure:"write_buffer_size"`
./pkg/common/config/config.go-	PingInterval    time.Duration             `mapstructure:"ping_interval"`
./pkg/common/config/config.go-	PongTimeout     time.Duration             `mapstructure:"pong_timeout"`
./pkg/common/config/config.go-	MaxMessageSize  int64                     `mapstructure:"max_message_size"`
./pkg/common/config/config.go-	Security        *WebSocketSecurityConfig  `mapstructure:"security"`
./pkg/common/config/config.go-	RateLimit       *WebSocketRateLimitConfig `mapstructure:"rate_limit"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// WebSocketSecurityConfig holds WebSocket security configuration
./pkg/common/config/config.go:type WebSocketSecurityConfig struct {
./pkg/common/config/config.go-	RequireAuth    bool     `mapstructure:"require_auth"`
./pkg/common/config/config.go-	HMACSignatures bool     `mapstructure:"hmac_signatures"`
./pkg/common/config/config.go-	AllowedOrigins []string `mapstructure:"allowed_origins"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// WebSocketRateLimitConfig holds WebSocket rate limiting configuration
./pkg/common/config/config.go:type WebSocketRateLimitConfig struct {
./pkg/common/config/config.go-	Rate    float64 `mapstructure:"rate"`
./pkg/common/config/config.go-	Burst   int     `mapstructure:"burst"`
./pkg/common/config/config.go-	PerIP   bool    `mapstructure:"per_ip"`
./pkg/common/config/config.go-	PerUser bool    `mapstructure:"per_user"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// AWSConfig holds configuration for AWS services
./pkg/common/config/config.go:type AWSConfig struct {
./pkg/common/config/config.go-	RDS         aws.RDSConfig         `mapstructure:"rds"`
./pkg/common/config/config.go-	ElastiCache aws.ElastiCacheConfig `mapstructure:"elasticache"`
./pkg/common/config/config.go-	S3          aws.S3Config          `mapstructure:"s3"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// EmbeddingConfig contains configuration for the embedding system
./pkg/common/config/config.go:type EmbeddingConfig struct {
./pkg/common/config/config.go-	Providers ProvidersConfig `mapstructure:"providers"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// ProvidersConfig contains configuration for embedding providers
./pkg/common/config/config.go:type ProvidersConfig struct {
./pkg/common/config/config.go-	OpenAI  OpenAIConfig  `mapstructure:"openai"`
./pkg/common/config/config.go-	Bedrock BedrockConfig `mapstructure:"bedrock"`
./pkg/common/config/config.go-	Google  GoogleConfig  `mapstructure:"google"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// OpenAIConfig contains OpenAI provider configuration
./pkg/common/config/config.go:type OpenAIConfig struct {
./pkg/common/config/config.go-	Enabled bool   `mapstructure:"enabled"`
./pkg/common/config/config.go-	APIKey  string `mapstructure:"api_key"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// BedrockConfig contains AWS Bedrock provider configuration
./pkg/common/config/config.go:type BedrockConfig struct {
./pkg/common/config/config.go-	Enabled  bool   `mapstructure:"enabled"`
./pkg/common/config/config.go-	Region   string `mapstructure:"region"`
./pkg/common/config/config.go-	Endpoint string `mapstructure:"endpoint"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// GoogleConfig contains Google provider configuration
./pkg/common/config/config.go:type GoogleConfig struct {
./pkg/common/config/config.go-	Enabled  bool   `mapstructure:"enabled"`
./pkg/common/config/config.go-	APIKey   string `mapstructure:"api_key"`
./pkg/common/config/config.go-	Endpoint string `mapstructure:"endpoint"`
./pkg/common/config/config.go-}
./pkg/common/config/config.go-
./pkg/common/config/config.go-// Load loads configuration from file and environment variables
./pkg/common/config/config.go-func Load() (*Config, error) {
./pkg/common/config/config.go-	// Initialize configuration
./pkg/common/config/config.go-	v := viper.New()
./pkg/common/config/config.go-
./pkg/common/config/config.go-	// Set defaults
./pkg/common/config/config.go-	setDefaults(v)
./pkg/common/config/config.go-
./pkg/common/config/config.go-	// Read from config file
./pkg/common/config/config.go-	configFile := os.Getenv("MCP_CONFIG_FILE")
./pkg/common/config/config.go-	if configFile == "" {
./pkg/common/config/config.go-		configFile = "configs/config.yaml"
./pkg/common/config/config.go-	}
./pkg/common/config/config.go-
./pkg/common/config/config.go-	v.SetConfigFile(configFile)
./pkg/common/config/config.go-
./pkg/common/config/config.go-	// Read from environment variables prefixed with MCP_
./pkg/common/config/config.go-	v.SetEnvPrefix("MCP")
./pkg/common/config/config.go-	v.SetEnvKeyReplacer(strings.NewReplacer(".", "_"))
./pkg/common/config/config.go-	v.AutomaticEnv()
./pkg/common/config/config.go-
./pkg/common/config/config.go-	// Bind specific environment variables that don't follow the MCP_ prefix
./pkg/common/config/config.go-	// These are commonly used in Docker environments
./pkg/common/config/config.go-	_ = v.BindEnv("cache.address", "REDIS_ADDR")    // Best effort - viper handles errors internally
./pkg/common/config/config.go-	_ = v.BindEnv("cache.address", "REDIS_ADDRESS") // Best effort - viper handles errors internally
./pkg/common/config/config.go-	_ = v.BindEnv("cache.address", "CACHE_ADDRESS") // Best effort - viper handles errors internally
./pkg/common/config/config.go-
./pkg/common/config/config.go-	// Bind database environment variables used by Docker
./pkg/common/config/config.go-	_ = v.BindEnv("database.host", "DATABASE_HOST")
./pkg/common/config/config.go-	_ = v.BindEnv("database.port", "DATABASE_PORT")
./pkg/common/config/config.go-	_ = v.BindEnv("database.database", "DATABASE_NAME")
./pkg/common/config/config.go-	_ = v.BindEnv("database.username", "DATABASE_USER")
./pkg/common/config/config.go-	_ = v.BindEnv("database.password", "DATABASE_PASSWORD")
./pkg/common/config/config.go-	_ = v.BindEnv("database.ssl_mode", "DATABASE_SSL_MODE")
./pkg/common/config/config.go-	_ = v.BindEnv("database.dsn", "DATABASE_DSN")
./pkg/common/config/config.go-
./pkg/common/config/config.go-	// Enable environment variable interpolation in config values
./pkg/common/config/config.go-	v.AllowEmptyEnv(true)
./pkg/common/config/config.go-
./pkg/common/config/config.go-	// Read config
./pkg/common/config/config.go-	if err := v.ReadInConfig(); err != nil {
./pkg/common/config/config.go-		// Config file is not required if environment variables are set
./pkg/common/config/config.go-		if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
./pkg/common/config/config.go-			return nil, fmt.Errorf("error reading config file: %w", err)
./pkg/common/config/config.go-		}
--
./pkg/common/config/rds_config.go:type RDSConfig struct {
./pkg/common/config/rds_config.go-	Host              string        `mapstructure:"host"`
./pkg/common/config/rds_config.go-	Port              int           `mapstructure:"port"`
./pkg/common/config/rds_config.go-	Database          string        `mapstructure:"database"`
./pkg/common/config/rds_config.go-	Username          string        `mapstructure:"username"`
./pkg/common/config/rds_config.go-	Password          string        `mapstructure:"password"`
./pkg/common/config/rds_config.go-	UseIAMAuth        bool          `mapstructure:"use_iam_auth"`
./pkg/common/config/rds_config.go-	TokenExpiration   int           `mapstructure:"token_expiration"`
./pkg/common/config/rds_config.go-	MaxOpenConns      int           `mapstructure:"max_open_conns"`
./pkg/common/config/rds_config.go-	MaxIdleConns      int           `mapstructure:"max_idle_conns"`
./pkg/common/config/rds_config.go-	ConnMaxLifetime   time.Duration `mapstructure:"conn_max_lifetime"`
./pkg/common/config/rds_config.go-	EnablePooling     bool          `mapstructure:"enable_pooling"`
./pkg/common/config/rds_config.go-	MinPoolSize       int           `mapstructure:"min_pool_size"`
./pkg/common/config/rds_config.go-	MaxPoolSize       int           `mapstructure:"max_pool_size"`
./pkg/common/config/rds_config.go-	ConnectionTimeout int           `mapstructure:"connection_timeout"`
./pkg/common/config/rds_config.go-	AuthConfig        struct {
./pkg/common/config/rds_config.go-		Region     string `mapstructure:"region"`
./pkg/common/config/rds_config.go-		Endpoint   string `mapstructure:"endpoint"`
./pkg/common/config/rds_config.go-		AssumeRole string `mapstructure:"assume_role"`
./pkg/common/config/rds_config.go-	} `mapstructure:"auth"`
./pkg/common/config/rds_config.go-}
./pkg/common/config/rds_config.go-
./pkg/common/config/rds_config.go-// GetDefaultRDSConfig returns default RDS configuration
./pkg/common/config/rds_config.go-func GetDefaultRDSConfig() *RDSConfig {
./pkg/common/config/rds_config.go-	return &RDSConfig{
./pkg/common/config/rds_config.go-		Host:              "localhost",
./pkg/common/config/rds_config.go-		Port:              5432,
./pkg/common/config/rds_config.go-		Database:          "mcp",
./pkg/common/config/rds_config.go-		Username:          "postgres",
./pkg/common/config/rds_config.go-		Password:          "",
./pkg/common/config/rds_config.go-		UseIAMAuth:        false,
./pkg/common/config/rds_config.go-		TokenExpiration:   900,
./pkg/common/config/rds_config.go-		MaxOpenConns:      25,
./pkg/common/config/rds_config.go-		MaxIdleConns:      5,
./pkg/common/config/rds_config.go-		ConnMaxLifetime:   5 * time.Minute,
./pkg/common/config/rds_config.go-		EnablePooling:     false,
./pkg/common/config/rds_config.go-		MinPoolSize:       5,
./pkg/common/config/rds_config.go-		MaxPoolSize:       25,
./pkg/common/config/rds_config.go-		ConnectionTimeout: 10,
./pkg/common/config/rds_config.go-		AuthConfig: struct {
./pkg/common/config/rds_config.go-			Region     string `mapstructure:"region"`
./pkg/common/config/rds_config.go-			Endpoint   string `mapstructure:"endpoint"`
./pkg/common/config/rds_config.go-			AssumeRole string `mapstructure:"assume_role"`
./pkg/common/config/rds_config.go-		}{
./pkg/common/config/rds_config.go-			Region:     "us-west-2",
./pkg/common/config/rds_config.go-			Endpoint:   "",
./pkg/common/config/rds_config.go-			AssumeRole: "",
./pkg/common/config/rds_config.go-		},
./pkg/common/config/rds_config.go-	}
./pkg/common/config/rds_config.go-}
--
./pkg/common/config/monitoring_config.go:type MonitoringConfig struct {
./pkg/common/config/monitoring_config.go-	Prometheus PrometheusConfig `yaml:"prometheus"`
./pkg/common/config/monitoring_config.go-	Logging    LoggingConfig    `yaml:"logging"`
./pkg/common/config/monitoring_config.go-}
./pkg/common/config/monitoring_config.go-
./pkg/common/config/monitoring_config.go-// PrometheusConfig holds Prometheus configuration
./pkg/common/config/monitoring_config.go:type PrometheusConfig struct {
./pkg/common/config/monitoring_config.go-	Enabled       bool                `yaml:"enabled"`
./pkg/common/config/monitoring_config.go-	Path          string              `yaml:"path"`
./pkg/common/config/monitoring_config.go-	VectorMetrics VectorMetricsConfig `yaml:"vector_metrics"`
./pkg/common/config/monitoring_config.go-}
./pkg/common/config/monitoring_config.go-
./pkg/common/config/monitoring_config.go-// VectorMetricsConfig holds configuration for vector-specific metrics
./pkg/common/config/monitoring_config.go:type VectorMetricsConfig struct {
./pkg/common/config/monitoring_config.go-	Enabled           bool      `yaml:"enabled"`
./pkg/common/config/monitoring_config.go-	CollectHistograms bool      `yaml:"collect_histograms"`
./pkg/common/config/monitoring_config.go-	Percentiles       []float64 `yaml:"percentiles"`
./pkg/common/config/monitoring_config.go-}
./pkg/common/config/monitoring_config.go-
./pkg/common/config/monitoring_config.go-// LoggingConfig holds logging configuration
./pkg/common/config/monitoring_config.go:type LoggingConfig struct {
./pkg/common/config/monitoring_config.go-	Level    string `yaml:"level"`
./pkg/common/config/monitoring_config.go-	Format   string `yaml:"format"`
./pkg/common/config/monitoring_config.go-	Output   string `yaml:"output"`
./pkg/common/config/monitoring_config.go-	FilePath string `yaml:"file_path"`
./pkg/common/config/monitoring_config.go-}
./pkg/common/config/monitoring_config.go-
./pkg/common/config/monitoring_config.go-// GetDefaultMonitoringConfig returns default monitoring configuration
./pkg/common/config/monitoring_config.go-func GetDefaultMonitoringConfig() MonitoringConfig {
./pkg/common/config/monitoring_config.go-	return MonitoringConfig{
./pkg/common/config/monitoring_config.go-		Prometheus: PrometheusConfig{
./pkg/common/config/monitoring_config.go-			Enabled: true,
./pkg/common/config/monitoring_config.go-			Path:    "/metrics",
./pkg/common/config/monitoring_config.go-			VectorMetrics: VectorMetricsConfig{
./pkg/common/config/monitoring_config.go-				Enabled:           true,
./pkg/common/config/monitoring_config.go-				CollectHistograms: true,
./pkg/common/config/monitoring_config.go-				Percentiles:       []float64{0.5, 0.9, 0.95, 0.99},
./pkg/common/config/monitoring_config.go-			},
./pkg/common/config/monitoring_config.go-		},
./pkg/common/config/monitoring_config.go-		Logging: LoggingConfig{
./pkg/common/config/monitoring_config.go-			Level:  "info",
./pkg/common/config/monitoring_config.go-			Format: "json",
./pkg/common/config/monitoring_config.go-			Output: "stdout",
./pkg/common/config/monitoring_config.go-		},
./pkg/common/config/monitoring_config.go-	}
./pkg/common/config/monitoring_config.go-}
--
./pkg/common/config/webhook_config.go:type WebhookConfig struct {
./pkg/common/config/webhook_config.go-	enabled             bool
./pkg/common/config/webhook_config.go-	githubSecret        string
./pkg/common/config/webhook_config.go-	githubEndpoint      string
./pkg/common/config/webhook_config.go-	githubIPValidation  bool
./pkg/common/config/webhook_config.go-	githubAllowedEvents []string
./pkg/common/config/webhook_config.go-}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-// Enabled returns whether webhooks are enabled
./pkg/common/config/webhook_config.go-func (c *WebhookConfig) Enabled() bool {
./pkg/common/config/webhook_config.go-	return c.enabled
./pkg/common/config/webhook_config.go-}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-// GitHubSecret returns the GitHub webhook secret
./pkg/common/config/webhook_config.go-func (c *WebhookConfig) GitHubSecret() string {
./pkg/common/config/webhook_config.go-	return c.githubSecret
./pkg/common/config/webhook_config.go-}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-// GitHubEndpoint returns the GitHub webhook endpoint path
./pkg/common/config/webhook_config.go-func (c *WebhookConfig) GitHubEndpoint() string {
./pkg/common/config/webhook_config.go-	return c.githubEndpoint
./pkg/common/config/webhook_config.go-}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-// GitHubIPValidationEnabled returns whether GitHub IP validation is enabled
./pkg/common/config/webhook_config.go-func (c *WebhookConfig) GitHubIPValidationEnabled() bool {
./pkg/common/config/webhook_config.go-	return c.githubIPValidation
./pkg/common/config/webhook_config.go-}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-// GitHubAllowedEvents returns the list of allowed GitHub event types
./pkg/common/config/webhook_config.go-func (c *WebhookConfig) GitHubAllowedEvents() []string {
./pkg/common/config/webhook_config.go-	return c.githubAllowedEvents
./pkg/common/config/webhook_config.go-}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-// NewWebhookConfig creates a new WebhookConfig with default values
./pkg/common/config/webhook_config.go-func NewWebhookConfig() *WebhookConfig {
./pkg/common/config/webhook_config.go-	// Default configuration
./pkg/common/config/webhook_config.go-	config := &WebhookConfig{
./pkg/common/config/webhook_config.go-		enabled:             false,
./pkg/common/config/webhook_config.go-		githubEndpoint:      "/api/webhooks/github",
./pkg/common/config/webhook_config.go-		githubIPValidation:  true,
./pkg/common/config/webhook_config.go-		githubAllowedEvents: []string{"push", "pull_request", "issues", "issue_comment", "release"},
./pkg/common/config/webhook_config.go-	}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-	// Load from environment variables
./pkg/common/config/webhook_config.go-	if val := os.Getenv("MCP_WEBHOOK_ENABLED"); val == "true" {
./pkg/common/config/webhook_config.go-		config.enabled = true
./pkg/common/config/webhook_config.go-	}
./pkg/common/config/webhook_config.go-
./pkg/common/config/webhook_config.go-	if val := os.Getenv("MCP_GITHUB_WEBHOOK_SECRET"); val != "" {
./pkg/common/config/webhook_config.go-		config.githubSecret = val
./pkg/common/config/webhook_config.go-		// Only enable GitHub webhook if a secret is provided
--
./pkg/common/observability/tracing.go:type TracingConfig struct {
./pkg/common/observability/tracing.go-	Enabled     bool   `mapstructure:"enabled"`
./pkg/common/observability/tracing.go-	ServiceName string `mapstructure:"service_name"`
./pkg/common/observability/tracing.go-	Environment string `mapstructure:"environment"`
./pkg/common/observability/tracing.go-	Endpoint    string `mapstructure:"endpoint"`
./pkg/common/observability/tracing.go-}
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-var (
./pkg/common/observability/tracing.go-	tracer          trace.Tracer
./pkg/common/observability/tracing.go-	tracerInit      bool
./pkg/common/observability/tracing.go-	tracingWarnOnce sync.Once
./pkg/common/observability/tracing.go-)
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-// InitTracing initializes OpenTelemetry tracing
./pkg/common/observability/tracing.go-func InitTracing(cfg TracingConfig) (func(), error) {
./pkg/common/observability/tracing.go-	if !cfg.Enabled {
./pkg/common/observability/tracing.go-		log.Println("Tracing is disabled")
./pkg/common/observability/tracing.go-		tracerInit = false
./pkg/common/observability/tracing.go-		return func() {}, nil
./pkg/common/observability/tracing.go-	}
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-	if cfg.ServiceName == "" {
./pkg/common/observability/tracing.go-		cfg.ServiceName = "mcp-server"
./pkg/common/observability/tracing.go-	}
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-	if cfg.Environment == "" {
./pkg/common/observability/tracing.go-		cfg.Environment = "development"
./pkg/common/observability/tracing.go-	}
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-	if cfg.Endpoint == "" {
./pkg/common/observability/tracing.go-		cfg.Endpoint = "localhost:4317"
./pkg/common/observability/tracing.go-	}
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-	ctx := context.Background()
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-	// Create OTLP exporter with endpoint
./pkg/common/observability/tracing.go-	traceExporter, err := otlptracegrpc.New(ctx,
./pkg/common/observability/tracing.go-		otlptracegrpc.WithEndpoint(cfg.Endpoint),
./pkg/common/observability/tracing.go-		otlptracegrpc.WithInsecure(),
./pkg/common/observability/tracing.go-	)
./pkg/common/observability/tracing.go-	if err != nil {
./pkg/common/observability/tracing.go-		return nil, fmt.Errorf("failed to create trace exporter: %w", err)
./pkg/common/observability/tracing.go-	}
./pkg/common/observability/tracing.go-
./pkg/common/observability/tracing.go-	// Create resource with service information
./pkg/common/observability/tracing.go-	res, err := resource.New(ctx,
./pkg/common/observability/tracing.go-		resource.WithAttributes(
./pkg/common/observability/tracing.go-			attribute.String("service.name", cfg.ServiceName),
./pkg/common/observability/tracing.go-			attribute.String("environment", cfg.Environment),
./pkg/common/observability/tracing.go-		),
./pkg/common/observability/tracing.go-	)
--
./pkg/common/aws/rds.go:type RDSConnectionConfig struct {
./pkg/common/aws/rds.go-	Host              string        `mapstructure:"host"`
./pkg/common/aws/rds.go-	Port              int           `mapstructure:"port"`
./pkg/common/aws/rds.go-	Database          string        `mapstructure:"database"`
./pkg/common/aws/rds.go-	Username          string        `mapstructure:"username"`
./pkg/common/aws/rds.go-	Password          string        `mapstructure:"password"`
./pkg/common/aws/rds.go-	UseIAMAuth        bool          `mapstructure:"use_iam_auth"`
./pkg/common/aws/rds.go-	TokenExpiration   int           `mapstructure:"token_expiration"`
./pkg/common/aws/rds.go-	MaxOpenConns      int           `mapstructure:"max_open_conns"`
./pkg/common/aws/rds.go-	MaxIdleConns      int           `mapstructure:"max_idle_conns"`
./pkg/common/aws/rds.go-	ConnMaxLifetime   time.Duration `mapstructure:"conn_max_lifetime"`
./pkg/common/aws/rds.go-	EnablePooling     bool          `mapstructure:"enable_pooling"`
./pkg/common/aws/rds.go-	MinPoolSize       int           `mapstructure:"min_pool_size"`
./pkg/common/aws/rds.go-	MaxPoolSize       int           `mapstructure:"max_pool_size"`
./pkg/common/aws/rds.go-	ConnectionTimeout int           `mapstructure:"connection_timeout"`
./pkg/common/aws/rds.go-	Auth              AuthConfig    `mapstructure:"auth"`
./pkg/common/aws/rds.go-}
./pkg/common/aws/rds.go-
./pkg/common/aws/rds.go-// RDSClientInterface defines the interface for RDS operations
./pkg/common/aws/rds.go-type RDSClientInterface interface {
./pkg/common/aws/rds.go-	GetAuthToken(ctx context.Context) (string, error)
./pkg/common/aws/rds.go-	BuildPostgresConnectionString(ctx context.Context) (string, error)
./pkg/common/aws/rds.go-	DescribeDBInstances(ctx context.Context, instanceIdentifier string) (*rds.DescribeDBInstancesOutput, error)
./pkg/common/aws/rds.go-}
./pkg/common/aws/rds.go-
./pkg/common/aws/rds.go-// ExtendedRDSClient extends the basic RDSClient with additional methods
./pkg/common/aws/rds.go-type ExtendedRDSClient struct {
./pkg/common/aws/rds.go-	awsConfig  aws.Config
./pkg/common/aws/rds.go-	connConfig RDSConnectionConfig
./pkg/common/aws/rds.go-	rdsClient  *rds.Client
./pkg/common/aws/rds.go-}
./pkg/common/aws/rds.go-
./pkg/common/aws/rds.go-// NewExtendedRDSClient creates a new extended RDS client with both connection and AWS config
./pkg/common/aws/rds.go-func NewExtendedRDSClient(ctx context.Context, connCfg RDSConnectionConfig) (*ExtendedRDSClient, error) {
./pkg/common/aws/rds.go-	// Get AWS config
./pkg/common/aws/rds.go-	var awsConfig aws.Config
./pkg/common/aws/rds.go-
./pkg/common/aws/rds.go-	// Always use IAM authentication if enabled
./pkg/common/aws/rds.go-	if connCfg.UseIAMAuth {
./pkg/common/aws/rds.go-		var err error
./pkg/common/aws/rds.go-		awsConfig, err = GetAWSConfig(ctx, connCfg.Auth)
./pkg/common/aws/rds.go-		if err != nil {
./pkg/common/aws/rds.go-			return nil, fmt.Errorf("failed to load AWS config with IAM auth: %w", err)
./pkg/common/aws/rds.go-		}
./pkg/common/aws/rds.go-	}
./pkg/common/aws/rds.go-
./pkg/common/aws/rds.go-	// Create RDS client
./pkg/common/aws/rds.go-	// For IAM auth we already have the AWS config, for non-IAM we'll set up a default client later
./pkg/common/aws/rds.go-	var rdsClient *rds.Client
./pkg/common/aws/rds.go-	if connCfg.UseIAMAuth {
./pkg/common/aws/rds.go-		rdsClient = rds.NewFromConfig(awsConfig)
--
./pkg/common/aws/elasticache.go:type ElastiCacheConfig struct {
./pkg/common/aws/elasticache.go-	AuthConfig         AuthConfig          `mapstructure:"auth"`
./pkg/common/aws/elasticache.go-	PrimaryEndpoint    string              `mapstructure:"primary_endpoint"`
./pkg/common/aws/elasticache.go-	Port               int                 `mapstructure:"port"`
./pkg/common/aws/elasticache.go-	Username           string              `mapstructure:"username"` // For Redis auth
./pkg/common/aws/elasticache.go-	Password           string              `mapstructure:"password"` // For Redis auth
./pkg/common/aws/elasticache.go-	UseIAMAuth         bool                `mapstructure:"use_iam_auth"`
./pkg/common/aws/elasticache.go-	ClusterMode        bool                `mapstructure:"cluster_mode"`
./pkg/common/aws/elasticache.go-	ReaderEndpoint     string              `mapstructure:"reader_endpoint"`   // Used for cluster mode
./pkg/common/aws/elasticache.go-	CacheNodes         []string            `mapstructure:"cache_nodes"`       // List of nodes for cluster mode
./pkg/common/aws/elasticache.go-	ClusterDiscovery   bool                `mapstructure:"cluster_discovery"` // Use API to discover nodes
./pkg/common/aws/elasticache.go-	ClusterName        string              `mapstructure:"cluster_name"`
./pkg/common/aws/elasticache.go-	TLS                *securitytls.Config `mapstructure:"tls"` // TLS configuration
./pkg/common/aws/elasticache.go-	MaxRetries         int                 `mapstructure:"max_retries"`
./pkg/common/aws/elasticache.go-	MinIdleConnections int                 `mapstructure:"min_idle_connections"`
./pkg/common/aws/elasticache.go-	PoolSize           int                 `mapstructure:"pool_size"`
./pkg/common/aws/elasticache.go-	DialTimeout        time.Duration       `mapstructure:"dial_timeout"`
./pkg/common/aws/elasticache.go-	ReadTimeout        time.Duration       `mapstructure:"read_timeout"`
./pkg/common/aws/elasticache.go-	WriteTimeout       time.Duration       `mapstructure:"write_timeout"`
./pkg/common/aws/elasticache.go-	PoolTimeout        int                 `mapstructure:"pool_timeout"`
./pkg/common/aws/elasticache.go-	TokenExpiration    int                 `mapstructure:"token_expiration"`
./pkg/common/aws/elasticache.go-}
./pkg/common/aws/elasticache.go-
./pkg/common/aws/elasticache.go-// ElastiCacheClient is a client for AWS ElastiCache
./pkg/common/aws/elasticache.go-type ElastiCacheClient struct {
./pkg/common/aws/elasticache.go-	config ElastiCacheConfig
./pkg/common/aws/elasticache.go-}
./pkg/common/aws/elasticache.go-
./pkg/common/aws/elasticache.go-// NewElastiCacheClient creates a new ElastiCache client
./pkg/common/aws/elasticache.go-func NewElastiCacheClient(ctx context.Context, cfg ElastiCacheConfig) (*ElastiCacheClient, error) {
./pkg/common/aws/elasticache.go-	// Always use IAM authentication if enabled, and pass AssumeRole if set
./pkg/common/aws/elasticache.go-	if cfg.UseIAMAuth {
./pkg/common/aws/elasticache.go-		_, err := GetAWSConfig(ctx, cfg.AuthConfig)
./pkg/common/aws/elasticache.go-		if err != nil {
./pkg/common/aws/elasticache.go-			return nil, fmt.Errorf("failed to load AWS config with IAM auth: %w", err)
./pkg/common/aws/elasticache.go-		}
./pkg/common/aws/elasticache.go-	}
./pkg/common/aws/elasticache.go-	return &ElastiCacheClient{
./pkg/common/aws/elasticache.go-		config: cfg,
./pkg/common/aws/elasticache.go-	}, nil
./pkg/common/aws/elasticache.go-}
./pkg/common/aws/elasticache.go-
./pkg/common/aws/elasticache.go-// GetAuthToken generates a temporary IAM auth token for ElastiCache
./pkg/common/aws/elasticache.go-// To implement IAM auth for ElastiCache in production, you'll need to:
./pkg/common/aws/elasticache.go-// 1. Import the AWS SDK ElastiCache package: github.com/aws/aws-sdk-go-v2/service/elasticache
./pkg/common/aws/elasticache.go-// 2. Use the API to generate or authenticate with IAM
./pkg/common/aws/elasticache.go-func (c *ElastiCacheClient) GetAuthToken(ctx context.Context) (string, error) {
./pkg/common/aws/elasticache.go-	// For testing in local development environments
./pkg/common/aws/elasticache.go-	if c.config.PrimaryEndpoint == "localhost" || c.config.PrimaryEndpoint == "127.0.0.1" ||
./pkg/common/aws/elasticache.go-		c.config.PrimaryEndpoint == "redis" || c.config.PrimaryEndpoint == "" ||
./pkg/common/aws/elasticache.go-		strings.HasPrefix(c.config.PrimaryEndpoint, "host.docker.internal") {
--
./pkg/common/aws/auth.go:type AuthConfig struct {
./pkg/common/aws/auth.go-	Region     string `mapstructure:"region"`
./pkg/common/aws/auth.go-	Endpoint   string `mapstructure:"endpoint"`
./pkg/common/aws/auth.go-	AssumeRole string `mapstructure:"assume_role"`
./pkg/common/aws/auth.go-}
./pkg/common/aws/auth.go-
./pkg/common/aws/auth.go-// GetAWSConfig creates an AWS SDK configuration with IRSA support
./pkg/common/aws/auth.go-// If AssumeRole is set, it will use STS to assume the specified role and return a config with temporary credentials
./pkg/common/aws/auth.go-func GetAWSConfig(ctx context.Context, cfg AuthConfig) (aws.Config, error) {
./pkg/common/aws/auth.go-	// Create the AWS config options
./pkg/common/aws/auth.go-	options := []func(*config.LoadOptions) error{
./pkg/common/aws/auth.go-		config.WithRegion(cfg.Region),
./pkg/common/aws/auth.go-	}
./pkg/common/aws/auth.go-
./pkg/common/aws/auth.go-	// Add custom endpoint if specified (for local development or testing)
./pkg/common/aws/auth.go-	// Note: With AWS SDK v2, endpoints should be configured per-service client
./pkg/common/aws/auth.go-	// This will be handled when creating service clients
./pkg/common/aws/auth.go-
./pkg/common/aws/auth.go-	// Check if running in a Kubernetes pod with a service account
./pkg/common/aws/auth.go-	// The AWS SDK automatically detects and uses IRSA if the required environment variables are set
./pkg/common/aws/auth.go-	// These environment variables are set automatically by the EKS Pod Identity Agent
./pkg/common/aws/auth.go-	_, hasWebIdentityTokenFile := os.LookupEnv("AWS_WEB_IDENTITY_TOKEN_FILE")
./pkg/common/aws/auth.go-	_, hasRoleArn := os.LookupEnv("AWS_ROLE_ARN")
./pkg/common/aws/auth.go-
./pkg/common/aws/auth.go-	if hasWebIdentityTokenFile && hasRoleArn {
./pkg/common/aws/auth.go-		log.Println("Using IRSA authentication for AWS services")
./pkg/common/aws/auth.go-	} else {
./pkg/common/aws/auth.go-		log.Println("Using standard AWS credential provider chain")
./pkg/common/aws/auth.go-	}
./pkg/common/aws/auth.go-
./pkg/common/aws/auth.go-	// If AssumeRole is set, use STS to assume the role and inject credentials
./pkg/common/aws/auth.go-	if cfg.AssumeRole != "" {
./pkg/common/aws/auth.go-		log.Printf("Assuming IAM role: %s", cfg.AssumeRole)
./pkg/common/aws/auth.go-		awsCfg, err := config.LoadDefaultConfig(ctx, options...)
./pkg/common/aws/auth.go-		if err != nil {
./pkg/common/aws/auth.go-			return aws.Config{}, err
./pkg/common/aws/auth.go-		}
./pkg/common/aws/auth.go-		stsClient := sts.NewFromConfig(awsCfg)
./pkg/common/aws/auth.go-		creds := stscreds.NewAssumeRoleProvider(stsClient, cfg.AssumeRole)
./pkg/common/aws/auth.go-		awsCfg.Credentials = aws.NewCredentialsCache(creds)
./pkg/common/aws/auth.go-		return awsCfg, nil
./pkg/common/aws/auth.go-	}
./pkg/common/aws/auth.go-	// Load the AWS configuration (default provider chain, no assume role)
./pkg/common/aws/auth.go-	awsCfg, err := config.LoadDefaultConfig(ctx, options...)
./pkg/common/aws/auth.go-	if err != nil {
./pkg/common/aws/auth.go-		return aws.Config{}, err
./pkg/common/aws/auth.go-	}
./pkg/common/aws/auth.go-
./pkg/common/aws/auth.go-	// Store the endpoint in the config context for service clients to use
./pkg/common/aws/auth.go-	if cfg.Endpoint != "" {
./pkg/common/aws/auth.go-		awsCfg.BaseEndpoint = aws.String(cfg.Endpoint)
--
./pkg/common/aws/client.go:type LegacyAuthConfig struct {
./pkg/common/aws/client.go-	Region          string
./pkg/common/aws/client.go-	AccessKeyID     string
./pkg/common/aws/client.go-	SecretAccessKey string
./pkg/common/aws/client.go-	SessionToken    string
./pkg/common/aws/client.go-	Profile         string
./pkg/common/aws/client.go-	Endpoint        string
./pkg/common/aws/client.go-}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-// RDSConfig holds configuration for RDS
./pkg/common/aws/client.go:type RDSConfig struct {
./pkg/common/aws/client.go-	Region     string
./pkg/common/aws/client.go-	SecretName string
./pkg/common/aws/client.go-}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-// RDSClient is a client for AWS RDS
./pkg/common/aws/client.go-type RDSClient struct {
./pkg/common/aws/client.go-	Config *aws.Config
./pkg/common/aws/client.go-}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-// StandardAWSClient implements the AWSClient interface with standard AWS functionality
./pkg/common/aws/client.go-type StandardAWSClient struct {
./pkg/common/aws/client.go-	ctx       context.Context
./pkg/common/aws/client.go-	awsConfig *aws.Config
./pkg/common/aws/client.go-	region    string
./pkg/common/aws/client.go-	session   any
./pkg/common/aws/client.go-	s3Client  *s3.Client
./pkg/common/aws/client.go-	sqsClient *sqs.Client
./pkg/common/aws/client.go-}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-// NewAWSClient creates a new AWS client with the provided config
./pkg/common/aws/client.go-func NewAWSClient(ctx context.Context, cfg *aws.Config) AWSClient {
./pkg/common/aws/client.go-	region := os.Getenv("AWS_REGION")
./pkg/common/aws/client.go-	if region == "" {
./pkg/common/aws/client.go-		region = "us-west-2" // Default region
./pkg/common/aws/client.go-	}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-	return &StandardAWSClient{
./pkg/common/aws/client.go-		ctx:       ctx,
./pkg/common/aws/client.go-		awsConfig: cfg,
./pkg/common/aws/client.go-		region:    region,
./pkg/common/aws/client.go-	}
./pkg/common/aws/client.go-}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-// GetSession returns the AWS session
./pkg/common/aws/client.go-func (c *StandardAWSClient) GetSession() any {
./pkg/common/aws/client.go-	return c.session
./pkg/common/aws/client.go-}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-// GetCredentials returns the AWS credentials
./pkg/common/aws/client.go-func (c *StandardAWSClient) GetCredentials() any {
./pkg/common/aws/client.go-	if c.awsConfig == nil {
./pkg/common/aws/client.go-		return nil
./pkg/common/aws/client.go-	}
./pkg/common/aws/client.go-	return c.awsConfig.Credentials
./pkg/common/aws/client.go-}
./pkg/common/aws/client.go-
./pkg/common/aws/client.go-// GetRegion returns the AWS region
./pkg/common/aws/client.go-func (c *StandardAWSClient) GetRegion() string {
./pkg/common/aws/client.go-	return c.region
./pkg/common/aws/client.go-}
--
./pkg/common/logging/tracing.go:type TracingConfig struct {
./pkg/common/logging/tracing.go-	Enabled     bool   `mapstructure:"enabled"`
./pkg/common/logging/tracing.go-	ServiceName string `mapstructure:"service_name"`
./pkg/common/logging/tracing.go-	Environment string `mapstructure:"environment"`
./pkg/common/logging/tracing.go-	Endpoint    string `mapstructure:"endpoint"`
./pkg/common/logging/tracing.go-}
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-var (
./pkg/common/logging/tracing.go-	tracer          trace.Tracer
./pkg/common/logging/tracing.go-	tracerInit      bool
./pkg/common/logging/tracing.go-	tracingWarnOnce sync.Once
./pkg/common/logging/tracing.go-)
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-// InitTracing initializes OpenTelemetry tracing
./pkg/common/logging/tracing.go-func InitTracing(cfg TracingConfig) (func(), error) {
./pkg/common/logging/tracing.go-	if !cfg.Enabled {
./pkg/common/logging/tracing.go-		log.Println("Tracing is disabled")
./pkg/common/logging/tracing.go-		tracerInit = false
./pkg/common/logging/tracing.go-		return func() {}, nil
./pkg/common/logging/tracing.go-	}
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-	if cfg.ServiceName == "" {
./pkg/common/logging/tracing.go-		cfg.ServiceName = "mcp-server"
./pkg/common/logging/tracing.go-	}
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-	if cfg.Environment == "" {
./pkg/common/logging/tracing.go-		cfg.Environment = "development"
./pkg/common/logging/tracing.go-	}
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-	if cfg.Endpoint == "" {
./pkg/common/logging/tracing.go-		cfg.Endpoint = "localhost:4317"
./pkg/common/logging/tracing.go-	}
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-	ctx := context.Background()
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-	// Create OTLP exporter with endpoint
./pkg/common/logging/tracing.go-	traceExporter, err := otlptracegrpc.New(ctx,
./pkg/common/logging/tracing.go-		otlptracegrpc.WithEndpoint(cfg.Endpoint),
./pkg/common/logging/tracing.go-		otlptracegrpc.WithInsecure(),
./pkg/common/logging/tracing.go-	)
./pkg/common/logging/tracing.go-	if err != nil {
./pkg/common/logging/tracing.go-		return nil, fmt.Errorf("failed to create trace exporter: %w", err)
./pkg/common/logging/tracing.go-	}
./pkg/common/logging/tracing.go-
./pkg/common/logging/tracing.go-	// Create resource with service information
./pkg/common/logging/tracing.go-	res, err := resource.New(ctx,
./pkg/common/logging/tracing.go-		resource.WithAttributes(
./pkg/common/logging/tracing.go-			semconv.ServiceNameKey.String(cfg.ServiceName),
./pkg/common/logging/tracing.go-			attribute.String("environment", cfg.Environment),
./pkg/common/logging/tracing.go-		),
./pkg/common/logging/tracing.go-	)
--
./pkg/resilience/rate_limiter.go:type RateLimiterConfig struct {
./pkg/resilience/rate_limiter.go-	Limit       int           // Maximum requests per period
./pkg/resilience/rate_limiter.go-	Period      time.Duration // Time period for the limit
./pkg/resilience/rate_limiter.go-	BurstFactor int           // Burst factor (multiplier for limit for short bursts)
./pkg/resilience/rate_limiter.go-}
./pkg/resilience/rate_limiter.go-
./pkg/resilience/rate_limiter.go-// RateLimiter implements a token bucket rate limiter
./pkg/resilience/rate_limiter.go-type RateLimiter struct {
./pkg/resilience/rate_limiter.go-	name       string
./pkg/resilience/rate_limiter.go-	config     RateLimiterConfig
./pkg/resilience/rate_limiter.go-	tokens     int
./pkg/resilience/rate_limiter.go-	lastRefill time.Time
./pkg/resilience/rate_limiter.go-	mutex      sync.Mutex
./pkg/resilience/rate_limiter.go-}
./pkg/resilience/rate_limiter.go-
./pkg/resilience/rate_limiter.go-// NewRateLimiter creates a new rate limiter with the given configuration
./pkg/resilience/rate_limiter.go-func NewRateLimiter(name string, config RateLimiterConfig) *RateLimiter {
./pkg/resilience/rate_limiter.go-	return &RateLimiter{
./pkg/resilience/rate_limiter.go-		name:       name,
./pkg/resilience/rate_limiter.go-		config:     config,
./pkg/resilience/rate_limiter.go-		tokens:     config.Limit,
./pkg/resilience/rate_limiter.go-		lastRefill: time.Now(),
./pkg/resilience/rate_limiter.go-	}
./pkg/resilience/rate_limiter.go-}
./pkg/resilience/rate_limiter.go-
./pkg/resilience/rate_limiter.go-// RateLimiterManager manages multiple rate limiters
./pkg/resilience/rate_limiter.go-type RateLimiterManager struct {
./pkg/resilience/rate_limiter.go-	limiters map[string]*RateLimiter
./pkg/resilience/rate_limiter.go-	mutex    sync.RWMutex
./pkg/resilience/rate_limiter.go-}
./pkg/resilience/rate_limiter.go-
./pkg/resilience/rate_limiter.go-// NewRateLimiterManager creates a new rate limiter manager
./pkg/resilience/rate_limiter.go-func NewRateLimiterManager(defaultConfigs map[string]RateLimiterConfig) *RateLimiterManager {
./pkg/resilience/rate_limiter.go-	manager := &RateLimiterManager{
./pkg/resilience/rate_limiter.go-		limiters: make(map[string]*RateLimiter),
./pkg/resilience/rate_limiter.go-	}
./pkg/resilience/rate_limiter.go-
./pkg/resilience/rate_limiter.go-	// Create rate limiters from default configs
./pkg/resilience/rate_limiter.go-	for name, config := range defaultConfigs {
./pkg/resilience/rate_limiter.go-		manager.limiters[name] = NewRateLimiter(name, config)
./pkg/resilience/rate_limiter.go-	}
./pkg/resilience/rate_limiter.go-
./pkg/resilience/rate_limiter.go-	return manager
./pkg/resilience/rate_limiter.go-}
./pkg/resilience/rate_limiter.go-
./pkg/resilience/rate_limiter.go-// GetRateLimiter gets a rate limiter by name, creating it if it doesn't exist
./pkg/resilience/rate_limiter.go-func (m *RateLimiterManager) GetRateLimiter(name string) *RateLimiter {
./pkg/resilience/rate_limiter.go-	m.mutex.RLock()
./pkg/resilience/rate_limiter.go-	limiter, exists := m.limiters[name]
./pkg/resilience/rate_limiter.go-	m.mutex.RUnlock()
./pkg/resilience/rate_limiter.go-
--
./pkg/resilience/circuit_breaker.go:type CircuitBreakerConfig struct {
./pkg/resilience/circuit_breaker.go-	FailureThreshold    int           // Number of failures before tripping
./pkg/resilience/circuit_breaker.go-	FailureRatio        float64       // Failure ratio threshold (0.0-1.0)
./pkg/resilience/circuit_breaker.go-	ResetTimeout        time.Duration // Time before attempting retry
./pkg/resilience/circuit_breaker.go-	SuccessThreshold    int           // Number of successes needed to close circuit
./pkg/resilience/circuit_breaker.go-	TimeoutThreshold    time.Duration // Request timeout threshold
./pkg/resilience/circuit_breaker.go-	MaxRequestsHalfOpen int           // Max requests in half-open state
./pkg/resilience/circuit_breaker.go-	MinimumRequestCount int           // Minimum requests before evaluating failure ratio
./pkg/resilience/circuit_breaker.go-}
./pkg/resilience/circuit_breaker.go-
./pkg/resilience/circuit_breaker.go-// CircuitBreaker implements the circuit breaker pattern with production features
./pkg/resilience/circuit_breaker.go-type CircuitBreaker struct {
./pkg/resilience/circuit_breaker.go-	name            string
./pkg/resilience/circuit_breaker.go-	config          CircuitBreakerConfig
./pkg/resilience/circuit_breaker.go-	state           atomic.Value // CircuitBreakerState
./pkg/resilience/circuit_breaker.go-	counts          atomic.Value // *Counts
./pkg/resilience/circuit_breaker.go-	lastFailureTime atomic.Value // time.Time
./pkg/resilience/circuit_breaker.go-	lastStateChange atomic.Value // time.Time
./pkg/resilience/circuit_breaker.go-
./pkg/resilience/circuit_breaker.go-	// Concurrent request tracking for half-open state
./pkg/resilience/circuit_breaker.go-	halfOpenRequests atomic.Int32
./pkg/resilience/circuit_breaker.go-
./pkg/resilience/circuit_breaker.go-	// Synchronization
./pkg/resilience/circuit_breaker.go-	mutex sync.RWMutex
./pkg/resilience/circuit_breaker.go-
./pkg/resilience/circuit_breaker.go-	// Observability
./pkg/resilience/circuit_breaker.go-	logger  observability.Logger
./pkg/resilience/circuit_breaker.go-	metrics observability.MetricsClient
./pkg/resilience/circuit_breaker.go-}
./pkg/resilience/circuit_breaker.go-
./pkg/resilience/circuit_breaker.go-// NewCircuitBreaker creates a new circuit breaker with the given configuration
./pkg/resilience/circuit_breaker.go-func NewCircuitBreaker(name string, config CircuitBreakerConfig, logger observability.Logger, metrics observability.MetricsClient) *CircuitBreaker {
./pkg/resilience/circuit_breaker.go-	// Apply defaults if not set
./pkg/resilience/circuit_breaker.go-	if config.FailureThreshold == 0 {
./pkg/resilience/circuit_breaker.go-		config.FailureThreshold = 5
./pkg/resilience/circuit_breaker.go-	}
./pkg/resilience/circuit_breaker.go-	if config.FailureRatio == 0 {
./pkg/resilience/circuit_breaker.go-		config.FailureRatio = 0.6
./pkg/resilience/circuit_breaker.go-	}
./pkg/resilience/circuit_breaker.go-	if config.ResetTimeout == 0 {
./pkg/resilience/circuit_breaker.go-		config.ResetTimeout = 30 * time.Second
./pkg/resilience/circuit_breaker.go-	}
./pkg/resilience/circuit_breaker.go-	if config.SuccessThreshold == 0 {
./pkg/resilience/circuit_breaker.go-		config.SuccessThreshold = 2
./pkg/resilience/circuit_breaker.go-	}
./pkg/resilience/circuit_breaker.go-	if config.TimeoutThreshold == 0 {
./pkg/resilience/circuit_breaker.go-		config.TimeoutThreshold = 5 * time.Second
./pkg/resilience/circuit_breaker.go-	}
./pkg/resilience/circuit_breaker.go-	if config.MaxRequestsHalfOpen == 0 {
./pkg/resilience/circuit_breaker.go-		config.MaxRequestsHalfOpen = 5
./pkg/resilience/circuit_breaker.go-	}
--
./pkg/resilience/circuit_breaker_config.go:type CircuitBreakerServiceConfig struct {
./pkg/resilience/circuit_breaker_config.go-	Enabled             bool          `mapstructure:"enabled" json:"enabled"`
./pkg/resilience/circuit_breaker_config.go-	MaxRequests         uint32        `mapstructure:"max_requests" json:"max_requests"`
./pkg/resilience/circuit_breaker_config.go-	Interval            time.Duration `mapstructure:"interval" json:"interval"`
./pkg/resilience/circuit_breaker_config.go-	Timeout             time.Duration `mapstructure:"timeout" json:"timeout"`
./pkg/resilience/circuit_breaker_config.go-	FailureThreshold    float64       `mapstructure:"failure_threshold" json:"failure_threshold"`
./pkg/resilience/circuit_breaker_config.go-	SuccessThreshold    uint32        `mapstructure:"success_threshold" json:"success_threshold"`
./pkg/resilience/circuit_breaker_config.go-	MinimumRequestCount uint32        `mapstructure:"minimum_request_count" json:"minimum_request_count"`
./pkg/resilience/circuit_breaker_config.go-	MaxRequestsHalfOpen uint32        `mapstructure:"max_requests_half_open" json:"max_requests_half_open"`
./pkg/resilience/circuit_breaker_config.go-}
./pkg/resilience/circuit_breaker_config.go-
./pkg/resilience/circuit_breaker_config.go-// DefaultCircuitBreakerConfigs provides default configurations for all services
./pkg/resilience/circuit_breaker_config.go-var DefaultCircuitBreakerConfigs = map[string]CircuitBreakerServiceConfig{
./pkg/resilience/circuit_breaker_config.go-	"task_service": {
./pkg/resilience/circuit_breaker_config.go-		Enabled:             true,
./pkg/resilience/circuit_breaker_config.go-		MaxRequests:         100,
./pkg/resilience/circuit_breaker_config.go-		Interval:            10 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		Timeout:             30 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		FailureThreshold:    0.5,
./pkg/resilience/circuit_breaker_config.go-		SuccessThreshold:    5,
./pkg/resilience/circuit_breaker_config.go-		MinimumRequestCount: 10,
./pkg/resilience/circuit_breaker_config.go-		MaxRequestsHalfOpen: 10,
./pkg/resilience/circuit_breaker_config.go-	},
./pkg/resilience/circuit_breaker_config.go-	"workflow_service": {
./pkg/resilience/circuit_breaker_config.go-		Enabled:             true,
./pkg/resilience/circuit_breaker_config.go-		MaxRequests:         50,
./pkg/resilience/circuit_breaker_config.go-		Interval:            10 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		Timeout:             45 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		FailureThreshold:    0.6,
./pkg/resilience/circuit_breaker_config.go-		SuccessThreshold:    3,
./pkg/resilience/circuit_breaker_config.go-		MinimumRequestCount: 5,
./pkg/resilience/circuit_breaker_config.go-		MaxRequestsHalfOpen: 5,
./pkg/resilience/circuit_breaker_config.go-	},
./pkg/resilience/circuit_breaker_config.go-	"agent_service": {
./pkg/resilience/circuit_breaker_config.go-		Enabled:             true,
./pkg/resilience/circuit_breaker_config.go-		MaxRequests:         200,
./pkg/resilience/circuit_breaker_config.go-		Interval:            5 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		Timeout:             15 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		FailureThreshold:    0.5,
./pkg/resilience/circuit_breaker_config.go-		SuccessThreshold:    5,
./pkg/resilience/circuit_breaker_config.go-		MinimumRequestCount: 20,
./pkg/resilience/circuit_breaker_config.go-		MaxRequestsHalfOpen: 20,
./pkg/resilience/circuit_breaker_config.go-	},
./pkg/resilience/circuit_breaker_config.go-	"context_service": {
./pkg/resilience/circuit_breaker_config.go-		Enabled:             true,
./pkg/resilience/circuit_breaker_config.go-		MaxRequests:         150,
./pkg/resilience/circuit_breaker_config.go-		Interval:            10 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		Timeout:             20 * time.Second,
./pkg/resilience/circuit_breaker_config.go-		FailureThreshold:    0.4,
./pkg/resilience/circuit_breaker_config.go-		SuccessThreshold:    5,
./pkg/resilience/circuit_breaker_config.go-		MinimumRequestCount: 15,
--
./pkg/queue/queue.go:type Config struct {
./pkg/queue/queue.go-	Logger observability.Logger
./pkg/queue/queue.go-}
./pkg/queue/queue.go-
./pkg/queue/queue.go-// NewClient creates a new Redis-based queue client
./pkg/queue/queue.go-func NewClient(_ context.Context, config *Config) (*Client, error) {
./pkg/queue/queue.go-	if config == nil {
./pkg/queue/queue.go-		config = &Config{}
./pkg/queue/queue.go-	}
./pkg/queue/queue.go-
./pkg/queue/queue.go-	logger := config.Logger
./pkg/queue/queue.go-	if logger == nil {
./pkg/queue/queue.go-		logger = observability.NewNoopLogger()
./pkg/queue/queue.go-	}
./pkg/queue/queue.go-
./pkg/queue/queue.go-	// Get Redis configuration from environment
./pkg/queue/queue.go-	addresses := []string{"localhost:6379"}
./pkg/queue/queue.go-	if redisAddr := os.Getenv("REDIS_ADDRESS"); redisAddr != "" {
./pkg/queue/queue.go-		addresses = []string{redisAddr}
./pkg/queue/queue.go-	}
./pkg/queue/queue.go-
./pkg/queue/queue.go-	password := os.Getenv("REDIS_PASSWORD")
./pkg/queue/queue.go-
./pkg/queue/queue.go-	streamName := "webhook-events"
./pkg/queue/queue.go-	if s := os.Getenv("REDIS_STREAM_NAME"); s != "" {
./pkg/queue/queue.go-		streamName = s
./pkg/queue/queue.go-	}
./pkg/queue/queue.go-
./pkg/queue/queue.go-	consumerGroup := "webhook-processors"
./pkg/queue/queue.go-	if g := os.Getenv("REDIS_CONSUMER_GROUP"); g != "" {
./pkg/queue/queue.go-		consumerGroup = g
./pkg/queue/queue.go-	}
./pkg/queue/queue.go-
./pkg/queue/queue.go-	// Create Redis Streams client
./pkg/queue/queue.go-	streamsClient, err := redis.NewStreamsClient(&redis.StreamsConfig{
./pkg/queue/queue.go-		Addresses:  addresses,
./pkg/queue/queue.go-		Password:   password,
./pkg/queue/queue.go-		PoolSize:   10,
./pkg/queue/queue.go-		MaxRetries: 3,
./pkg/queue/queue.go-	}, logger)
./pkg/queue/queue.go-	if err != nil {
./pkg/queue/queue.go-		return nil, fmt.Errorf("failed to create Redis Streams client: %w", err)
./pkg/queue/queue.go-	}
./pkg/queue/queue.go-
./pkg/queue/queue.go-	// Test connection
./pkg/queue/queue.go-	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
./pkg/queue/queue.go-	defer cancel()
./pkg/queue/queue.go-
./pkg/queue/queue.go-	// Create consumer group if it doesn't exist
./pkg/queue/queue.go-	if err := streamsClient.CreateConsumerGroupMkStream(ctx, streamName, consumerGroup, "0"); err != nil {
./pkg/queue/queue.go-		// Ignore error if group already exists
--
./pkg/rules/policy_manager.go:type PolicyManagerConfig struct {
./pkg/rules/policy_manager.go-	CacheDuration  time.Duration `mapstructure:"cache_duration"`
./pkg/rules/policy_manager.go-	MaxPolicies    int           `mapstructure:"max_policies"`
./pkg/rules/policy_manager.go-	EnableCaching  bool          `mapstructure:"enable_caching"`
./pkg/rules/policy_manager.go-	HotReload      bool          `mapstructure:"hot_reload"`
./pkg/rules/policy_manager.go-	ReloadInterval time.Duration `mapstructure:"reload_interval"`
./pkg/rules/policy_manager.go-}
./pkg/rules/policy_manager.go-
./pkg/rules/policy_manager.go-// policyManager implements the PolicyManager interface
./pkg/rules/policy_manager.go-type policyManager struct {
./pkg/rules/policy_manager.go-	mu       sync.RWMutex
./pkg/rules/policy_manager.go-	policies map[string]*Policy
./pkg/rules/policy_manager.go-	cache    cache.Cache
./pkg/rules/policy_manager.go-	config   PolicyManagerConfig
./pkg/rules/policy_manager.go-	logger   observability.Logger
./pkg/rules/policy_manager.go-	metrics  observability.MetricsClient
./pkg/rules/policy_manager.go-	loadFunc func() ([]Policy, error)
./pkg/rules/policy_manager.go-	stopChan chan struct{}
./pkg/rules/policy_manager.go-}
./pkg/rules/policy_manager.go-
./pkg/rules/policy_manager.go-// NewPolicyManager creates a new policy manager
./pkg/rules/policy_manager.go-func NewPolicyManager(config PolicyManagerConfig, cache cache.Cache, logger observability.Logger, metrics observability.MetricsClient) PolicyManager {
./pkg/rules/policy_manager.go-	if config.CacheDuration == 0 {
./pkg/rules/policy_manager.go-		config.CacheDuration = 5 * time.Minute
./pkg/rules/policy_manager.go-	}
./pkg/rules/policy_manager.go-	if config.MaxPolicies == 0 {
./pkg/rules/policy_manager.go-		config.MaxPolicies = 1000
./pkg/rules/policy_manager.go-	}
./pkg/rules/policy_manager.go-	if config.ReloadInterval == 0 {
./pkg/rules/policy_manager.go-		config.ReloadInterval = 30 * time.Second
./pkg/rules/policy_manager.go-	}
./pkg/rules/policy_manager.go-
./pkg/rules/policy_manager.go-	return &policyManager{
./pkg/rules/policy_manager.go-		policies: make(map[string]*Policy),
./pkg/rules/policy_manager.go-		cache:    cache,
./pkg/rules/policy_manager.go-		config:   config,
./pkg/rules/policy_manager.go-		logger:   logger,
./pkg/rules/policy_manager.go-		metrics:  metrics,
./pkg/rules/policy_manager.go-		stopChan: make(chan struct{}),
./pkg/rules/policy_manager.go-	}
./pkg/rules/policy_manager.go-}
./pkg/rules/policy_manager.go-
./pkg/rules/policy_manager.go-// LoadPolicies loads policies in bulk
./pkg/rules/policy_manager.go-func (pm *policyManager) LoadPolicies(ctx context.Context, policies []Policy) error {
./pkg/rules/policy_manager.go-	pm.mu.Lock()
./pkg/rules/policy_manager.go-	defer pm.mu.Unlock()
./pkg/rules/policy_manager.go-
./pkg/rules/policy_manager.go-	// Clear existing policies
./pkg/rules/policy_manager.go-	pm.policies = make(map[string]*Policy)
./pkg/rules/policy_manager.go-
./pkg/rules/policy_manager.go-	// Load new policies
--
./pkg/rules/engine.go:type Config struct {
./pkg/rules/engine.go-	HotReload      bool          `mapstructure:"hot_reload"`
./pkg/rules/engine.go-	ReloadInterval time.Duration `mapstructure:"reload_interval"`
./pkg/rules/engine.go-	CacheDuration  time.Duration `mapstructure:"cache_duration"`
./pkg/rules/engine.go-	MaxRules       int           `mapstructure:"max_rules"`
./pkg/rules/engine.go-}
./pkg/rules/engine.go-
./pkg/rules/engine.go-// engine implements the Engine interface
./pkg/rules/engine.go-type engine struct {
./pkg/rules/engine.go-	mu              sync.RWMutex
./pkg/rules/engine.go-	rules           map[string]*Rule
./pkg/rules/engine.go-	rulesByCategory map[string][]*Rule
./pkg/rules/engine.go-	evaluator       map[string]func(map[string]interface{}) (interface{}, error)
./pkg/rules/engine.go-	config          Config
./pkg/rules/engine.go-	logger          observability.Logger
./pkg/rules/engine.go-	metrics         observability.MetricsClient
./pkg/rules/engine.go-	loadFunc        func() ([]Rule, error)
./pkg/rules/engine.go-	stopChan        chan struct{}
./pkg/rules/engine.go-}
./pkg/rules/engine.go-
./pkg/rules/engine.go-// NewEngine creates a new rule engine
./pkg/rules/engine.go-func NewEngine(config Config, logger observability.Logger, metrics observability.MetricsClient) Engine {
./pkg/rules/engine.go-	if config.ReloadInterval == 0 {
./pkg/rules/engine.go-		config.ReloadInterval = 30 * time.Second
./pkg/rules/engine.go-	}
./pkg/rules/engine.go-	if config.CacheDuration == 0 {
./pkg/rules/engine.go-		config.CacheDuration = 5 * time.Minute
./pkg/rules/engine.go-	}
./pkg/rules/engine.go-	if config.MaxRules == 0 {
./pkg/rules/engine.go-		config.MaxRules = 1000
./pkg/rules/engine.go-	}
./pkg/rules/engine.go-
./pkg/rules/engine.go-	return &engine{
./pkg/rules/engine.go-		rules:           make(map[string]*Rule),
./pkg/rules/engine.go-		rulesByCategory: make(map[string][]*Rule),
./pkg/rules/engine.go-		evaluator:       make(map[string]func(map[string]interface{}) (interface{}, error)),
./pkg/rules/engine.go-		config:          config,
./pkg/rules/engine.go-		logger:          logger,
./pkg/rules/engine.go-		metrics:         metrics,
./pkg/rules/engine.go-		stopChan:        make(chan struct{}),
./pkg/rules/engine.go-	}
./pkg/rules/engine.go-}
./pkg/rules/engine.go-
./pkg/rules/engine.go-// LoadRules loads rules in bulk
./pkg/rules/engine.go-func (e *engine) LoadRules(ctx context.Context, rules []Rule) error {
./pkg/rules/engine.go-	e.mu.Lock()
./pkg/rules/engine.go-	defer e.mu.Unlock()
./pkg/rules/engine.go-
./pkg/rules/engine.go-	// Clear existing rules
./pkg/rules/engine.go-	e.rules = make(map[string]*Rule)
./pkg/rules/engine.go-	e.rulesByCategory = make(map[string][]*Rule)
--
./pkg/aws/aws.go:type AuthConfig struct {
./pkg/aws/aws.go-	Region     string
./pkg/aws/aws.go-	Endpoint   string
./pkg/aws/aws.go-	AssumeRole string
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// LegacyAuthConfig wraps AWS authentication configuration (legacy version)
./pkg/aws/aws.go:type LegacyAuthConfig struct {
./pkg/aws/aws.go-	Region          string
./pkg/aws/aws.go-	AccessKeyID     string
./pkg/aws/aws.go-	SecretAccessKey string
./pkg/aws/aws.go-	SessionToken    string
./pkg/aws/aws.go-	Profile         string
./pkg/aws/aws.go-	Endpoint        string
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// RDSConfig holds configuration for RDS
./pkg/aws/aws.go:type RDSConfig struct {
./pkg/aws/aws.go-	Region     string
./pkg/aws/aws.go-	SecretName string
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// RDSClient is a client for AWS RDS
./pkg/aws/aws.go-type RDSClient struct {
./pkg/aws/aws.go-	Config interface{}
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// S3Config holds configuration for S3
./pkg/aws/aws.go:type S3Config struct {
./pkg/aws/aws.go-	Auth              AuthConfig
./pkg/aws/aws.go-	Bucket            string
./pkg/aws/aws.go-	UploadPartSize    int64
./pkg/aws/aws.go-	DownloadPartSize  int64
./pkg/aws/aws.go-	Concurrency       int
./pkg/aws/aws.go-	RequestTimeout    int
./pkg/aws/aws.go-	ServerSideEncrypt string
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// ElastiCacheConfig holds configuration for ElastiCache
./pkg/aws/aws.go:type ElastiCacheConfig struct {
./pkg/aws/aws.go-	Auth               AuthConfig
./pkg/aws/aws.go-	ClusterAddress     string
./pkg/aws/aws.go-	Port               int
./pkg/aws/aws.go-	ClusterMode        bool
./pkg/aws/aws.go-	ClusterDiscovery   bool
./pkg/aws/aws.go-	UseTLS             bool
./pkg/aws/aws.go-	InsecureSkipVerify bool
./pkg/aws/aws.go-	MaxRetries         int
./pkg/aws/aws.go-	MinIdleConnections int
./pkg/aws/aws.go-	PoolSize           int
./pkg/aws/aws.go-	DialTimeout        int
./pkg/aws/aws.go-	ReadTimeout        int
./pkg/aws/aws.go-	WriteTimeout       int
./pkg/aws/aws.go-	PoolTimeout        int
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// StandardAWSClient implements the AWSClient interface
./pkg/aws/aws.go-type StandardAWSClient struct {
./pkg/aws/aws.go-	// Contains unexported fields
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// Function declarations for backward compatibility
./pkg/aws/aws.go-// These are stubs that will be implemented by the real implementations in pkg/common/aws
./pkg/aws/aws.go-
./pkg/aws/aws.go-// NewAWSClient creates a new AWS client with the provided config
./pkg/aws/aws.go-func NewAWSClient(ctx interface{}, cfg interface{}) AWSClient {
./pkg/aws/aws.go-	// This is a stub that will be overridden by the real implementation
./pkg/aws/aws.go-	return nil
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// GetAWSConfig gets an AWS config
./pkg/aws/aws.go-func GetAWSConfig(ctx interface{}, cfg AuthConfig) (interface{}, error) {
./pkg/aws/aws.go-	// This is a stub that will be overridden by the real implementation
./pkg/aws/aws.go-	return nil, nil
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// LegacyGetAWSConfig gets an AWS config using legacy format
./pkg/aws/aws.go-func LegacyGetAWSConfig(ctx interface{}, cfg AuthConfig) (interface{}, error) {
./pkg/aws/aws.go-	// This is a stub that will be overridden by the real implementation
./pkg/aws/aws.go-	return nil, nil
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// IsIRSAEnabled returns whether IRSA is enabled
./pkg/aws/aws.go-func IsIRSAEnabled() bool {
./pkg/aws/aws.go-	// This is a stub that will be overridden by the real implementation
./pkg/aws/aws.go-	return false
./pkg/aws/aws.go-}
./pkg/aws/aws.go-
./pkg/aws/aws.go-// GetAWSConfigLegacy gets an AWS config using legacy format
./pkg/aws/aws.go-func GetAWSConfigLegacy(ctx interface{}, cfg LegacyAuthConfig) (interface{}, error) {
--
./pkg/worker/redis_worker.go:type Config struct {
./pkg/worker/redis_worker.go-	QueueClient    QueueClient
./pkg/worker/redis_worker.go-	RedisClient    RedisIdempotency
./pkg/worker/redis_worker.go-	Processor      func(queue.Event) error
./pkg/worker/redis_worker.go-	Logger         observability.Logger
./pkg/worker/redis_worker.go-	ConsumerName   string
./pkg/worker/redis_worker.go-	IdempotencyTTL time.Duration
./pkg/worker/redis_worker.go-}
./pkg/worker/redis_worker.go-
./pkg/worker/redis_worker.go-// NewRedisWorker creates a new Redis worker
./pkg/worker/redis_worker.go-func NewRedisWorker(config *Config) (*RedisWorker, error) {
./pkg/worker/redis_worker.go-	if config.QueueClient == nil {
./pkg/worker/redis_worker.go-		return nil, fmt.Errorf("queue client is required")
./pkg/worker/redis_worker.go-	}
./pkg/worker/redis_worker.go-	if config.RedisClient == nil {
./pkg/worker/redis_worker.go-		return nil, fmt.Errorf("redis client is required")
./pkg/worker/redis_worker.go-	}
./pkg/worker/redis_worker.go-	if config.Processor == nil {
./pkg/worker/redis_worker.go-		return nil, fmt.Errorf("processor function is required")
./pkg/worker/redis_worker.go-	}
./pkg/worker/redis_worker.go-	if config.Logger == nil {
./pkg/worker/redis_worker.go-		config.Logger = observability.NewNoopLogger()
./pkg/worker/redis_worker.go-	}
./pkg/worker/redis_worker.go-	if config.ConsumerName == "" {
./pkg/worker/redis_worker.go-		config.ConsumerName = "worker"
./pkg/worker/redis_worker.go-	}
./pkg/worker/redis_worker.go-	if config.IdempotencyTTL == 0 {
./pkg/worker/redis_worker.go-		config.IdempotencyTTL = 24 * time.Hour
./pkg/worker/redis_worker.go-	}
./pkg/worker/redis_worker.go-
./pkg/worker/redis_worker.go-	return &RedisWorker{
./pkg/worker/redis_worker.go-		queueClient:    config.QueueClient,
./pkg/worker/redis_worker.go-		redisClient:    config.RedisClient,
./pkg/worker/redis_worker.go-		processor:      config.Processor,
./pkg/worker/redis_worker.go-		logger:         config.Logger,
./pkg/worker/redis_worker.go-		consumerName:   config.ConsumerName,
./pkg/worker/redis_worker.go-		idempotencyTTL: config.IdempotencyTTL,
./pkg/worker/redis_worker.go-	}, nil
./pkg/worker/redis_worker.go-}
./pkg/worker/redis_worker.go-
./pkg/worker/redis_worker.go-// Run starts the worker processing loop
./pkg/worker/redis_worker.go-func (w *RedisWorker) Run(ctx context.Context) error {
./pkg/worker/redis_worker.go-	w.logger.Info("Starting Redis worker", map[string]interface{}{
./pkg/worker/redis_worker.go-		"consumer_name": w.consumerName,
./pkg/worker/redis_worker.go-	})
./pkg/worker/redis_worker.go-
./pkg/worker/redis_worker.go-	for {
./pkg/worker/redis_worker.go-		select {
./pkg/worker/redis_worker.go-		case <-ctx.Done():
./pkg/worker/redis_worker.go-			w.logger.Info("Worker stopping due to context cancellation", nil)
./pkg/worker/redis_worker.go-			return ctx.Err()
--
./pkg/testutil/helpers.go:type TestConfig struct {
./pkg/testutil/helpers.go-	DatabaseDSN   string
./pkg/testutil/helpers.go-	RedisAddr     string
./pkg/testutil/helpers.go-	APIBaseURL    string
./pkg/testutil/helpers.go-	TestTenantID  string
./pkg/testutil/helpers.go-	TestAuthToken string
./pkg/testutil/helpers.go-}
./pkg/testutil/helpers.go-
./pkg/testutil/helpers.go-// LoadTestConfig loads test configuration from environment
./pkg/testutil/helpers.go-func LoadTestConfig() *TestConfig {
./pkg/testutil/helpers.go-	return &TestConfig{
./pkg/testutil/helpers.go-		DatabaseDSN:   getEnvOrDefault("TEST_DATABASE_DSN", "postgresql://test:test@localhost:5432/test?sslmode=disable"),
./pkg/testutil/helpers.go-		RedisAddr:     getEnvOrDefault("TEST_REDIS_ADDR", "localhost:6379"),
./pkg/testutil/helpers.go-		APIBaseURL:    getEnvOrDefault("TEST_API_BASE_URL", "http://localhost:8081"),
./pkg/testutil/helpers.go-		TestTenantID:  getEnvOrDefault("TEST_TENANT_ID", "test-tenant-"+uuid.New().String()),
./pkg/testutil/helpers.go-		TestAuthToken: getEnvOrDefault("TEST_AUTH_TOKEN", "test-token"),
./pkg/testutil/helpers.go-	}
./pkg/testutil/helpers.go-}
./pkg/testutil/helpers.go-
./pkg/testutil/helpers.go-// TestDatabase provides test database utilities
./pkg/testutil/helpers.go-type TestDatabase struct {
./pkg/testutil/helpers.go-	DB *sql.DB
./pkg/testutil/helpers.go-}
./pkg/testutil/helpers.go-
./pkg/testutil/helpers.go-// NewTestDatabase creates a new test database connection
./pkg/testutil/helpers.go-func NewTestDatabase(t *testing.T, dsn string) *TestDatabase {
./pkg/testutil/helpers.go-	db, err := sql.Open("postgres", dsn)
./pkg/testutil/helpers.go-	require.NoError(t, err)
./pkg/testutil/helpers.go-
./pkg/testutil/helpers.go-	// Verify connection
./pkg/testutil/helpers.go-	err = db.Ping()
./pkg/testutil/helpers.go-	require.NoError(t, err)
./pkg/testutil/helpers.go-
./pkg/testutil/helpers.go-	return &TestDatabase{DB: db}
./pkg/testutil/helpers.go-}
./pkg/testutil/helpers.go-
./pkg/testutil/helpers.go-// Cleanup cleans up test data
./pkg/testutil/helpers.go-func (tdb *TestDatabase) Cleanup(t *testing.T, tenantID string) {
./pkg/testutil/helpers.go-	queries := []string{
./pkg/testutil/helpers.go-		fmt.Sprintf("DELETE FROM mcp.contexts WHERE agent_id LIKE '%s-%%'", tenantID),
./pkg/testutil/helpers.go-		fmt.Sprintf("DELETE FROM mcp.agents WHERE tenant_id = '%s'", tenantID),
./pkg/testutil/helpers.go-		fmt.Sprintf("DELETE FROM mcp.models WHERE tenant_id = '%s'", tenantID),
./pkg/testutil/helpers.go-	}
./pkg/testutil/helpers.go-
./pkg/testutil/helpers.go-	for _, query := range queries {
./pkg/testutil/helpers.go-		_, err := tdb.DB.Exec(query)
./pkg/testutil/helpers.go-		if err != nil {
./pkg/testutil/helpers.go-			t.Logf("Cleanup query failed: %v", err)
./pkg/testutil/helpers.go-		}
./pkg/testutil/helpers.go-	}
./pkg/testutil/helpers.go-}
--
./pkg/client/rest/webhook.go:type WebhookConfig struct {
./pkg/client/rest/webhook.go-	Enabled       bool
./pkg/client/rest/webhook.go-	Secret        string
./pkg/client/rest/webhook.go-	Endpoint      string
./pkg/client/rest/webhook.go-	AllowedEvents []string
./pkg/client/rest/webhook.go-	ValidateIP    bool
./pkg/client/rest/webhook.go-	IPWhitelist   []string
./pkg/client/rest/webhook.go-}
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-// WebhookClient handles webhook processing through the REST API
./pkg/client/rest/webhook.go-type WebhookClient struct {
./pkg/client/rest/webhook.go-	client *RESTClient
./pkg/client/rest/webhook.go-	logger observability.Logger
./pkg/client/rest/webhook.go-	config WebhookConfig
./pkg/client/rest/webhook.go-}
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-// NewWebhookClient creates a new WebhookClient with the given configuration
./pkg/client/rest/webhook.go-func NewWebhookClient(client *RESTClient, config WebhookConfig, logger observability.Logger) *WebhookClient {
./pkg/client/rest/webhook.go-	if logger == nil {
./pkg/client/rest/webhook.go-		logger = observability.NewLogger("webhook-client")
./pkg/client/rest/webhook.go-	}
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-	return &WebhookClient{
./pkg/client/rest/webhook.go-		client: client,
./pkg/client/rest/webhook.go-		config: config,
./pkg/client/rest/webhook.go-		logger: logger,
./pkg/client/rest/webhook.go-	}
./pkg/client/rest/webhook.go-}
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-// ProcessWebhook handles an incoming webhook request
./pkg/client/rest/webhook.go-func (c *WebhookClient) ProcessWebhook(ctx context.Context, provider string, headers http.Header, body []byte) error {
./pkg/client/rest/webhook.go-	endpoint := fmt.Sprintf("/api/webhooks/%s", provider)
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-	req := WebhookRequest{
./pkg/client/rest/webhook.go-		Provider: provider,
./pkg/client/rest/webhook.go-		Headers:  make(map[string][]string),
./pkg/client/rest/webhook.go-		Body:     body,
./pkg/client/rest/webhook.go-	}
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-	// Copy headers we care about
./pkg/client/rest/webhook.go-	for k, v := range headers {
./pkg/client/rest/webhook.go-		req.Headers[k] = v
./pkg/client/rest/webhook.go-	}
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-	var resp struct {
./pkg/client/rest/webhook.go-		Success bool   `json:"success"`
./pkg/client/rest/webhook.go-		Error   string `json:"error,omitempty"`
./pkg/client/rest/webhook.go-	}
./pkg/client/rest/webhook.go-
./pkg/client/rest/webhook.go-	err := c.client.Post(ctx, endpoint, req, &resp)
./pkg/client/rest/webhook.go-	if err != nil {
--
./pkg/client/rest/client.go:type ClientConfig struct {
./pkg/client/rest/client.go-	BaseURL string
./pkg/client/rest/client.go-	APIKey  string
./pkg/client/rest/client.go-	Timeout time.Duration
./pkg/client/rest/client.go-	Logger  observability.Logger
./pkg/client/rest/client.go-}
./pkg/client/rest/client.go-
./pkg/client/rest/client.go-// NewRESTClient creates a new REST API client
./pkg/client/rest/client.go-func NewRESTClient(config ClientConfig) *RESTClient {
./pkg/client/rest/client.go-	timeout := config.Timeout
./pkg/client/rest/client.go-	if timeout == 0 {
./pkg/client/rest/client.go-		timeout = 30 * time.Second
./pkg/client/rest/client.go-	}
./pkg/client/rest/client.go-
./pkg/client/rest/client.go-	logger := config.Logger
./pkg/client/rest/client.go-	if logger == nil {
./pkg/client/rest/client.go-		logger = observability.NewLogger("rest-client")
./pkg/client/rest/client.go-	}
./pkg/client/rest/client.go-
./pkg/client/rest/client.go-	return &RESTClient{
./pkg/client/rest/client.go-		baseURL: config.BaseURL,
./pkg/client/rest/client.go-		httpClient: &http.Client{
./pkg/client/rest/client.go-			Timeout: timeout,
./pkg/client/rest/client.go-		},
./pkg/client/rest/client.go-		apiKey: config.APIKey,
./pkg/client/rest/client.go-		logger: logger,
./pkg/client/rest/client.go-	}
./pkg/client/rest/client.go-}
./pkg/client/rest/client.go-
./pkg/client/rest/client.go-// doRequest performs an HTTP request with the given method, path, and body
./pkg/client/rest/client.go-func (c *RESTClient) doRequest(ctx context.Context, method, path string, body interface{}, result interface{}) error {
./pkg/client/rest/client.go-	url := fmt.Sprintf("%s%s", c.baseURL, path)
./pkg/client/rest/client.go-
./pkg/client/rest/client.go-	var reqBody []byte
./pkg/client/rest/client.go-	var err error
./pkg/client/rest/client.go-	if body != nil {
./pkg/client/rest/client.go-		reqBody, err = json.Marshal(body)
./pkg/client/rest/client.go-		if err != nil {
./pkg/client/rest/client.go-			return fmt.Errorf("failed to marshal request body: %w", err)
./pkg/client/rest/client.go-		}
./pkg/client/rest/client.go-	}
./pkg/client/rest/client.go-
./pkg/client/rest/client.go-	req, err := http.NewRequestWithContext(ctx, method, url, bytes.NewBuffer(reqBody))
./pkg/client/rest/client.go-	if err != nil {
./pkg/client/rest/client.go-		return fmt.Errorf("failed to create request: %w", err)
./pkg/client/rest/client.go-	}
./pkg/client/rest/client.go-
./pkg/client/rest/client.go-	req.Header.Set("Content-Type", "application/json")
./pkg/client/rest/client.go-	if c.apiKey != "" {
./pkg/client/rest/client.go-		req.Header.Set("X-API-Key", c.apiKey)
./pkg/client/rest/client.go-	}
--
./pkg/services/base_service.go:type ServiceConfig struct {
./pkg/services/base_service.go-	// Resilience
./pkg/services/base_service.go-	CircuitBreaker *gobreaker.Settings
./pkg/services/base_service.go-	RetryPolicy    resilience.RetryPolicy
./pkg/services/base_service.go-	TimeoutPolicy  resilience.TimeoutPolicy
./pkg/services/base_service.go-	BulkheadPolicy resilience.BulkheadPolicy
./pkg/services/base_service.go-
./pkg/services/base_service.go-	// Rate Limiting
./pkg/services/base_service.go-	RateLimiter  RateLimiter
./pkg/services/base_service.go-	QuotaManager QuotaManager
./pkg/services/base_service.go-
./pkg/services/base_service.go-	// Security
./pkg/services/base_service.go-	Authorizer        auth.Authorizer
./pkg/services/base_service.go-	Sanitizer         Sanitizer
./pkg/services/base_service.go-	EncryptionService EncryptionService
./pkg/services/base_service.go-
./pkg/services/base_service.go-	// Observability
./pkg/services/base_service.go-	Logger  observability.Logger
./pkg/services/base_service.go-	Metrics observability.MetricsClient
./pkg/services/base_service.go-	Tracer  observability.StartSpanFunc
./pkg/services/base_service.go-
./pkg/services/base_service.go-	// Business Rules
./pkg/services/base_service.go-	RuleEngine    rules.Engine
./pkg/services/base_service.go-	PolicyManager rules.PolicyManager
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// BaseService provides common functionality for all services
./pkg/services/base_service.go-type BaseService struct {
./pkg/services/base_service.go-	config         ServiceConfig
./pkg/services/base_service.go-	eventStore     events.EventStore
./pkg/services/base_service.go-	eventPublisher events.EventPublisher
./pkg/services/base_service.go-	healthChecker  HealthChecker
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// NewBaseService creates a new base service
./pkg/services/base_service.go-func NewBaseService(config ServiceConfig) BaseService {
./pkg/services/base_service.go-	return BaseService{
./pkg/services/base_service.go-		config: config,
./pkg/services/base_service.go-	}
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// SetEventStore sets the event store
./pkg/services/base_service.go-func (s *BaseService) SetEventStore(store events.EventStore) {
./pkg/services/base_service.go-	s.eventStore = store
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// SetEventPublisher sets the event publisher
./pkg/services/base_service.go-func (s *BaseService) SetEventPublisher(publisher events.EventPublisher) {
./pkg/services/base_service.go-	s.eventPublisher = publisher
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
--
./pkg/services/base_service.go:type TxConfig struct {
./pkg/services/base_service.go-	Timeout        time.Duration
./pkg/services/base_service.go-	IsolationLevel string
./pkg/services/base_service.go-	RetryPolicy    resilience.RetryPolicy
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// defaultTxConfig provides default transaction configuration
./pkg/services/base_service.go-var defaultTxConfig = TxConfig{
./pkg/services/base_service.go-	Timeout:        30 * time.Second,
./pkg/services/base_service.go-	IsolationLevel: "read_committed",
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// WithTxTimeout sets the transaction timeout
./pkg/services/base_service.go-func WithTxTimeout(timeout time.Duration) TxOption {
./pkg/services/base_service.go-	return func(cfg *TxConfig) {
./pkg/services/base_service.go-		cfg.Timeout = timeout
./pkg/services/base_service.go-	}
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// WithTxIsolationLevel sets the transaction isolation level
./pkg/services/base_service.go-func WithTxIsolationLevel(level string) TxOption {
./pkg/services/base_service.go-	return func(cfg *TxConfig) {
./pkg/services/base_service.go-		cfg.IsolationLevel = level
./pkg/services/base_service.go-	}
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// WithTxRetryPolicy sets the transaction retry policy
./pkg/services/base_service.go-func WithTxRetryPolicy(policy resilience.RetryPolicy) TxOption {
./pkg/services/base_service.go-	return func(cfg *TxConfig) {
./pkg/services/base_service.go-		cfg.RetryPolicy = policy
./pkg/services/base_service.go-	}
./pkg/services/base_service.go-}
./pkg/services/base_service.go-
./pkg/services/base_service.go-// StartDistributedTransaction starts a new distributed transaction with options
./pkg/services/base_service.go-func (s *BaseService) StartDistributedTransaction(ctx context.Context, opts ...TxOption) (context.Context, func(), func()) {
./pkg/services/base_service.go-	// Generate transaction ID
./pkg/services/base_service.go-	txID := uuid.New()
./pkg/services/base_service.go-
./pkg/services/base_service.go-	// Apply options
./pkg/services/base_service.go-	config := defaultTxConfig
./pkg/services/base_service.go-	for _, opt := range opts {
./pkg/services/base_service.go-		opt(&config)
./pkg/services/base_service.go-	}
./pkg/services/base_service.go-
./pkg/services/base_service.go-	// Create timeout context
./pkg/services/base_service.go-	ctx, cancel := context.WithTimeout(ctx, config.Timeout)
./pkg/services/base_service.go-
./pkg/services/base_service.go-	// Add transaction ID to context
./pkg/services/base_service.go-	type txIDKey struct{}
./pkg/services/base_service.go-	ctx = context.WithValue(ctx, txIDKey{}, txID)
./pkg/services/base_service.go-
--
./pkg/interfaces/interfaces.go:type WebhookConfig struct {
./pkg/interfaces/interfaces.go-	EnabledField             bool     `mapstructure:"enabled"`
./pkg/interfaces/interfaces.go-	GitHubEndpointField      string   `mapstructure:"github_endpoint"`
./pkg/interfaces/interfaces.go-	GitHubSecretField        string   `mapstructure:"github_secret"`
./pkg/interfaces/interfaces.go-	GitHubIPValidationField  bool     `mapstructure:"github_ip_validation"`
./pkg/interfaces/interfaces.go-	GitHubAllowedEventsField []string `mapstructure:"github_allowed_events"`
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// WebhookConfigInterface defines an interface for accessing webhook configuration
./pkg/interfaces/interfaces.go-type WebhookConfigInterface interface {
./pkg/interfaces/interfaces.go-	Enabled() bool
./pkg/interfaces/interfaces.go-	GitHubSecret() string
./pkg/interfaces/interfaces.go-	GitHubEndpoint() string
./pkg/interfaces/interfaces.go-	GitHubIPValidationEnabled() bool
./pkg/interfaces/interfaces.go-	GitHubAllowedEvents() []string
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// Enabled returns whether webhooks are enabled
./pkg/interfaces/interfaces.go-func (c *WebhookConfig) Enabled() bool {
./pkg/interfaces/interfaces.go-	return c.EnabledField
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// GitHubSecret returns the GitHub webhook secret
./pkg/interfaces/interfaces.go-func (c *WebhookConfig) GitHubSecret() string {
./pkg/interfaces/interfaces.go-	return c.GitHubSecretField
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// GitHubEndpoint returns the GitHub webhook endpoint
./pkg/interfaces/interfaces.go-func (c *WebhookConfig) GitHubEndpoint() string {
./pkg/interfaces/interfaces.go-	return c.GitHubEndpointField
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// GitHubIPValidationEnabled returns whether GitHub IP validation is enabled
./pkg/interfaces/interfaces.go-func (c *WebhookConfig) GitHubIPValidationEnabled() bool {
./pkg/interfaces/interfaces.go-	return c.GitHubIPValidationField
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// GitHubAllowedEvents returns the list of allowed GitHub events
./pkg/interfaces/interfaces.go-func (c *WebhookConfig) GitHubAllowedEvents() []string {
./pkg/interfaces/interfaces.go-	return c.GitHubAllowedEventsField
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// APIConfig defines the API server configuration
./pkg/interfaces/interfaces.go:type APIConfig struct {
./pkg/interfaces/interfaces.go-	ListenAddress  string `mapstructure:"listen_address"`
./pkg/interfaces/interfaces.go-	BaseURL        string `mapstructure:"base_url"`
./pkg/interfaces/interfaces.go-	TLSCertFile    string `mapstructure:"tls_cert_file"`
./pkg/interfaces/interfaces.go-	TLSKeyFile     string `mapstructure:"tls_key_file"`
./pkg/interfaces/interfaces.go-	CORSAllowed    string `mapstructure:"cors_allowed"`
./pkg/interfaces/interfaces.go-	RateLimit      int    `mapstructure:"rate_limit"`
./pkg/interfaces/interfaces.go-	RequestTimeout int    `mapstructure:"request_timeout"`
./pkg/interfaces/interfaces.go-}
./pkg/interfaces/interfaces.go-
./pkg/interfaces/interfaces.go-// CoreConfig defines the engine core configuration
./pkg/interfaces/interfaces.go:type CoreConfig struct {
./pkg/interfaces/interfaces.go-	EventBufferSize  int `mapstructure:"event_buffer_size"`
./pkg/interfaces/interfaces.go-	ConcurrencyLimit int `mapstructure:"concurrency_limit"`
./pkg/interfaces/interfaces.go-	EventTimeout     any `mapstructure:"event_timeout"`
./pkg/interfaces/interfaces.go-}
