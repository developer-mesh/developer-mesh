// Package events provides adapter functionality for connecting to the system event bus.
// This file provides a compatibility layer that resolves interface redeclaration issues
// following the pattern used successfully in the AWS package migration.
package events

import (
	"context"
	"time"

	corevents "github.com/S-Corkum/devops-mcp/pkg/events"
	"github.com/S-Corkum/devops-mcp/pkg/mcp"
	"github.com/S-Corkum/devops-mcp/pkg/observability"
	"github.com/google/uuid"
)

// ----- Core Type Aliases -----
// These provide clear references to the pkg/events and pkg/mcp types

// CoreEvent is an alias for the mcp.Event type
type CoreEvent = mcp.Event

// CoreEventType is an alias for the core events.EventType
type CoreEventType = corevents.EventType

// CoreHandler is an alias for the core events.Handler
type CoreHandler = corevents.Handler

// CoreEventBus is an alias for the core events.EventBusIface
type CoreEventBus = corevents.EventBusIface

// ----- Adapter Bridge Functions -----

// AdapterToCore converts an adapter event type to a core event type
func AdapterToCore(eventType EventType) CoreEventType {
	return CoreEventType(string(eventType))
}

// CoreToAdapter converts a core event type to an adapter event type
func CoreToAdapter(eventType CoreEventType) EventType {
	return EventType(string(eventType))
}

// ----- EventBus Adapter -----

// EventBusBridge adapts a core EventBus to the local EventBus interface
// This maintains backward compatibility with legacy code
type EventBusBridge struct {
	core   CoreEventBus
	logger observability.Logger
}

// NewEventBusBridge creates a new adapter for the core EventBus
func NewEventBusBridge(core CoreEventBus, logger observability.Logger) *EventBusBridge {
	return &EventBusBridge{
		core:   core,
		logger: logger,
	}
}

// Publish publishes an event to the core event bus
func (b *EventBusBridge) Publish(ctx context.Context, event *mcp.Event) {
	if b.core != nil {
		b.core.Publish(ctx, event)
	}
}

// Subscribe converts and delegates a subscription to the core event bus
func (b *EventBusBridge) Subscribe(eventType EventType, listener EventListener) {
	if b.core == nil {
		return
	}

	// Create a handler that adapts from core to adapter format
	handler := CoreHandler(func(ctx context.Context, payload interface{}) {
		adapterEvent := &AdapterEvent{
			AdapterType: "bridge",
			EventType:   eventType,
			Payload:     payload,
			Timestamp:   time.Now().Unix(),
			Metadata:    make(map[string]interface{}),
		}

		_ = listener.Handle(ctx, adapterEvent)
	})

	b.core.Subscribe(AdapterToCore(eventType), handler)
}

// SubscribeAll subscribes to all events from the core event bus
func (b *EventBusBridge) SubscribeAll(listener EventListener) {
	if b.core == nil {
		return
	}

	// Create a handler that adapts from core to adapter format
	handler := CoreHandler(func(ctx context.Context, payload interface{}) {
		adapterEvent := &AdapterEvent{
			AdapterType: "bridge",
			EventType:   "unknown", // We don't know the specific type for wildcard handlers
			Payload:     payload,
			Timestamp:   time.Now().Unix(),
			Metadata:    make(map[string]interface{}),
		}

		_ = listener.Handle(ctx, adapterEvent)
	})

	b.core.Subscribe("*", handler)
}

// Close closes the underlying event bus
func (b *EventBusBridge) Close() error {
	if b.core != nil {
		b.core.Close()
	}
	return nil
}

// ----- Event Conversion Functions -----

// AdapterEventToCore converts an adapter event to a core event
func AdapterEventToCore(e *AdapterEvent) *CoreEvent {
	return &CoreEvent{
		Source:    e.AdapterType,
		Type:      string(e.EventType),
		Timestamp: time.Unix(e.Timestamp, 0),
		Data:      e.Payload,
		AgentID:   "", // Set as needed
		SessionID: "", // Set as needed
	}
}

// CoreEventToAdapter converts a core event to an adapter event
func CoreEventToAdapter(e *CoreEvent) *AdapterEvent {
	return &AdapterEvent{
		AdapterType: e.Source,
		EventType:   EventType(e.Type),
		Payload:     e.Data,
		Timestamp:   e.Timestamp.Unix(),
		Metadata:    map[string]interface{}{
			"agentId":   e.AgentID,
			"sessionId": e.SessionID,
		},
	}
}

// ----- Helper Functions -----

// TimeToUnix converts time.Time to Unix timestamp
func TimeToUnix(t time.Time) int64 {
	return t.Unix()
}

// UnixToTime converts Unix timestamp to time.Time
func UnixToTime(unix int64) time.Time {
	return time.Unix(unix, 0)
}

// CreateAdapterEvent creates a new adapter event
func CreateAdapterEvent(adapterType string, eventType EventType, payload interface{}) *AdapterEvent {
	return &AdapterEvent{
		AdapterType: adapterType,
		EventType:   eventType,
		Payload:     payload,
		Timestamp:   time.Now().Unix(),
		Metadata:    make(map[string]interface{}),
	}
}

// Type aliases to ensure the same types are used consistently across the codebase
type (
	// LegacyEventType is the type for adapter events
	LegacyEventType = string

	// LegacyAdapterEvent represents events in the adapter system
	LegacyAdapterEvent struct {
		AdapterType string
		EventType   LegacyEventType
		Payload     interface{}
		Timestamp   int64
		Metadata    map[string]interface{}
	}

	// LegacyEventListener handles legacy adapter events
	LegacyEventListener interface {
		Handle(ctx context.Context, event *LegacyAdapterEvent) error
	}

	// LegacyEventBus is the interface for the legacy event bus
	LegacyEventBus interface {
		Publish(ctx context.Context, event *mcp.Event)
		Subscribe(eventType LegacyEventType, listener LegacyEventListener)
		SubscribeAll(listener LegacyEventListener)
		Close() error
	}
)

// Event type constants for the legacy system
const (
	LegacyEventTypeOperationSuccess     LegacyEventType = "operation_success"
	LegacyEventTypeOperationFailure     LegacyEventType = "operation_failure"
	LegacyEventTypeAdapterHealthChanged LegacyEventType = "adapter_health_changed"
	LegacyEventTypeWebhookReceived     LegacyEventType = "webhook_received"
)

// LegacyEventBusAdapter adapts the modern events.EventBusIface to the legacy adapter event system
type LegacyEventBusAdapter struct {
	underlying events.EventBusIface
	logger     observability.Logger
}

// NewLegacyEventBusAdapter creates a new LegacyEventBusAdapter
func NewLegacyEventBusAdapter(bus events.EventBusIface, logger observability.Logger) LegacyEventBus {
	return &LegacyEventBusAdapter{
		underlying: bus,
		logger:     logger,
	}
}

// Publish publishes an event to the underlying event bus
func (a *LegacyEventBusAdapter) Publish(ctx context.Context, event *mcp.Event) {
	if a.underlying != nil {
		a.underlying.Publish(ctx, event)
	}
}

// Subscribe subscribes to events of the specified type
func (a *LegacyEventBusAdapter) Subscribe(eventType LegacyEventType, listener LegacyEventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler function that adapts the core event to a legacy adapter event
	handlerFunc := func(ctx context.Context, event interface{}) {
		// Convert the event to a legacy adapter event
		legacyEvent := &LegacyAdapterEvent{
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "core",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener with the legacy event
		if err := listener.Handle(ctx, legacyEvent); err != nil && a.logger != nil {
			a.logger.Warn("Error handling event", map[string]interface{}{
				"eventType": string(eventType),
				"error":     err.Error(),
			})
		}
	}
	
	// Subscribe to the underlying event bus with the adapted handler
	a.underlying.Subscribe(events.EventType(string(eventType)), events.Handler(handlerFunc))
}

// SubscribeAll subscribes to all events
func (a *LegacyEventBusAdapter) SubscribeAll(listener LegacyEventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler for all events
	handlerFunc := func(ctx context.Context, event interface{}) {
		// Create a legacy adapter event with a generic event type
		legacyEvent := &LegacyAdapterEvent{
			EventType:   "all",
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "core",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener with the legacy event
		if err := listener.Handle(ctx, legacyEvent); err != nil && a.logger != nil {
			a.logger.Warn("Error handling event", map[string]interface{}{
				"eventType": "all",
				"error":     err.Error(),
			})
		}
	}
	
	// Subscribe to all events in the underlying event bus
	a.underlying.Subscribe("*", events.Handler(handlerFunc))
}

// Close closes the event bus
func (a *LegacyEventBusAdapter) Close() error {
	// No-op implementation
	return nil
}

// CreateLegacyAdapterEvent creates a new legacy adapter event
func CreateLegacyAdapterEvent(adapterType string, eventType LegacyEventType, payload interface{}) *LegacyAdapterEvent {
	return &LegacyAdapterEvent{
		AdapterType: adapterType,
		EventType:   eventType,
		Payload:     payload,
		Timestamp:   time.Now().Unix(),
		Metadata:    make(map[string]interface{}),
	}
}

// AddMetadata adds metadata to a legacy adapter event
func (e *LegacyAdapterEvent) AddMetadata(key string, value interface{}) *LegacyAdapterEvent {
	if e.Metadata == nil {
		e.Metadata = make(map[string]interface{})
	}
	e.Metadata[key] = value
	return e
}

// TimeToUnix converts time.Time to Unix timestamp
func TimeToUnix(t time.Time) int64 {
	return t.Unix()
}

// Compatibility functions to bridge between the old and new event systems

// AdapterToSystemEvent converts a legacy adapter event to a system event
func AdapterToSystemEvent(event *LegacyAdapterEvent) *eventsystem.Event {
	if event == nil {
		return nil
	}
	
	return &eventsystem.Event{
		ID:        uuid.New().String(),
		Type:      string(event.EventType),
		Time:      time.Unix(event.Timestamp, 0),
		Data:      event.Payload,
		Metadata:  event.Metadata,
	}
}

// SystemToAdapterEvent converts a system event to a legacy adapter event
func SystemToAdapterEvent(event *eventsystem.Event) *LegacyAdapterEvent {
	if event == nil {
		return nil
	}
	
	return &LegacyAdapterEvent{
		AdapterType: "system",
		EventType:   LegacyEventType(event.Type),
		Payload:     event.Data,
		Timestamp:   event.Time.Unix(),
		Metadata:    event.Metadata,
	}
}

// MapEventType maps between current and legacy event types
func MapEventType(eventType EventType) LegacyEventType {
	switch eventType {
	case EventTypeOperationSuccess:
		return LegacyEventTypeOperationSuccess
	case EventTypeOperationFailure:
		return LegacyEventTypeOperationFailure
	case EventTypeAdapterHealthChanged:
		return LegacyEventTypeAdapterHealthChanged
	case EventTypeWebhookReceived:
		return LegacyEventTypeWebhookReceived
	default:
		return LegacyEventType(string(eventType))
	}
}

// MapLegacyEventType maps legacy event types to current event types
func MapLegacyEventType(legacyType LegacyEventType) EventType {
	switch legacyType {
	case LegacyEventTypeOperationSuccess:
		return EventTypeOperationSuccess
	case LegacyEventTypeOperationFailure:
		return EventTypeOperationFailure
	case LegacyEventTypeAdapterHealthChanged:
		return EventTypeAdapterHealthChanged
	case LegacyEventTypeWebhookReceived:
		return EventTypeWebhookReceived
	default:
		return EventType(string(legacyType))
	}
}

// AdapterToLegacyEvent converts an AdapterEvent to a LegacyAdapterEvent
func AdapterToLegacyEvent(event *AdapterEvent) *LegacyAdapterEvent {
	if event == nil {
		return nil
	}
	
	return &LegacyAdapterEvent{
		AdapterType: event.AdapterType,
		EventType:   MapEventType(event.EventType),
		Payload:     event.Payload,
		Timestamp:   TimeToUnix(event.Timestamp),
		Metadata:    event.Metadata,
	}
}

// LegacyToAdapterEvent converts a LegacyAdapterEvent to an AdapterEvent
func LegacyToAdapterEvent(event *LegacyAdapterEvent) *AdapterEvent {
	if event == nil {
		return nil
	}
	
	return &AdapterEvent{
		ID:          uuid.New().String(),
		AdapterType: event.AdapterType,
		EventType:   MapLegacyEventType(event.EventType),
		Payload:     event.Payload,
		Timestamp:   time.Unix(event.Timestamp, 0),
		Metadata:    event.Metadata,
	}
}

// LegacyToCoreEvent converts a LegacyAdapterEvent to a core Event
func LegacyToCoreEvent(event *LegacyAdapterEvent) *mcp.Event {
	if event == nil {
		return nil
	}
	
	return &mcp.Event{
		Type:    string(event.EventType),
		Payload: event.Payload,
	}
}

// CoreToLegacyEvent converts a core Event to a LegacyAdapterEvent
func CoreToLegacyEvent(event *mcp.Event) *LegacyAdapterEvent {
	if event == nil {
		return nil
	}
	
	return &LegacyAdapterEvent{
		AdapterType: "core",
		EventType:   LegacyEventType(event.Type),
		Payload:     event.Payload,
		Timestamp:   time.Now().Unix(),
		Metadata:    make(map[string]interface{}),
	}
}

// LegacyEventType represents an event type in the legacy adapter event system
type LegacyEventType string

// Legacy event type constants
const (
	LegacyEventTypeOperationSuccess     LegacyEventType = "operation_success"
	LegacyEventTypeOperationFailure     LegacyEventType = "operation_failure"
	LegacyEventTypeAdapterHealthChanged LegacyEventType = "health_changed"
	LegacyEventTypeWebhookReceived     LegacyEventType = "webhook_received"
)

// LegacyAdapterEvent represents an event from an adapter in the legacy format
type LegacyAdapterEvent struct {
	AdapterType string
	EventType   LegacyEventType
	Payload     interface{}
	Timestamp   int64
	Metadata    map[string]interface{}
}

// LegacyEventListener is the interface for legacy event listeners
type LegacyEventListener interface {
	// Handle handles a legacy adapter event
	Handle(ctx context.Context, event *LegacyAdapterEvent) error
}

// LegacyEventBus is the interface for legacy event bus implementations
type LegacyEventBus interface {
	// Publish publishes an event
	Publish(ctx context.Context, event *mcp.Event)
	// Subscribe subscribes to events of a specific type
	Subscribe(eventType LegacyEventType, listener LegacyEventListener)
	// SubscribeAll subscribes to all events
	SubscribeAll(listener LegacyEventListener)
	// Close closes the event bus
	Close() error
}

// LegacyEventBusAdapter adapts the core events.EventBusIface to the legacy adapter event system
type LegacyEventBusAdapter struct {
	underlying coreEvents.EventBusIface
	logger     observability.Logger
}

// NewLegacyEventBusAdapter creates a new LegacyEventBusAdapter
func NewLegacyEventBusAdapter(bus coreEvents.EventBusIface, logger observability.Logger) LegacyEventBus {
	return &LegacyEventBusAdapter{
		underlying: bus,
		logger:     logger,
	}
}

// Publish publishes an event to the underlying event bus
func (a *LegacyEventBusAdapter) Publish(ctx context.Context, event *mcp.Event) {
	if a.underlying != nil {
		a.underlying.Publish(ctx, event)
	}
}

// Subscribe subscribes to events of the specified type
func (a *LegacyEventBusAdapter) Subscribe(eventType LegacyEventType, listener LegacyEventListener) {
	if a.underlying == nil {
		return
	}
	
	// Map the legacy event type to the core event type
	coreEventType := coreEvents.EventType(string(eventType))
	
	// Create a handler function that adapts the core event to a legacy adapter event
	handler := func(ctx context.Context, event interface{}) {
		// Convert the event to a legacy adapter event
		legacyEvent := &LegacyAdapterEvent{
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "core",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener with the legacy event
		if err := listener.Handle(ctx, legacyEvent); err != nil && a.logger != nil {
			a.logger.Warn("Error handling event", map[string]interface{}{
				"eventType": string(eventType),
				"error":     err.Error(),
			})
		}
	}
	
	// Subscribe to the underlying event bus with the adapted handler
	a.underlying.Subscribe(coreEventType, coreEvents.Handler(handler))
}

// SubscribeAll subscribes to all events
func (a *LegacyEventBusAdapter) SubscribeAll(listener LegacyEventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler for all events
	handler := func(ctx context.Context, event interface{}) {
		// Create a legacy adapter event with a generic event type
		legacyEvent := &LegacyAdapterEvent{
			EventType:   "all",
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "core",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener with the legacy event
		if err := listener.Handle(ctx, legacyEvent); err != nil && a.logger != nil {
			a.logger.Warn("Error handling event", map[string]interface{}{
				"eventType": "all",
				"error":     err.Error(),
			})
		}
	}
	
	// Subscribe to all events in the underlying event bus
	a.underlying.Subscribe("*", coreEvents.Handler(handler))
}

// Close closes the event bus
func (a *LegacyEventBusAdapter) Close() error {
	// No-op implementation
	return nil
}

// CreateLegacyAdapterEvent creates a new legacy adapter event
func CreateLegacyAdapterEvent(adapterType string, eventType LegacyEventType, payload interface{}) *LegacyAdapterEvent {
	return &LegacyAdapterEvent{
		AdapterType: adapterType,
		EventType:   eventType,
		Payload:     payload,
		Timestamp:   time.Now().Unix(),
		Metadata:    make(map[string]interface{}),
	}
}

// AddMetadata adds metadata to a legacy adapter event
func (e *LegacyAdapterEvent) AddMetadata(key string, value interface{}) *LegacyAdapterEvent {
	if e.Metadata == nil {
		e.Metadata = make(map[string]interface{})
	}
	e.Metadata[key] = value
	return e
}

// TimeToUnix converts time.Time to Unix timestamp
func TimeToUnix(t time.Time) int64 {
	return t.Unix()
}

// ConvertAdapterEventToCore converts an AdapterEvent to a core Event
func ConvertAdapterEventToCore(event *AdapterEvent) *mcp.Event {
	// Create a new core event
	return &mcp.Event{
		ID:        event.ID,
		Type:      string(event.EventType),
		Timestamp: event.Timestamp,
		Payload:   event.Payload,
		Metadata:  event.Metadata,
	}
}

// ConvertCoreEventToAdapter converts a core Event to an AdapterEvent
func ConvertCoreEventToAdapter(event *mcp.Event) *AdapterEvent {
	return &AdapterEvent{
		ID:          event.ID,
		AdapterType: "core",
		EventType:   EventType(event.Type),
		Payload:     event.Payload,
		Timestamp:   event.Timestamp,
		Metadata:    event.Metadata,
	}
}

// HandlerAdapter adapts an EventListener to a core events.Handler
type HandlerAdapter struct {
	listener EventListener
	eventType EventType
}

// NewHandlerAdapter creates a new HandlerAdapter
func NewHandlerAdapter(listener EventListener, eventType EventType) coreEvents.Handler {
	return coreEvents.Handler(func(ctx context.Context, event interface{}) {
		// Create an adapter event
		adapterEvent := &AdapterEvent{
			ID:          uuid.New().String(),
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now(),
			AdapterType: "system",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener
		_ = listener.Handle(ctx, adapterEvent)
	})
}

// EventBusCompat adapts the core events.EventBusIface to the adapter EventBus interface
type EventBusCompat struct {
	underlying coreEvents.EventBusIface
}

// NewEventBusCompat creates a new EventBusCompat
func NewEventBusCompat(bus coreEvents.EventBusIface) EventBus {
	return &EventBusCompat{
		underlying: bus,
	}
}

// Publish publishes an event to the underlying event bus
func (a *EventBusCompat) Publish(ctx context.Context, event *mcp.Event) {
	if a.underlying != nil {
		a.underlying.Publish(ctx, event)
	}
}

// Subscribe subscribes to events of the specified type
func (a *EventBusCompat) Subscribe(eventType EventType, listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler for the specified event type
	handler := NewHandlerAdapter(listener, eventType)
	
	// Subscribe to the underlying event bus
	a.underlying.Subscribe(coreEvents.EventType(string(eventType)), handler)
}

// SubscribeAll subscribes to all events
func (a *EventBusCompat) SubscribeAll(listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler for all events
	handler := NewHandlerAdapter(listener, "*")
	
	// Subscribe to all events
	a.underlying.Subscribe("*", handler)
}

// Close closes the event bus
func (a *EventBusCompat) Close() error {
	// No-op implementation
	return nil
}

// Type aliases to prevent redeclaration issues
type (
	// EventType is an alias for the core event type
	EventType = string

	// AdapterEvent represents an event from an adapter
	AdapterEvent struct {
		AdapterType string
		EventType   EventType
		Payload     interface{}
		Timestamp   int64
		Metadata    map[string]interface{}
	}

	// EventListener is a function that handles AdapterEvents
	EventListener interface {
		Handle(ctx context.Context, event *AdapterEvent) error
	}

	// EventBus is the interface for publishing and subscribing to events
	EventBus interface {
		Publish(ctx context.Context, event *mcp.Event)
		Subscribe(eventType EventType, listener EventListener)
		SubscribeAll(listener EventListener)
		Close() error
	}
)

// Common event types
const (
	EventTypeOperationSuccess      EventType = "operation_success"
	EventTypeOperationFailure      EventType = "operation_failure"
	EventTypeAdapterHealthChanged  EventType = "adapter_health_changed"
	EventTypeWebhookReceived       EventType = "webhook_received"
)

// EventBusAdapter adapts the core EventBus interface to the adapter EventBus interface
type EventBusAdapter struct {
	underlying coreEvents.EventBusIface
}

// NewEventBusAdapter creates a new EventBusAdapter
func NewEventBusAdapter(bus coreEvents.EventBusIface) EventBus {
	return &EventBusAdapter{
		underlying: bus,
	}
}

// Publish publishes an event to the event bus
func (a *EventBusAdapter) Publish(ctx context.Context, event *mcp.Event) {
	if a.underlying != nil {
		a.underlying.Publish(ctx, event)
	}
}

// Subscribe subscribes to events of the specified type
func (a *EventBusAdapter) Subscribe(eventType EventType, listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Convert the event type to core event type
	coreEventType := coreEvents.EventType(eventType)
	
	// Create a handler that adapts the core event to an adapter event
	handler := func(ctx context.Context, event interface{}) {
		// Create an adapter event
		adapterEvent := &AdapterEvent{
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "system",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener
		_ = listener.Handle(ctx, adapterEvent)
	}
	
	// Subscribe to the underlying event bus
	a.underlying.Subscribe(coreEventType, coreEvents.Handler(handler))
}

// SubscribeAll subscribes to all events
func (a *EventBusAdapter) SubscribeAll(listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler for all events
	handler := func(ctx context.Context, event interface{}) {
		// Create an adapter event
		adapterEvent := &AdapterEvent{
			EventType:   "all",
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "system",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener
		_ = listener.Handle(ctx, adapterEvent)
	}
	
	// Subscribe with a wildcard pattern
	a.underlying.Subscribe("*", coreEvents.Handler(handler))
}

// Close closes the event bus
func (a *EventBusAdapter) Close() error {
	// No-op implementation
	return nil
}

// TimeToUnix converts time.Time to Unix timestamp
func TimeToUnix(t time.Time) int64 {
	return t.Unix()
}

// CreateAdapterEvent creates a new adapter event
func CreateAdapterEvent(adapterType string, eventType EventType, payload interface{}, metadata map[string]interface{}) *AdapterEvent {
	if metadata == nil {
		metadata = make(map[string]interface{})
	}
	
	return &AdapterEvent{
		AdapterType: adapterType,
		EventType:   eventType,
		Payload:     payload,
		Timestamp:   time.Now().Unix(),
		Metadata:    metadata,
	}
}

// AdapterEventBus is an alias to clarify that this is the standard adapter event bus
// This helps avoid redeclaration conflicts between EventBus interface and implementation
type AdapterEventBus = EventBus

// EventBusWrapper implements the EventBus interface by delegating to a events.EventBusIface
type EventBusWrapper struct {
	underlying events.EventBusIface
}

// NewEventBusWrapper creates a new EventBusWrapper for the given events.EventBusIface
func NewEventBusWrapper(bus events.EventBusIface) EventBus {
	return &EventBusWrapper{
		underlying: bus,
	}
}

// Publish publishes an event to the event bus
func (e *EventBusWrapper) Publish(ctx context.Context, event *mcp.Event) {
	if e.underlying != nil {
		e.underlying.Publish(ctx, event)
	}
}

// Subscribe subscribes to events of the specified type
func (e *EventBusWrapper) Subscribe(eventType EventType, listener EventListener) {
	if e.underlying == nil {
		return
	}
	
	// Create a handler for the listener
	handler := events.Handler(func(ctx context.Context, event interface{}) {
		// Create an adapter event
		adapterEvent := &AdapterEvent{
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "system",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener
		_ = listener.Handle(ctx, adapterEvent)
	})
	
	// Subscribe to the underlying event bus
	e.underlying.Subscribe(events.EventType(string(eventType)), handler)
}

// SubscribeAll subscribes to all events
func (e *EventBusWrapper) SubscribeAll(listener EventListener) {
	if e.underlying == nil {
		return
	}
	
	// Create a handler for all events
	handler := events.Handler(func(ctx context.Context, event interface{}) {
		// Create an adapter event
		adapterEvent := &AdapterEvent{
			EventType:   "all",
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "system",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener
		_ = listener.Handle(ctx, adapterEvent)
	})
	
	// Subscribe with a wildcard pattern
	e.underlying.Subscribe("*", handler)
}

// Close closes the event bus
func (e *EventBusWrapper) Close() error {
	// No-op implementation
	return nil
}

// ConvertTimeToUnix converts time.Time to Unix timestamp
func ConvertTimeToUnix(t time.Time) int64 {
	return t.Unix()
}

// Interface declaration validation to ensure our adapter implements the required interfaces
var _ EventBus = (*EventBusCompatAdapter)(nil)

// EventBusCompatAdapter provides compatibility between different event bus implementations
type EventBusCompatAdapter struct {
	underlying system.EventBus
}

// NewCompatEventBus creates a new EventBusCompatAdapter that wraps a system.EventBus
func NewCompatEventBus(bus system.EventBus) EventBus {
	if bus == nil {
		return nil
	}
	return &EventBusCompatAdapter{
		underlying: bus,
	}
}

// Publish publishes an event to the event bus
func (a *EventBusCompatAdapter) Publish(ctx context.Context, event *mcp.Event) {
	if a.underlying != nil {
		a.underlying.Publish(ctx, event)
	}
}

// Subscribe subscribes to events of a specific type
func (a *EventBusCompatAdapter) Subscribe(eventType EventType, listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Convert our event type to a system event type
	systemEventType := system.EventType(string(eventType))
	
	// Create a handler that adapts between the different handler types
	handler := func(ctx context.Context, event interface{}) {
		// Create an adapter event from the system event
		adapterEvent := &AdapterEvent{
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "system",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener and ignore any errors for simplicity
		if err := listener.Handle(ctx, adapterEvent); err != nil {
			fmt.Printf("Error handling event: %v\n", err)
		}
	}
	
	// Create a system handler that will call our local handler
	systemHandler := system.HandlerFunc(handler)
	
	// Subscribe to the underlying event bus with the converted types
	a.underlying.Subscribe(systemEventType, systemHandler)
}

// SubscribeAll subscribes to all events
func (a *EventBusCompatAdapter) SubscribeAll(listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler for all events
	handler := func(ctx context.Context, event interface{}) {
		// Determine the event type if possible
		var eventType EventType = "unknown"
		
		// Create an adapter event
		adapterEvent := &AdapterEvent{
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			AdapterType: "system",
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener and ignore any errors for simplicity
		if err := listener.Handle(ctx, adapterEvent); err != nil {
			fmt.Printf("Error handling event: %v\n", err)
		}
	}
	
	// Create a system handler and subscribe to all events
	systemHandler := system.HandlerFunc(handler)
	
	// Subscribe to all events using the appropriate method on the underlying bus
	a.underlying.SubscribeAll(systemHandler)
}

// Close closes the event bus
func (a *EventBusCompatAdapter) Close() error {
	// No-op implementation since the underlying event bus may not have a Close method
	return nil
}

// ConvertToUnixTimestamp converts a time.Time to Unix timestamp (seconds since epoch)
func ConvertToUnixTimestamp(t time.Time) int64 {
	return t.Unix()
}

// TimestampToTime converts a Unix timestamp to time.Time
func TimestampToTime(timestamp int64) time.Time {
	return time.Unix(timestamp, 0)
}

// ----- Bridge Implementation -----

// StandardEventBusAdapter bridges between pkg/events EventBusIface and adapter events.EventBus
type StandardEventBusAdapter struct {
	underlying corEvents.EventBusIface
}

// NewStandardEventBusAdapter creates a new adapter for the core events.EventBusIface
func NewStandardEventBusAdapter(bus corEvents.EventBusIface) EventBus {
	if bus == nil {
		return nil
	}
	return &StandardEventBusAdapter{
		underlying: bus,
	}
}

// Publish publishes an event to the underlying event bus
func (a *StandardEventBusAdapter) Publish(ctx context.Context, event *mcp.Event) {
	if a.underlying != nil {
		a.underlying.Publish(ctx, event)
	}
}

// Subscribe implements the adapter event bus's Subscribe method
func (a *StandardEventBusAdapter) Subscribe(eventType EventType, listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Convert the adapter event type to the core event type
	coreEventType := corEvents.EventType(string(eventType))
	
	// Create a handler that adapts the core event handler to the adapter event handler
	handler := corEvents.Handler(func(ctx context.Context, event interface{}) {
		// Convert the event to the format expected by the adapter event listener
		adapterEvent := &AdapterEvent{
			AdapterType: "adapter", // Generic adapter type
			EventType:   eventType,
			Payload:     event,
			Timestamp:   time.Now().Unix(), // Convert time.Time to int64 timestamp
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener with the adapted event
		if err := listener.Handle(ctx, adapterEvent); err != nil {
			// Log error if needed
		}
	})
	
	// Subscribe to the underlying event bus
	a.underlying.Subscribe(ctx, coreEventType, handler)
}

// SubscribeAll subscribes to all events
func (a *StandardEventBusAdapter) SubscribeAll(listener EventListener) {
	if a.underlying == nil {
		return
	}
	
	// Create a handler for all events
	handler := corEvents.Handler(func(ctx context.Context, event interface{}) {
		// Create a generic adapter event
		adapterEvent := &AdapterEvent{
			AdapterType: "adapter",
			EventType:   "all", // Generic event type for all events
			Payload:     event,
			Timestamp:   time.Now().Unix(),
			Metadata:    make(map[string]interface{}),
		}
		
		// Call the listener with the adapted event
		if err := listener.Handle(ctx, adapterEvent); err != nil {
			// Log error if needed
		}
	})
	
	// Use a wildcard pattern to subscribe to all events
	a.underlying.Subscribe(ctx, "*", handler)
}

// Close implements the Close method for the adapter's EventBus interface
func (a *StandardEventBusAdapter) Close() error {
	// No-op since the underlying bus may not have a Close method
	return nil
}

// ConvertSystemEventToAdapter converts a system.Event to an AdapterEvent
func ConvertSystemEventToAdapter(sysEvent system.Event) *AdapterEvent {
	return &AdapterEvent{
		AdapterType: "system",
		EventType:   EventType(string(sysEvent.Type())),
		Payload:     sysEvent,
		Timestamp:   time.Now().Unix(),
		Metadata:    make(map[string]interface{}),
	}
}

// ConvertAdapterEventToSystem converts an AdapterEvent to a system.BaseEvent
func ConvertAdapterEventToSystem(adapterEvent *AdapterEvent) *system.BaseEvent {
	baseEvent := &system.BaseEvent{
		EventType: system.EventType(string(adapterEvent.EventType)),
		Payload:   adapterEvent.Payload,
		Timestamp: time.Unix(adapterEvent.Timestamp, 0), // Convert int64 timestamp to time.Time
		Metadata:  adapterEvent.Metadata,
	}
	return baseEvent
}
