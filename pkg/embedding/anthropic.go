package embedding

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
)

const (
	// Default Anthropic API endpoint for embeddings
	defaultAnthropicEndpoint = "https://api.anthropic.com/v1/embeddings"
	// Default Anthropic model
	defaultAnthropicModel = "claude-3-5-haiku-20250531"
)

// AnthropicConfig contains configuration for the Anthropic API
type AnthropicConfig struct {
	// Anthropic API key
	APIKey string
	// Anthropic API endpoint (optional)
	Endpoint string
	// Anthropic model name
	Model string
	// For testing environments
	UseMockEmbeddings bool
}

// AnthropicEmbeddingService implements EmbeddingService using Anthropic
type AnthropicEmbeddingService struct {
	// HTTP client for making requests
	client *http.Client
	// Configuration for the embedding model
	config ModelConfig
	// Anthropic API key
	apiKey string
	// Anthropic API endpoint
	endpoint string
	// For testing environments when Anthropic API isn't available
	useMockEmbeddings bool
}

// AnthropicEmbeddingRequest represents a request to the Anthropic embeddings API
type AnthropicEmbeddingRequest struct {
	Model string   `json:"model"`
	Text  string   `json:"text"`
}

// AnthropicEmbeddingResponse represents a response from the Anthropic embeddings API
type AnthropicEmbeddingResponse struct {
	Object    string      `json:"object"`
	Embedding []float32   `json:"embedding"`
	Model     string      `json:"model"`
	Error     interface{} `json:"error,omitempty"`
}

// AnthropicBatchEmbeddingRequest represents a request to the Anthropic embeddings API for batch processing
type AnthropicBatchEmbeddingRequest struct {
	Model string   `json:"model"`
	Texts []string `json:"texts"`
}

// AnthropicBatchEmbeddingResponse represents a response from the Anthropic embeddings API for batch processing
type AnthropicBatchEmbeddingResponse struct {
	Object     string        `json:"object"`
	Embeddings [][]float32   `json:"embeddings"`
	Model      string        `json:"model"`
	Error      interface{}   `json:"error,omitempty"`
}

// NewAnthropicEmbeddingService creates a new Anthropic embedding service
func NewAnthropicEmbeddingService(config *AnthropicConfig) (*AnthropicEmbeddingService, error) {
	// Validate required fields
	if config.APIKey == "" {
		return nil, errors.New("API key is required")
	}

	// Use default model if not specified
	modelName := config.Model
	if modelName == "" {
		modelName = defaultAnthropicModel
	}

	// Validate model
	err := ValidateEmbeddingModel(ModelTypeAnthropic, modelName)
	if err != nil {
		return nil, err
	}

	// Get dimensions for the model
	dimensions, err := GetEmbeddingModelDimensions(ModelTypeAnthropic, modelName)
	if err != nil {
		return nil, err
	}

	// Use default endpoint if not specified
	endpoint := config.Endpoint
	if endpoint == "" {
		endpoint = defaultAnthropicEndpoint
	}

	// Create model configuration
	modelConfig := ModelConfig{
		Type:       ModelTypeAnthropic,
		Name:       modelName,
		Dimensions: dimensions,
	}

	// Create HTTP client
	client := &http.Client{}

	return &AnthropicEmbeddingService{
		client:           client,
		config:           modelConfig,
		apiKey:           config.APIKey,
		endpoint:         endpoint,
		useMockEmbeddings: config.UseMockEmbeddings,
	}, nil
}

// NewMockAnthropicEmbeddingService creates a mock Anthropic embedding service for testing
func NewMockAnthropicEmbeddingService(modelName string) (*AnthropicEmbeddingService, error) {
	// Use default model if not specified
	if modelName == "" {
		modelName = defaultAnthropicModel
	}

	// Validate model
	err := ValidateEmbeddingModel(ModelTypeAnthropic, modelName)
	if err != nil {
		return nil, err
	}

	// Get dimensions for the model
	dimensions, err := GetEmbeddingModelDimensions(ModelTypeAnthropic, modelName)
	if err != nil {
		return nil, err
	}

	// Create model configuration
	modelConfig := ModelConfig{
		Type:       ModelTypeAnthropic,
		Name:       modelName,
		Dimensions: dimensions,
	}

	// Create HTTP client
	client := &http.Client{}

	return &AnthropicEmbeddingService{
		client:           client,
		config:           modelConfig,
		apiKey:           "mock-api-key",
		endpoint:         defaultAnthropicEndpoint,
		useMockEmbeddings: true,
	}, nil
}

// GetModelConfig returns the model configuration
func (s *AnthropicEmbeddingService) GetModelConfig() ModelConfig {
	return s.config
}

// GetModelDimensions returns the dimensions of the embeddings generated by this model
func (s *AnthropicEmbeddingService) GetModelDimensions() int {
	return s.config.Dimensions
}

// GenerateEmbedding creates an embedding for a single text
func (s *AnthropicEmbeddingService) GenerateEmbedding(ctx context.Context, text string, contentType string, contentID string) (*EmbeddingVector, error) {
	if text == "" {
		return nil, errors.New("text is required")
	}

	var vector []float32
	var err error

	// Check if we should use mock embeddings (for testing environments)
	if s.useMockEmbeddings {
		// Generate mock embeddings when Anthropic API isn't available
		vector, err = generateMockEmbedding(text, s.config.Dimensions)
		if err != nil {
			return nil, fmt.Errorf("failed to generate mock embedding: %w", err)
		}
	} else {
		// Use the real Anthropic API
		// Create request payload
		requestData := AnthropicEmbeddingRequest{
			Model: s.config.Name,
			Text:  text,
		}

		// Convert request data to JSON
		requestBytes, err := json.Marshal(requestData)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request: %w", err)
		}

		// Create HTTP request
		req, err := http.NewRequestWithContext(ctx, http.MethodPost, s.endpoint, bytes.NewBuffer(requestBytes))
		if err != nil {
			return nil, fmt.Errorf("failed to create request: %w", err)
		}

		// Set headers
		req.Header.Set("Content-Type", "application/json")
		req.Header.Set("x-api-key", s.apiKey)
		req.Header.Set("anthropic-version", "2023-06-01")

		// Send request
		resp, err := s.client.Do(req)
		if err != nil {
			return nil, fmt.Errorf("failed to send request: %w", err)
		}
		defer resp.Body.Close()

		// Read response body
		responseBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response body: %w", err)
		}

		// Check response status
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("unexpected status code: %d, body: %s", resp.StatusCode, responseBody)
		}

		// Parse response
		var response AnthropicEmbeddingResponse
		err = json.Unmarshal(responseBody, &response)
		if err != nil {
			return nil, fmt.Errorf("failed to parse response: %w", err)
		}

		// Check for error in response
		if response.Error != nil {
			return nil, fmt.Errorf("API error: %v", response.Error)
		}

		// Get embedding
		vector = response.Embedding
	}

	// Create embedding vector
	return &EmbeddingVector{
		Vector:      vector,
		ContentID:   contentID,
		ContentType: contentType,
		ModelID:     s.config.Name,
		Dimensions:  s.config.Dimensions,
		Metadata:    nil,
	}, nil
}

// BatchGenerateEmbeddings creates embeddings for multiple texts
func (s *AnthropicEmbeddingService) BatchGenerateEmbeddings(ctx context.Context, texts []string, contentType string, contentIDs []string) ([]*EmbeddingVector, error) {
	if len(texts) == 0 {
		return nil, errors.New("no texts provided for embedding generation")
	}

	if len(texts) != len(contentIDs) {
		return nil, errors.New("number of texts must match number of content IDs")
	}

	// If using mock embeddings or if there's only one text, use individual requests
	if s.useMockEmbeddings || len(texts) == 1 {
		// Process each text individually
		embeddings := make([]*EmbeddingVector, len(texts))
		for i, text := range texts {
			embedding, err := s.GenerateEmbedding(ctx, text, contentType, contentIDs[i])
			if err != nil {
				return nil, fmt.Errorf("failed to generate embedding for text %d: %w", i, err)
			}
			embeddings[i] = embedding
		}
		return embeddings, nil
	}

	// Use batch processing for multiple texts
	// Create request payload
	requestData := AnthropicBatchEmbeddingRequest{
		Model: s.config.Name,
		Texts: texts,
	}

	// Convert request data to JSON
	requestBytes, err := json.Marshal(requestData)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal request: %w", err)
	}

	// Create HTTP request
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, s.endpoint, bytes.NewBuffer(requestBytes))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set headers
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("x-api-key", s.apiKey)
	req.Header.Set("anthropic-version", "2023-06-01")

	// Send request
	resp, err := s.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	responseBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check response status
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("unexpected status code: %d, body: %s", resp.StatusCode, responseBody)
	}

	// Parse response
	var response AnthropicBatchEmbeddingResponse
	err = json.Unmarshal(responseBody, &response)
	if err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	// Check for error in response
	if response.Error != nil {
		return nil, fmt.Errorf("API error: %v", response.Error)
	}

	// Create embedding vectors
	embeddings := make([]*EmbeddingVector, len(texts))
	for i, embedding := range response.Embeddings {
		embeddings[i] = &EmbeddingVector{
			Vector:      embedding,
			ContentID:   contentIDs[i],
			ContentType: contentType,
			ModelID:     s.config.Name,
			Dimensions:  s.config.Dimensions,
			Metadata:    nil,
		}
	}

	return embeddings, nil
}
