package embedding

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
	
	"github.com/google/uuid"
)

// ModelType represents the type of embedding model
type ModelType string

const (
	// ModelTypeOpenAI represents OpenAI embedding models
	ModelTypeOpenAI ModelType = "openai"
	// ModelTypeHuggingFace represents HuggingFace embedding models
	ModelTypeHuggingFace ModelType = "huggingface"
	// ModelTypeBedrock represents AWS Bedrock embedding models
	ModelTypeBedrock ModelType = "bedrock"
	// ModelTypeAnthropic represents direct Anthropic API embedding models
	ModelTypeAnthropic ModelType = "anthropic"
	// ModelTypeCustom represents custom embedding models
	ModelTypeCustom ModelType = "custom"
)

// ModelConfig contains configuration for embedding models
type ModelConfig struct {
	// Type of the embedding model
	Type ModelType `json:"type"`

	// Name/ID of the model
	Name string `json:"name"`

	// API key for the model service (if applicable)
	APIKey string `json:"api_key,omitempty"`

	// Endpoint URL for custom models
	Endpoint string `json:"endpoint,omitempty"`

	// Dimensions of the embedding vectors produced by this model
	Dimensions int `json:"dimensions"`

	// Additional configuration parameters specific to the model type
	Parameters map[string]interface{} `json:"parameters,omitempty"`
}

// EmbeddingVector represents a vector embedding with metadata
type EmbeddingVector struct {
	// The actual embedding vector values
	Vector []float32 `json:"vector"`

	// Dimensions of the vector
	Dimensions int `json:"dimensions"`

	// Model ID used to generate this embedding
	ModelID string `json:"model_id"`

	// ContentType indicates what type of content this is an embedding for
	ContentType string `json:"content_type"`

	// ContentID is a unique identifier for the content
	ContentID string `json:"content_id"`

	// Metadata about the embedding and content
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// EmbeddingService defines the interface for generating embeddings
type EmbeddingService interface {
	// GenerateEmbedding creates an embedding for a single text
	GenerateEmbedding(ctx context.Context, text string, contentType string, contentID string) (*EmbeddingVector, error)

	// BatchGenerateEmbeddings creates embeddings for multiple texts
	BatchGenerateEmbeddings(ctx context.Context, texts []string, contentType string, contentIDs []string) ([]*EmbeddingVector, error)

	// GetModelConfig returns the model configuration
	GetModelConfig() ModelConfig

	// GetModelDimensions returns the dimensions of the embeddings generated by this model
	GetModelDimensions() int
}

// EmbeddingStorage defines the interface for storing and retrieving embeddings
type EmbeddingStorage interface {
	// StoreEmbedding stores a single embedding
	StoreEmbedding(ctx context.Context, embedding *EmbeddingVector) error

	// BatchStoreEmbeddings stores multiple embeddings in a batch
	BatchStoreEmbeddings(ctx context.Context, embeddings []*EmbeddingVector) error

	// FindSimilarEmbeddings finds embeddings similar to the provided one
	FindSimilarEmbeddings(ctx context.Context, embedding *EmbeddingVector, limit int, threshold float32) ([]*EmbeddingVector, error)

	// GetEmbeddingsByContentIDs retrieves embeddings by content IDs
	GetEmbeddingsByContentIDs(ctx context.Context, contentIDs []string) ([]*EmbeddingVector, error)

	// DeleteEmbeddingsByContentIDs deletes embeddings by content IDs
	DeleteEmbeddingsByContentIDs(ctx context.Context, contentIDs []string) error
}

// EmbeddingPipeline coordinates the embedding generation and storage process
type EmbeddingPipeline interface {
	// ProcessContent processes content to generate and store embeddings
	ProcessContent(ctx context.Context, content string, contentType string, contentID string) error

	// BatchProcessContent processes multiple content items in a batch
	BatchProcessContent(ctx context.Context, contents []string, contentType string, contentIDs []string) error

	// ProcessCodeChunks processes code chunks to generate and store embeddings
	ProcessCodeChunks(ctx context.Context, contentType string, contentID string, chunkIDs []string) error

	// ProcessIssues processes GitHub issues to generate and store embeddings
	ProcessIssues(ctx context.Context, ownerRepo string, issueNumbers []int) error

	// ProcessDiscussions processes GitHub discussions to generate and store embeddings
	ProcessDiscussions(ctx context.Context, ownerRepo string, discussionIDs []string) error
}

// Service provides high-level embedding operations
type Service struct {
	repo      *Repository
	providers map[string]Provider
}

// Provider interface for embedding providers
type Provider interface {
	GenerateEmbedding(ctx context.Context, content string, model string) ([]float32, error)
	GetSupportedModels() []string
	ValidateAPIKey() error
}

// NewService creates a new embedding service
func NewService(repo *Repository) *Service {
	return &Service{
		repo:      repo,
		providers: make(map[string]Provider),
	}
}

// RegisterProvider adds an embedding provider
func (s *Service) RegisterProvider(name string, provider Provider) {
	s.providers[name] = provider
}

// CreateEmbedding generates and stores an embedding
func (s *Service) CreateEmbedding(ctx context.Context, req CreateEmbeddingRequest) (uuid.UUID, error) {
	// Get model information
	model, err := s.repo.GetModelByName(ctx, req.ModelName)
	if err != nil {
		return uuid.Nil, fmt.Errorf("failed to get model: %w", err)
	}
	
	// Get provider
	provider, ok := s.providers[model.Provider]
	if !ok {
		return uuid.Nil, fmt.Errorf("provider not registered: %s", model.Provider)
	}
	
	// Generate embedding
	embedding, err := provider.GenerateEmbedding(ctx, req.Content, req.ModelName)
	if err != nil {
		return uuid.Nil, fmt.Errorf("failed to generate embedding: %w", err)
	}
	
	// Create metadata
	metadata := map[string]interface{}{
		"source":      req.Source,
		"created_at":  time.Now().UTC().Format(time.RFC3339),
		"chunk_size":  len(req.Content),
	}
	
	if req.Metadata != nil {
		for k, v := range req.Metadata {
			metadata[k] = v
		}
	}
	
	metadataJSON, err := json.Marshal(metadata)
	if err != nil {
		return uuid.Nil, fmt.Errorf("failed to marshal metadata: %w", err)
	}
	
	// Insert embedding
	insertReq := InsertRequest{
		ContextID:            req.ContextID,
		Content:              req.Content,
		Embedding:            embedding,
		ModelName:            req.ModelName,
		TenantID:             req.TenantID,
		Metadata:             metadataJSON,
		ContentIndex:         req.ContentIndex,
		ChunkIndex:           req.ChunkIndex,
		ConfiguredDimensions: req.ConfiguredDimensions,
	}
	
	return s.repo.InsertEmbedding(ctx, insertReq)
}

// SearchSimilar performs similarity search
func (s *Service) SearchSimilar(ctx context.Context, req SearchSimilarRequest) ([]EmbeddingSearchResult, error) {
	// Get model information
	model, err := s.repo.GetModelByName(ctx, req.ModelName)
	if err != nil {
		return nil, fmt.Errorf("failed to get model: %w", err)
	}
	
	// Get provider
	provider, ok := s.providers[model.Provider]
	if !ok {
		return nil, fmt.Errorf("provider not registered: %s", model.Provider)
	}
	
	// Generate query embedding
	queryEmbedding, err := provider.GenerateEmbedding(ctx, req.Query, req.ModelName)
	if err != nil {
		return nil, fmt.Errorf("failed to generate query embedding: %w", err)
	}
	
	// Prepare metadata filter if provided
	var metadataFilter json.RawMessage
	if req.MetadataFilter != nil {
		filterJSON, err := json.Marshal(req.MetadataFilter)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal metadata filter: %w", err)
		}
		metadataFilter = filterJSON
	}
	
	// Search embeddings
	searchReq := SearchRequest{
		QueryEmbedding: queryEmbedding,
		ModelName:      req.ModelName,
		TenantID:       req.TenantID,
		ContextID:      req.ContextID,
		Limit:          req.Limit,
		Threshold:      req.Threshold,
		MetadataFilter: metadataFilter,
	}
	
	return s.repo.SearchEmbeddings(ctx, searchReq)
}

// GetAvailableModels returns all available embedding models
func (s *Service) GetAvailableModels(ctx context.Context, filter ModelFilter) ([]Model, error) {
	return s.repo.GetAvailableModels(ctx, filter)
}

// GetEmbeddingsByContext retrieves all embeddings for a context
func (s *Service) GetEmbeddingsByContext(ctx context.Context, contextID, tenantID uuid.UUID) ([]Embedding, error) {
	return s.repo.GetEmbeddingsByContext(ctx, contextID, tenantID)
}

// Service request types

type CreateEmbeddingRequest struct {
	ContextID            uuid.UUID              `json:"context_id"`
	Content              string                 `json:"content"`
	ModelName            string                 `json:"model_name"`
	TenantID             uuid.UUID              `json:"tenant_id"`
	Source               string                 `json:"source,omitempty"`
	ContentIndex         int                    `json:"content_index"`
	ChunkIndex           int                    `json:"chunk_index"`
	ConfiguredDimensions *int                   `json:"configured_dimensions,omitempty"`
	Metadata             map[string]interface{} `json:"metadata,omitempty"`
}

type SearchSimilarRequest struct {
	Query          string                 `json:"query"`
	ModelName      string                 `json:"model_name"`
	TenantID       uuid.UUID              `json:"tenant_id"`
	ContextID      *uuid.UUID             `json:"context_id,omitempty"`
	Limit          int                    `json:"limit"`
	Threshold      float64                `json:"threshold"`
	MetadataFilter map[string]interface{} `json:"metadata_filter,omitempty"`
}
