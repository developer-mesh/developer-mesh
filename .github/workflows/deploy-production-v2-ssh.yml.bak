name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-east-1
  EC2_INSTANCE_IP: ${{ secrets.EC2_INSTANCE_IP }}
  DEPLOYMENT_TIMEOUT: 600  # 10 minutes

jobs:
  pre-deployment:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    steps:
      - name: Check CI Status
        run: |
          echo "Checking CI status for commit ${{ github.sha }}"
          # Note: CI check is handled by branch protection rules

      - name: Verify Docker Images Exist
        run: |
          # Login to GHCR
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          # Docker metadata action creates shortened SHA tags (7 chars)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          
          for service in mcp-server rest-api worker; do
            # Try both latest and SHA-based tags
            IMAGE_BASE="ghcr.io/${OWNER}/devops-mcp-${service}"
            echo "Checking image: ${IMAGE_BASE}:latest"
            
            if docker pull "${IMAGE_BASE}:latest"; then
              echo "✓ Found ${IMAGE_BASE}:latest"
            else
              echo "Trying SHA-based tag: ${IMAGE_BASE}:main-${SHORT_SHA}"
              docker pull "${IMAGE_BASE}:main-${SHORT_SHA}" || {
                echo "ERROR: Could not find image for ${service}"
                exit 1
              }
            fi
          done

  deploy:
    name: Deploy Services
    needs: pre-deployment
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${{ env.EC2_INSTANCE_IP }}" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "Found instance: $INSTANCE_ID"

      - name: Create Deployment Package
        run: |
          mkdir -p deployment
          cp docker-compose.production.yml deployment/docker-compose.yml
          cp -r configs deployment/
          
          # Copy nginx configuration if it exists
          if [ -f deployments/nginx/mcp.conf ]; then
            mkdir -p deployment/nginx
            cp deployments/nginx/mcp.conf deployment/nginx/
          fi
          
          # Create .env file with secrets
          cat > deployment/.env << EOF
          # Database
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=5432
          DATABASE_USER=dbadmin
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_NAME=devops_mcp
          DATABASE_SSL_MODE=require
          
          # Redis
          REDIS_ADDR=${{ secrets.REDIS_ENDPOINT }}
          REDIS_TLS_ENABLED=true
          
          # AWS
          AWS_REGION=${{ env.AWS_REGION }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET=${{ secrets.S3_BUCKET }}
          SQS_QUEUE_URL=${{ secrets.SQS_QUEUE_URL }}
          
          # Application
          ENVIRONMENT=production
          ADMIN_API_KEY=${{ secrets.ADMIN_API_KEY }}
          GITHUB_TOKEN=${{ github.token }}
          MCP_SERVER_URL=http://mcp-server:8080
          
          # Image Tags (use shortened SHA to match what Docker metadata creates)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          IMAGE_TAG=main-${SHORT_SHA}
          EOF
          
          # Update docker-compose with new image tags (using shortened SHA)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          sed -i "s|:latest|:main-${SHORT_SHA}|g" deployment/docker-compose.yml

      - name: Transfer Deployment Package via S3
        run: |
          # Create a unique S3 key for this deployment
          DEPLOYMENT_KEY="deployments/${{ github.sha }}/deployment.tar.gz"
          
          # Create tarball of deployment directory
          tar -czf deployment.tar.gz deployment/
          
          # Upload to S3
          aws s3 cp deployment.tar.gz "s3://${{ secrets.S3_BUCKET }}/${DEPLOYMENT_KEY}"
          
          # Use SSM to download and extract on EC2
          aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'cd /home/ec2-user/devops-mcp',
              'aws s3 cp s3://${{ secrets.S3_BUCKET }}/${DEPLOYMENT_KEY} deployment.tar.gz',
              'tar -xzf deployment.tar.gz --strip-components=1',
              'rm deployment.tar.gz'
            ]" \
            --command-id "${{ github.run_id }}-transfer" \
            --output json
          
          # Wait for command to complete
          aws ssm wait command-executed \
            --command-id "${{ github.run_id }}-transfer" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"
          
      - name: Update Nginx Configuration
        run: |
          ssh -i ~/.ssh/ec2-key.pem ec2-user@${{ env.EC2_INSTANCE_IP }} << 'EOF'
            # Update nginx configuration if provided
            if [ -f /home/ec2-user/devops-mcp/nginx/mcp.conf ]; then
              echo "Updating nginx configuration..."
              sudo cp /etc/nginx/conf.d/mcp.conf /etc/nginx/conf.d/mcp.conf.backup.$(date +%Y%m%d_%H%M%S)
              sudo cp /home/ec2-user/devops-mcp/nginx/mcp.conf /etc/nginx/conf.d/mcp.conf
              
              # Test nginx configuration
              if sudo nginx -t; then
                sudo systemctl reload nginx
                echo "Nginx configuration updated successfully"
              else
                echo "Nginx configuration test failed, reverting..."
                sudo cp /etc/nginx/conf.d/mcp.conf.backup.$(ls -t /etc/nginx/conf.d/mcp.conf.backup.* | head -1 | cut -d. -f4) /etc/nginx/conf.d/mcp.conf
                exit 1
              fi
            fi
          EOF

      - name: Run Database Migrations
        if: ${{ github.event.inputs.skip_migrations != 'true' }}
        run: |
          ssh -i ~/.ssh/ec2-key.pem ec2-user@${{ env.EC2_INSTANCE_IP }} << 'EOF'
            cd /home/ec2-user/devops-mcp
            
            # Pull migration image
            docker pull migrate/migrate:latest
            
            # Run migrations
            docker run --rm \
              -v /home/ec2-user/devops-mcp/migrations:/migrations \
              migrate/migrate \
              -database "postgresql://dbadmin:${DATABASE_PASSWORD}@${DATABASE_HOST}:5432/devops_mcp?sslmode=require" \
              -path /migrations \
              up
          EOF

      - name: Deploy Services (Blue-Green)
        id: deploy
        run: |
          ssh -i ~/.ssh/ec2-key.pem ec2-user@${{ env.EC2_INSTANCE_IP }} << 'EOF'
            set -e
            cd /home/ec2-user/devops-mcp
            
            # Pull new images (using shortened SHA)
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            export IMAGE_TAG="main-${SHORT_SHA}"
            docker-compose pull
            
            # Start new containers with blue suffix
            docker-compose -p devops-mcp-blue up -d
            
            # Wait for health checks
            echo "Waiting for services to be healthy..."
            sleep 30
            
            # Check health
            for service in mcp-server rest-api worker; do
              container_name="devops-mcp-blue_${service}_1"
              if ! docker inspect $container_name --format='{{.State.Health.Status}}' | grep -q healthy; then
                echo "Service $service is not healthy"
                docker logs $container_name --tail 50
                exit 1
              fi
            done
            
            echo "All services are healthy"
          EOF

      - name: Switch Traffic
        run: |
          ssh -i ~/.ssh/ec2-key.pem ec2-user@${{ env.EC2_INSTANCE_IP }} << 'EOF'
            set -e
            cd /home/ec2-user/devops-mcp
            
            # Update Nginx upstream to point to blue containers
            sudo sed -i 's/localhost:8080/localhost:8082/g' /etc/nginx/conf.d/mcp.conf
            sudo sed -i 's/localhost:8081/localhost:8083/g' /etc/nginx/conf.d/mcp.conf
            
            # Reload Nginx
            sudo nginx -t && sudo systemctl reload nginx
            
            # Stop old containers
            docker-compose -p devops-mcp down || true
            
            # Rename blue to production
            docker-compose -p devops-mcp-blue down
            docker-compose -p devops-mcp up -d
            
            # Restore Nginx config
            sudo sed -i 's/localhost:8082/localhost:8080/g' /etc/nginx/conf.d/mcp.conf
            sudo sed -i 's/localhost:8083/localhost:8081/g' /etc/nginx/conf.d/mcp.conf
            sudo systemctl reload nginx
          EOF

      - name: Run Smoke Tests
        run: |
          # Test endpoints
          for url in https://mcp.dev-mesh.io/health https://api.dev-mesh.io/health; do
            echo "Testing $url"
            response=$(curl -s -o /dev/null -w "%{http_code}" $url)
            if [ $response -ne 200 ]; then
              echo "Health check failed for $url (HTTP $response)"
              exit 1
            fi
          done
          
          # Test functionality
          echo "Running API smoke tests..."
          
          # Test WebSocket endpoint
          echo "Testing WebSocket endpoint..."
          ws_response=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Connection: Upgrade" \
            -H "Upgrade: websocket" \
            -H "Sec-WebSocket-Version: 13" \
            -H "Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==" \
            "https://mcp.dev-mesh.io/ws")
          
          if [ "$ws_response" = "101" ] || [ "$ws_response" = "400" ] || [ "$ws_response" = "401" ]; then
            echo "WebSocket endpoint accessible (HTTP $ws_response)"
          else
            echo "Warning: WebSocket endpoint returned HTTP $ws_response"
          fi

      - name: Report Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful!"
            echo "- MCP Server: https://mcp.dev-mesh.io"
            echo "- REST API: https://api.dev-mesh.io"
          else
            echo "❌ Deployment failed"
          fi

  rollback:
    name: Rollback on Failure
    needs: deploy
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${{ env.EC2_INSTANCE_IP }}" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "Found instance: $INSTANCE_ID"

      - name: Perform Rollback
        run: |
          ssh -i ~/.ssh/ec2-key.pem ec2-user@${{ env.EC2_INSTANCE_IP }} << 'EOF'
            cd /home/ec2-user/devops-mcp
            
            # Stop blue containers if they exist
            docker-compose -p devops-mcp-blue down || true
            
            # Revert to latest tag
            sed -i "s|:main-.*|:latest|g" docker-compose.yml
            docker-compose pull
            docker-compose up -d
            
            echo "Rollback completed"
          EOF

      - name: Send Rollback Notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              text: "Production deployment rolled back",
              attachments: [{
                color: 'danger',
                text: 'Deployment of ${{ github.sha }} failed and was rolled back'
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

  post-deployment:
    name: Post-Deployment Tasks
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Clean Old Images
        run: |
          ssh -i ~/.ssh/ec2-key.pem ec2-user@${{ env.EC2_INSTANCE_IP }} << 'EOF'
            # Remove unused Docker images
            docker image prune -a -f --filter "until=24h"
          EOF

      - name: Send Success Notification
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: |
            Production deployment successful!
            • MCP Server: https://mcp.dev-mesh.io
            • REST API: https://api.dev-mesh.io
            • Commit: ${{ github.sha }}
            
            E2E tests will run automatically after this deployment.
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}