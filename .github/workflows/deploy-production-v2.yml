name: Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_migrations:
        description: 'Skip database migrations'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: us-east-1
  EC2_INSTANCE_IP: ${{ secrets.EC2_INSTANCE_IP }}
  DEPLOYMENT_TIMEOUT: 600  # 10 minutes

jobs:
  pre-deployment:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    steps:
      - name: Check CI Status
        run: |
          echo "Checking CI status for commit ${{ github.sha }}"
          # Note: CI check is handled by branch protection rules

      - name: Verify Docker Images Exist
        run: |
          # Login to GHCR
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
          
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          # Docker metadata action creates shortened SHA tags (7 chars)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          
          for service in mcp-server rest-api worker; do
            # Try both latest and SHA-based tags
            IMAGE_BASE="ghcr.io/${OWNER}/devops-mcp-${service}"
            echo "Checking image: ${IMAGE_BASE}:latest"
            
            if docker pull "${IMAGE_BASE}:latest"; then
              echo "✓ Found ${IMAGE_BASE}:latest"
            else
              echo "Trying SHA-based tag: ${IMAGE_BASE}:main-${SHORT_SHA}"
              docker pull "${IMAGE_BASE}:main-${SHORT_SHA}" || {
                echo "ERROR: Could not find image for ${service}"
                exit 1
              }
            fi
          done

  deploy:
    name: Deploy Services
    needs: pre-deployment
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${{ env.EC2_INSTANCE_IP }}" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "Found instance: $INSTANCE_ID"

      - name: Create Deployment Package
        run: |
          mkdir -p deployment
          cp docker-compose.production.yml deployment/docker-compose.yml
          cp -r configs deployment/
          
          # Copy nginx configuration if it exists
          if [ -f deployments/nginx/mcp.conf ]; then
            mkdir -p deployment/nginx
            cp deployments/nginx/mcp.conf deployment/nginx/
          fi
          
          # Create .env file with all necessary variables
          cat > deployment/.env << EOF
          # Database
          DATABASE_HOST=${{ secrets.DATABASE_HOST }}
          DATABASE_PORT=5432
          DATABASE_USER=dbadmin
          DATABASE_PASSWORD=${{ secrets.DATABASE_PASSWORD }}
          DATABASE_NAME=devops_mcp
          DATABASE_SSL_MODE=require
          
          # Redis
          REDIS_ADDR=${{ secrets.REDIS_ENDPOINT }}
          REDIS_TLS_ENABLED=true
          
          # AWS
          AWS_REGION=${{ env.AWS_REGION }}
          AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET=${{ secrets.S3_BUCKET }}
          SQS_QUEUE_URL=${{ secrets.SQS_QUEUE_URL }}
          
          # Application
          ENVIRONMENT=production
          ADMIN_API_KEY=${{ secrets.ADMIN_API_KEY }}
          GITHUB_TOKEN=${{ github.token }}
          MCP_SERVER_URL=http://mcp-server:8080
          
          # Image Tags (use shortened SHA to match what Docker metadata creates)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          IMAGE_TAG=main-${SHORT_SHA}
          EOF
          
          # Update docker-compose with new image tags (using shortened SHA)
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          sed -i "s|:latest|:main-${SHORT_SHA}|g" deployment/docker-compose.yml

      - name: Transfer Deployment Files
        run: |
          # Transfer docker-compose.yml content via SSM Parameter Store
          COMPOSE_CONTENT=$(cat deployment/docker-compose.yml | base64 -w 0)
          aws ssm put-parameter \
            --name "/devops-mcp/deployment/docker-compose-${{ github.sha }}" \
            --value "$COMPOSE_CONTENT" \
            --type "String" \
            --overwrite || true
          
          # Transfer .env content
          ENV_CONTENT=$(cat deployment/.env | base64 -w 0)
          aws ssm put-parameter \
            --name "/devops-mcp/deployment/env-${{ github.sha }}" \
            --value "$ENV_CONTENT" \
            --type "SecureString" \
            --overwrite || true
          
          # Transfer config files
          for file in deployment/configs/*.yaml; do
            if [ -f "$file" ]; then
              filename=$(basename "$file")
              CONTENT=$(cat "$file" | base64 -w 0)
              aws ssm put-parameter \
                --name "/devops-mcp/deployment/config-${filename}-${{ github.sha }}" \
                --value "$CONTENT" \
                --type "String" \
                --overwrite || true
            fi
          done
          
          # Use SSM to retrieve and apply files on EC2
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters "commands=[
              'cd /home/ec2-user/devops-mcp',
              'mkdir -p configs',
              'aws ssm get-parameter --name /devops-mcp/deployment/docker-compose-${{ github.sha }} --query Parameter.Value --output text | base64 -d > docker-compose.yml',
              'aws ssm get-parameter --name /devops-mcp/deployment/env-${{ github.sha }} --with-decryption --query Parameter.Value --output text | base64 -d > .env',
              'for param in $(aws ssm describe-parameters --parameter-filters Key=Name,Values=/devops-mcp/deployment/config-*-${{ github.sha }} --query Parameters[].Name --output text); do filename=$(echo $param | sed \"s|/devops-mcp/deployment/config-||g\" | sed \"s|-${{ github.sha }}||g\"); aws ssm get-parameter --name $param --query Parameter.Value --output text | base64 -d > configs/$filename; done',
              'chmod 600 .env',
              'echo \"Deployment files transferred successfully\"'
            ]" \
            --query "Command.CommandId" \
            --output text)
          
          # Wait for command to complete
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"
          
          # Clean up parameters after successful transfer
          aws ssm delete-parameter --name "/devops-mcp/deployment/docker-compose-${{ github.sha }}" || true
          aws ssm delete-parameter --name "/devops-mcp/deployment/env-${{ github.sha }}" || true
          for param in $(aws ssm describe-parameters --parameter-filters "Key=Name,Values=/devops-mcp/deployment/config-*-${{ github.sha }}" --query 'Parameters[].Name' --output text); do
            aws ssm delete-parameter --name "$param" || true
          done
          
      - name: Update Nginx Configuration
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "if [ -f /home/ec2-user/devops-mcp/nginx/mcp.conf ]; then",
              "  echo \"Updating nginx configuration...\"",
              "  sudo cp /etc/nginx/conf.d/mcp.conf /etc/nginx/conf.d/mcp.conf.backup.$(date +%Y%m%d_%H%M%S)",
              "  sudo cp /home/ec2-user/devops-mcp/nginx/mcp.conf /etc/nginx/conf.d/mcp.conf",
              "  if sudo nginx -t; then",
              "    sudo systemctl reload nginx",
              "    echo \"Nginx configuration updated successfully\"",
              "  else",
              "    echo \"Nginx configuration test failed, reverting...\"",
              "    sudo cp /etc/nginx/conf.d/mcp.conf.backup.$(ls -t /etc/nginx/conf.d/mcp.conf.backup.* | head -1 | xargs basename) /etc/nginx/conf.d/mcp.conf",
              "    exit 1",
              "  fi",
              "fi"
            ]' \
            --query "Command.CommandId" \
            --output text)
          
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"

      - name: Run Database Migrations
        if: ${{ github.event.inputs.skip_migrations != 'true' }}
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /home/ec2-user/devops-mcp",
              "source .env",
              "docker pull migrate/migrate:latest",
              "docker run --rm -v /home/ec2-user/devops-mcp/migrations:/migrations migrate/migrate -database \"postgresql://dbadmin:${DATABASE_PASSWORD}@${DATABASE_HOST}:5432/devops_mcp?sslmode=require\" -path /migrations up"
            ]' \
            --query "Command.CommandId" \
            --output text)
          
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"

      - name: Deploy Services (Blue-Green)
        id: deploy
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
          
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "set -e",
              "cd /home/ec2-user/devops-mcp",
              "export IMAGE_TAG=main-'$SHORT_SHA'",
              "docker-compose pull",
              "docker-compose -p devops-mcp-blue up -d",
              "echo \"Waiting for services to be healthy...\"",
              "sleep 30",
              "for service in mcp-server rest-api worker; do container_name=\"devops-mcp-blue_${service}_1\"; if ! docker inspect $container_name --format=\"{{.State.Health.Status}}\" | grep -q healthy; then echo \"Service $service is not healthy\"; docker logs $container_name --tail 50; exit 1; fi; done",
              "echo \"All services are healthy\""
            ]' \
            --query "Command.CommandId" \
            --output text)
          
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"

      - name: Switch Traffic
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /home/ec2-user/devops-mcp",
              "docker-compose down || true",
              "docker-compose -p devops-mcp-blue ps -q | xargs -I {} docker rename {} $(echo {} | sed \"s/blue/prod/g\") || true",
              "docker-compose -p devops-mcp up -d",
              "docker image prune -f"
            ]' \
            --query "Command.CommandId" \
            --output text)
          
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"

      - name: Smoke Test
        run: |
          echo "Running smoke tests..."
          sleep 10  # Give services time to stabilize
          
          # Test REST API health endpoint
          echo "Testing REST API health endpoint..."
          for i in {1..5}; do
            if curl -f -s "https://api.dev-mesh.io/health"; then
              echo "✓ REST API is healthy"
              break
            fi
            echo "Attempt $i failed, retrying..."
            sleep 5
          done
          
          # Test MCP health endpoint
          echo "Testing MCP health endpoint..."
          for i in {1..5}; do
            if curl -f -s "https://mcp.dev-mesh.io/health"; then
              echo "✓ MCP Server is healthy"
              break
            fi
            echo "Attempt $i failed, retrying..."
            sleep 5
          done
          
          # Test WebSocket endpoint
          echo "Testing WebSocket endpoint..."
          ws_response=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Connection: Upgrade" \
            -H "Upgrade: websocket" \
            -H "Sec-WebSocket-Version: 13" \
            -H "Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==" \
            "https://mcp.dev-mesh.io/ws")
          
          if [ "$ws_response" = "101" ] || [ "$ws_response" = "400" ] || [ "$ws_response" = "401" ]; then
            echo "WebSocket endpoint accessible (HTTP $ws_response)"
          else
            echo "Warning: WebSocket endpoint returned HTTP $ws_response"
          fi

      - name: Report Deployment Status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful!"
            echo "- MCP Server: https://mcp.dev-mesh.io"
            echo "- REST API: https://api.dev-mesh.io"
          else
            echo "❌ Deployment failed"
          fi

  rollback:
    name: Rollback on Failure
    needs: deploy
    if: failure()
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Instance ID
        id: get-instance
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=ip-address,Values=${{ env.EC2_INSTANCE_IP }}" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "Found instance: $INSTANCE_ID"

      - name: Perform Rollback
        run: |
          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${{ steps.get-instance.outputs.instance_id }}" \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "cd /home/ec2-user/devops-mcp",
              "echo \"Starting rollback...\"",
              "docker-compose -p devops-mcp-blue down || true",
              "docker-compose restart",
              "docker-compose ps",
              "echo \"Rollback completed\""
            ]' \
            --query "Command.CommandId" \
            --output text)
          
          aws ssm wait command-executed \
            --command-id "${COMMAND_ID}" \
            --instance-id "${{ steps.get-instance.outputs.instance_id }}"